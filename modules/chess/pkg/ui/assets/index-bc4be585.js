var mh = Object.defineProperty; var vh = (e, t, n) => t in e ? mh(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n; var ze = (e, t, n) => (vh(e, typeof t != "symbol" ? t + "" : t, n), n); (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const o of i) if (o.type === "childList") for (const s of o.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && r(s) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const o = {}; return i.integrity && (o.integrity = i.integrity), i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? o.credentials = "include" : i.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function r(i) { if (i.ep) return; i.ep = !0; const o = n(i); fetch(i.href, o) } })(); function uc(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var ac = { exports: {} }, so = {}, cc = { exports: {} }, b = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Wr = Symbol.for("react.element"), yh = Symbol.for("react.portal"), Sh = Symbol.for("react.fragment"), wh = Symbol.for("react.strict_mode"), Eh = Symbol.for("react.profiler"), Ch = Symbol.for("react.provider"), kh = Symbol.for("react.context"), _h = Symbol.for("react.forward_ref"), xh = Symbol.for("react.suspense"), Oh = Symbol.for("react.memo"), Th = Symbol.for("react.lazy"), ku = Symbol.iterator; function Dh(e) { return e === null || typeof e != "object" ? null : (e = ku && e[ku] || e["@@iterator"], typeof e == "function" ? e : null) } var dc = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, fc = Object.assign, hc = {}; function Kn(e, t, n) { this.props = e, this.context = t, this.refs = hc, this.updater = n || dc } Kn.prototype.isReactComponent = {}; Kn.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; Kn.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function pc() { } pc.prototype = Kn.prototype; function El(e, t, n) { this.props = e, this.context = t, this.refs = hc, this.updater = n || dc } var Cl = El.prototype = new pc; Cl.constructor = El; fc(Cl, Kn.prototype); Cl.isPureReactComponent = !0; var _u = Array.isArray, gc = Object.prototype.hasOwnProperty, kl = { current: null }, mc = { key: !0, ref: !0, __self: !0, __source: !0 }; function vc(e, t, n) { var r, i = {}, o = null, s = null; if (t != null) for (r in t.ref !== void 0 && (s = t.ref), t.key !== void 0 && (o = "" + t.key), t) gc.call(t, r) && !mc.hasOwnProperty(r) && (i[r] = t[r]); var l = arguments.length - 2; if (l === 1) i.children = n; else if (1 < l) { for (var u = Array(l), a = 0; a < l; a++)u[a] = arguments[a + 2]; i.children = u } if (e && e.defaultProps) for (r in l = e.defaultProps, l) i[r] === void 0 && (i[r] = l[r]); return { $$typeof: Wr, type: e, key: o, ref: s, props: i, _owner: kl.current } } function Ph(e, t) { return { $$typeof: Wr, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function _l(e) { return typeof e == "object" && e !== null && e.$$typeof === Wr } function Nh(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var xu = /\/+/g; function zo(e, t) { return typeof e == "object" && e !== null && e.key != null ? Nh("" + e.key) : t.toString(36) } function wi(e, t, n, r, i) { var o = typeof e; (o === "undefined" || o === "boolean") && (e = null); var s = !1; if (e === null) s = !0; else switch (o) { case "string": case "number": s = !0; break; case "object": switch (e.$$typeof) { case Wr: case yh: s = !0 } }if (s) return s = e, i = i(s), e = r === "" ? "." + zo(s, 0) : r, _u(i) ? (n = "", e != null && (n = e.replace(xu, "$&/") + "/"), wi(i, t, n, "", function (a) { return a })) : i != null && (_l(i) && (i = Ph(i, n + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(xu, "$&/") + "/") + e)), t.push(i)), 1; if (s = 0, r = r === "" ? "." : r + ":", _u(e)) for (var l = 0; l < e.length; l++) { o = e[l]; var u = r + zo(o, l); s += wi(o, t, n, u, i) } else if (u = Dh(e), typeof u == "function") for (e = u.call(e), l = 0; !(o = e.next()).done;)o = o.value, u = r + zo(o, l++), s += wi(o, t, n, u, i); else if (o === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return s } function ei(e, t, n) { if (e == null) return e; var r = [], i = 0; return wi(e, r, "", "", function (o) { return t.call(n, o, i++) }), r } function Ih(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n) }, function (n) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var Se = { current: null }, Ei = { transition: null }, Lh = { ReactCurrentDispatcher: Se, ReactCurrentBatchConfig: Ei, ReactCurrentOwner: kl }; b.Children = { map: ei, forEach: function (e, t, n) { ei(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return ei(e, function () { t++ }), t }, toArray: function (e) { return ei(e, function (t) { return t }) || [] }, only: function (e) { if (!_l(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; b.Component = Kn; b.Fragment = Sh; b.Profiler = Eh; b.PureComponent = El; b.StrictMode = wh; b.Suspense = xh; b.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Lh; b.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = fc({}, e.props), i = e.key, o = e.ref, s = e._owner; if (t != null) { if (t.ref !== void 0 && (o = t.ref, s = kl.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps; for (u in t) gc.call(t, u) && !mc.hasOwnProperty(u) && (r[u] = t[u] === void 0 && l !== void 0 ? l[u] : t[u]) } var u = arguments.length - 2; if (u === 1) r.children = n; else if (1 < u) { l = Array(u); for (var a = 0; a < u; a++)l[a] = arguments[a + 2]; r.children = l } return { $$typeof: Wr, type: e.type, key: i, ref: o, props: r, _owner: s } }; b.createContext = function (e) { return e = { $$typeof: kh, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: Ch, _context: e }, e.Consumer = e }; b.createElement = vc; b.createFactory = function (e) { var t = vc.bind(null, e); return t.type = e, t }; b.createRef = function () { return { current: null } }; b.forwardRef = function (e) { return { $$typeof: _h, render: e } }; b.isValidElement = _l; b.lazy = function (e) { return { $$typeof: Th, _payload: { _status: -1, _result: e }, _init: Ih } }; b.memo = function (e, t) { return { $$typeof: Oh, type: e, compare: t === void 0 ? null : t } }; b.startTransition = function (e) { var t = Ei.transition; Ei.transition = {}; try { e() } finally { Ei.transition = t } }; b.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; b.useCallback = function (e, t) { return Se.current.useCallback(e, t) }; b.useContext = function (e) { return Se.current.useContext(e) }; b.useDebugValue = function () { }; b.useDeferredValue = function (e) { return Se.current.useDeferredValue(e) }; b.useEffect = function (e, t) { return Se.current.useEffect(e, t) }; b.useId = function () { return Se.current.useId() }; b.useImperativeHandle = function (e, t, n) { return Se.current.useImperativeHandle(e, t, n) }; b.useInsertionEffect = function (e, t) { return Se.current.useInsertionEffect(e, t) }; b.useLayoutEffect = function (e, t) { return Se.current.useLayoutEffect(e, t) }; b.useMemo = function (e, t) { return Se.current.useMemo(e, t) }; b.useReducer = function (e, t, n) { return Se.current.useReducer(e, t, n) }; b.useRef = function (e) { return Se.current.useRef(e) }; b.useState = function (e) { return Se.current.useState(e) }; b.useSyncExternalStore = function (e, t, n) { return Se.current.useSyncExternalStore(e, t, n) }; b.useTransition = function () { return Se.current.useTransition() }; b.version = "18.2.0"; cc.exports = b; var C = cc.exports; const yc = uc(C);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var jh = C, Rh = Symbol.for("react.element"), Mh = Symbol.for("react.fragment"), Ah = Object.prototype.hasOwnProperty, bh = jh.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, zh = { key: !0, ref: !0, __self: !0, __source: !0 }; function Sc(e, t, n) { var r, i = {}, o = null, s = null; n !== void 0 && (o = "" + n), t.key !== void 0 && (o = "" + t.key), t.ref !== void 0 && (s = t.ref); for (r in t) Ah.call(t, r) && !zh.hasOwnProperty(r) && (i[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) i[r] === void 0 && (i[r] = t[r]); return { $$typeof: Rh, type: e, key: o, ref: s, props: i, _owner: bh.current } } so.Fragment = Mh; so.jsx = Sc; so.jsxs = Sc; ac.exports = so; var S = ac.exports, Es = {}, wc = { exports: {} }, Re = {}, Ec = { exports: {} }, Cc = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(D, N) { var j = D.length; D.push(N); e: for (; 0 < j;) { var H = j - 1 >>> 1, X = D[H]; if (0 < i(X, N)) D[H] = N, D[j] = X, j = H; else break e } } function n(D) { return D.length === 0 ? null : D[0] } function r(D) { if (D.length === 0) return null; var N = D[0], j = D.pop(); if (j !== N) { D[0] = j; e: for (var H = 0, X = D.length, ot = X >>> 1; H < ot;) { var A = 2 * (H + 1) - 1, ft = D[A], Ge = A + 1, vn = D[Ge]; if (0 > i(ft, j)) Ge < X && 0 > i(vn, ft) ? (D[H] = vn, D[Ge] = j, H = Ge) : (D[H] = ft, D[A] = j, H = A); else if (Ge < X && 0 > i(vn, j)) D[H] = vn, D[Ge] = j, H = Ge; else break e } } return N } function i(D, N) { var j = D.sortIndex - N.sortIndex; return j !== 0 ? j : D.id - N.id } if (typeof performance == "object" && typeof performance.now == "function") { var o = performance; e.unstable_now = function () { return o.now() } } else { var s = Date, l = s.now(); e.unstable_now = function () { return s.now() - l } } var u = [], a = [], g = 1, p = null, f = 3, y = !1, m = !1, v = !1, E = typeof setTimeout == "function" ? setTimeout : null, d = typeof clearTimeout == "function" ? clearTimeout : null, c = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function h(D) { for (var N = n(a); N !== null;) { if (N.callback === null) r(a); else if (N.startTime <= D) r(a), N.sortIndex = N.expirationTime, t(u, N); else break; N = n(a) } } function w(D) { if (v = !1, h(D), !m) if (n(u) !== null) m = !0, Ee(k); else { var N = n(a); N !== null && dt(w, N.startTime - D) } } function k(D, N) { m = !1, v && (v = !1, d(T), T = -1), y = !0; var j = f; try { for (h(N), p = n(u); p !== null && (!(p.expirationTime > N) || D && !$());) { var H = p.callback; if (typeof H == "function") { p.callback = null, f = p.priorityLevel; var X = H(p.expirationTime <= N); N = e.unstable_now(), typeof X == "function" ? p.callback = X : p === n(u) && r(u), h(N) } else r(u); p = n(u) } if (p !== null) var ot = !0; else { var A = n(a); A !== null && dt(w, A.startTime - N), ot = !1 } return ot } finally { p = null, f = j, y = !1 } } var O = !1, x = null, T = -1, z = 5, M = -1; function $() { return !(e.unstable_now() - M < z) } function K() { if (x !== null) { var D = e.unstable_now(); M = D; var N = !0; try { N = x(!0, D) } finally { N ? Ae() : (O = !1, x = null) } } else O = !1 } var Ae; if (typeof c == "function") Ae = function () { c(K) }; else if (typeof MessageChannel < "u") { var be = new MessageChannel, qe = be.port2; be.port1.onmessage = K, Ae = function () { qe.postMessage(null) } } else Ae = function () { E(K, 0) }; function Ee(D) { x = D, O || (O = !0, Ae()) } function dt(D, N) { T = E(function () { D(e.unstable_now()) }, N) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (D) { D.callback = null }, e.unstable_continueExecution = function () { m || y || (m = !0, Ee(k)) }, e.unstable_forceFrameRate = function (D) { 0 > D || 125 < D ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : z = 0 < D ? Math.floor(1e3 / D) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return f }, e.unstable_getFirstCallbackNode = function () { return n(u) }, e.unstable_next = function (D) { switch (f) { case 1: case 2: case 3: var N = 3; break; default: N = f }var j = f; f = N; try { return D() } finally { f = j } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (D, N) { switch (D) { case 1: case 2: case 3: case 4: case 5: break; default: D = 3 }var j = f; f = D; try { return N() } finally { f = j } }, e.unstable_scheduleCallback = function (D, N, j) { var H = e.unstable_now(); switch (typeof j == "object" && j !== null ? (j = j.delay, j = typeof j == "number" && 0 < j ? H + j : H) : j = H, D) { case 1: var X = -1; break; case 2: X = 250; break; case 5: X = 1073741823; break; case 4: X = 1e4; break; default: X = 5e3 }return X = j + X, D = { id: g++, callback: N, priorityLevel: D, startTime: j, expirationTime: X, sortIndex: -1 }, j > H ? (D.sortIndex = j, t(a, D), n(u) === null && D === n(a) && (v ? (d(T), T = -1) : v = !0, dt(w, j - H))) : (D.sortIndex = X, t(u, D), m || y || (m = !0, Ee(k))), D }, e.unstable_shouldYield = $, e.unstable_wrapCallback = function (D) { var N = f; return function () { var j = f; f = N; try { return D.apply(this, arguments) } finally { f = j } } } })(Cc); Ec.exports = Cc; var Fh = Ec.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var kc = C, je = Fh; function _(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var _c = new Set, kr = {}; function pn(e, t) { Fn(e, t), Fn(e + "Capture", t) } function Fn(e, t) { for (kr[e] = t, e = 0; e < t.length; e++)_c.add(t[e]) } var St = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Cs = Object.prototype.hasOwnProperty, $h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Ou = {}, Tu = {}; function Uh(e) { return Cs.call(Tu, e) ? !0 : Cs.call(Ou, e) ? !1 : $h.test(e) ? Tu[e] = !0 : (Ou[e] = !0, !1) } function Hh(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function Wh(e, t, n, r) { if (t === null || typeof t > "u" || Hh(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function we(e, t, n, r, i, o, s) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = s } var ce = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { ce[e] = new we(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; ce[t] = new we(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { ce[e] = new we(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { ce[e] = new we(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { ce[e] = new we(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { ce[e] = new we(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { ce[e] = new we(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { ce[e] = new we(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { ce[e] = new we(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var xl = /[\-:]([a-z])/g; function Ol(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(xl, Ol); ce[t] = new we(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(xl, Ol); ce[t] = new we(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(xl, Ol); ce[t] = new we(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { ce[e] = new we(e, 1, !1, e.toLowerCase(), null, !1, !1) }); ce.xlinkHref = new we("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { ce[e] = new we(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function Tl(e, t, n, r) { var i = ce.hasOwnProperty(t) ? ce[t] : null; (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (Wh(t, n, i, r) && (n = null), r || i === null ? Uh(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var kt = kc.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ti = Symbol.for("react.element"), En = Symbol.for("react.portal"), Cn = Symbol.for("react.fragment"), Dl = Symbol.for("react.strict_mode"), ks = Symbol.for("react.profiler"), xc = Symbol.for("react.provider"), Oc = Symbol.for("react.context"), Pl = Symbol.for("react.forward_ref"), _s = Symbol.for("react.suspense"), xs = Symbol.for("react.suspense_list"), Nl = Symbol.for("react.memo"), Nt = Symbol.for("react.lazy"), Tc = Symbol.for("react.offscreen"), Du = Symbol.iterator; function Yn(e) { return e === null || typeof e != "object" ? null : (e = Du && e[Du] || e["@@iterator"], typeof e == "function" ? e : null) } var Y = Object.assign, Fo; function lr(e) {
    if (Fo === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); Fo = t && t[1] || "" } return `
`+ Fo + e
} var $o = !1; function Uo(e, t) {
    if (!e || $o) return ""; $o = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (a) { var r = a } Reflect.construct(e, [], t) } else { try { t.call() } catch (a) { r = a } e.call(t.prototype) } else { try { throw Error() } catch (a) { r = a } e() } } catch (a) {
        if (a && r && typeof a.stack == "string") {
            for (var i = a.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, l = o.length - 1; 1 <= s && 0 <= l && i[s] !== o[l];)l--; for (; 1 <= s && 0 <= l; s--, l--)if (i[s] !== o[l]) {
                if (s !== 1 || l !== 1) do if (s--, l--, 0 > l || i[s] !== o[l]) {
                    var u = `
`+ i[s].replace(" at new ", " at "); return e.displayName && u.includes("<anonymous>") && (u = u.replace("<anonymous>", e.displayName)), u
                } while (1 <= s && 0 <= l); break
            }
        }
    } finally { $o = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? lr(e) : ""
} function Bh(e) { switch (e.tag) { case 5: return lr(e.type); case 16: return lr("Lazy"); case 13: return lr("Suspense"); case 19: return lr("SuspenseList"); case 0: case 2: case 15: return e = Uo(e.type, !1), e; case 11: return e = Uo(e.type.render, !1), e; case 1: return e = Uo(e.type, !0), e; default: return "" } } function Os(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case Cn: return "Fragment"; case En: return "Portal"; case ks: return "Profiler"; case Dl: return "StrictMode"; case _s: return "Suspense"; case xs: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case Oc: return (e.displayName || "Context") + ".Consumer"; case xc: return (e._context.displayName || "Context") + ".Provider"; case Pl: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case Nl: return t = e.displayName || null, t !== null ? t : Os(e.type) || "Memo"; case Nt: t = e._payload, e = e._init; try { return Os(e(t)) } catch { } }return null } function Vh(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Os(t); case 8: return t === Dl ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function Kt(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function Dc(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function Qh(e) { var t = Dc(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, o = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (s) { r = "" + s, o.call(this, s) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (s) { r = "" + s }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function ni(e) { e._valueTracker || (e._valueTracker = Qh(e)) } function Pc(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = Dc(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1 } function Mi(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Ts(e, t) { var n = t.checked; return Y({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function Pu(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = Kt(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function Nc(e, t) { t = t.checked, t != null && Tl(e, "checked", t, !1) } function Ds(e, t) { Nc(e, t); var n = Kt(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? Ps(e, t.type, n) : t.hasOwnProperty("defaultValue") && Ps(e, t.type, Kt(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function Nu(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function Ps(e, t, n) { (t !== "number" || Mi(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var ur = Array.isArray; function jn(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + Kt(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) { e[i].selected = !0, r && (e[i].defaultSelected = !0); return } t !== null || e[i].disabled || (t = e[i]) } t !== null && (t.selected = !0) } } function Ns(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(_(91)); return Y({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function Iu(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(_(92)); if (ur(n)) { if (1 < n.length) throw Error(_(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: Kt(n) } } function Ic(e, t) { var n = Kt(t.value), r = Kt(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function Lu(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function Lc(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Is(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? Lc(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var ri, jc = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, i) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (ri = ri || document.createElement("div"), ri.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ri.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function _r(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var fr = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Kh = ["Webkit", "ms", "Moz", "O"]; Object.keys(fr).forEach(function (e) { Kh.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), fr[t] = fr[e] }) }); function Rc(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || fr.hasOwnProperty(e) && fr[e] ? ("" + t).trim() : t + "px" } function Mc(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = Rc(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } var qh = Y({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Ls(e, t) { if (t) { if (qh[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(_(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(_(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(_(61)) } if (t.style != null && typeof t.style != "object") throw Error(_(62)) } } function js(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Rs = null; function Il(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var Ms = null, Rn = null, Mn = null; function ju(e) { if (e = Qr(e)) { if (typeof Ms != "function") throw Error(_(280)); var t = e.stateNode; t && (t = fo(t), Ms(e.stateNode, e.type, t)) } } function Ac(e) { Rn ? Mn ? Mn.push(e) : Mn = [e] : Rn = e } function bc() { if (Rn) { var e = Rn, t = Mn; if (Mn = Rn = null, ju(e), t) for (e = 0; e < t.length; e++)ju(t[e]) } } function zc(e, t) { return e(t) } function Fc() { } var Ho = !1; function $c(e, t, n) { if (Ho) return e(t, n); Ho = !0; try { return zc(e, t, n) } finally { Ho = !1, (Rn !== null || Mn !== null) && (Fc(), bc()) } } function xr(e, t) { var n = e.stateNode; if (n === null) return null; var r = fo(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(_(231, t, typeof n)); return n } var As = !1; if (St) try { var Xn = {}; Object.defineProperty(Xn, "passive", { get: function () { As = !0 } }), window.addEventListener("test", Xn, Xn), window.removeEventListener("test", Xn, Xn) } catch { As = !1 } function Gh(e, t, n, r, i, o, s, l, u) { var a = Array.prototype.slice.call(arguments, 3); try { t.apply(n, a) } catch (g) { this.onError(g) } } var hr = !1, Ai = null, bi = !1, bs = null, Yh = { onError: function (e) { hr = !0, Ai = e } }; function Xh(e, t, n, r, i, o, s, l, u) { hr = !1, Ai = null, Gh.apply(Yh, arguments) } function Jh(e, t, n, r, i, o, s, l, u) { if (Xh.apply(this, arguments), hr) { if (hr) { var a = Ai; hr = !1, Ai = null } else throw Error(_(198)); bi || (bi = !0, bs = a) } } function gn(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function Uc(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function Ru(e) { if (gn(e) !== e) throw Error(_(188)) } function Zh(e) { var t = e.alternate; if (!t) { if (t = gn(e), t === null) throw Error(_(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (i === null) break; var o = i.alternate; if (o === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === o.child) { for (o = i.child; o;) { if (o === n) return Ru(i), e; if (o === r) return Ru(i), t; o = o.sibling } throw Error(_(188)) } if (n.return !== r.return) n = i, r = o; else { for (var s = !1, l = i.child; l;) { if (l === n) { s = !0, n = i, r = o; break } if (l === r) { s = !0, r = i, n = o; break } l = l.sibling } if (!s) { for (l = o.child; l;) { if (l === n) { s = !0, n = o, r = i; break } if (l === r) { s = !0, r = o, n = i; break } l = l.sibling } if (!s) throw Error(_(189)) } } if (n.alternate !== r) throw Error(_(190)) } if (n.tag !== 3) throw Error(_(188)); return n.stateNode.current === n ? e : t } function Hc(e) { return e = Zh(e), e !== null ? Wc(e) : null } function Wc(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = Wc(e); if (t !== null) return t; e = e.sibling } return null } var Bc = je.unstable_scheduleCallback, Mu = je.unstable_cancelCallback, ep = je.unstable_shouldYield, tp = je.unstable_requestPaint, Z = je.unstable_now, np = je.unstable_getCurrentPriorityLevel, Ll = je.unstable_ImmediatePriority, Vc = je.unstable_UserBlockingPriority, zi = je.unstable_NormalPriority, rp = je.unstable_LowPriority, Qc = je.unstable_IdlePriority, lo = null, at = null; function ip(e) { if (at && typeof at.onCommitFiberRoot == "function") try { at.onCommitFiberRoot(lo, e, void 0, (e.current.flags & 128) === 128) } catch { } } var nt = Math.clz32 ? Math.clz32 : lp, op = Math.log, sp = Math.LN2; function lp(e) { return e >>>= 0, e === 0 ? 32 : 31 - (op(e) / sp | 0) | 0 } var ii = 64, oi = 4194304; function ar(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Fi(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, i = e.suspendedLanes, o = e.pingedLanes, s = n & 268435455; if (s !== 0) { var l = s & ~i; l !== 0 ? r = ar(l) : (o &= s, o !== 0 && (r = ar(o))) } else s = n & ~i, s !== 0 ? r = ar(s) : o !== 0 && (r = ar(o)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & i) && (i = r & -r, o = t & -t, i >= o || i === 16 && (o & 4194240) !== 0)) return t; if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - nt(t), i = 1 << n, r |= e[n], t &= ~i; return r } function up(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function ap(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) { var s = 31 - nt(o), l = 1 << s, u = i[s]; u === -1 ? (!(l & n) || l & r) && (i[s] = up(l, t)) : u <= t && (e.expiredLanes |= l), o &= ~l } } function zs(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function Kc() { var e = ii; return ii <<= 1, !(ii & 4194240) && (ii = 64), e } function Wo(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function Br(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - nt(t), e[t] = n } function cp(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - nt(n), o = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o } } function jl(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - nt(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var U = 0; function qc(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var Gc, Rl, Yc, Xc, Jc, Fs = !1, si = [], zt = null, Ft = null, $t = null, Or = new Map, Tr = new Map, jt = [], dp = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Au(e, t) { switch (e) { case "focusin": case "focusout": zt = null; break; case "dragenter": case "dragleave": Ft = null; break; case "mouseover": case "mouseout": $t = null; break; case "pointerover": case "pointerout": Or.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": Tr.delete(t.pointerId) } } function Jn(e, t, n, r, i, o) { return e === null || e.nativeEvent !== o ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: o, targetContainers: [i] }, t !== null && (t = Qr(t), t !== null && Rl(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e) } function fp(e, t, n, r, i) { switch (t) { case "focusin": return zt = Jn(zt, e, t, n, r, i), !0; case "dragenter": return Ft = Jn(Ft, e, t, n, r, i), !0; case "mouseover": return $t = Jn($t, e, t, n, r, i), !0; case "pointerover": var o = i.pointerId; return Or.set(o, Jn(Or.get(o) || null, e, t, n, r, i)), !0; case "gotpointercapture": return o = i.pointerId, Tr.set(o, Jn(Tr.get(o) || null, e, t, n, r, i)), !0 }return !1 } function Zc(e) { var t = tn(e.target); if (t !== null) { var n = gn(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = Uc(n), t !== null) { e.blockedOn = t, Jc(e.priority, function () { Yc(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function Ci(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = $s(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n === null) { n = e.nativeEvent; var r = new n.constructor(n.type, n); Rs = r, n.target.dispatchEvent(r), Rs = null } else return t = Qr(n), t !== null && Rl(t), e.blockedOn = n, !1; t.shift() } return !0 } function bu(e, t, n) { Ci(e) && n.delete(t) } function hp() { Fs = !1, zt !== null && Ci(zt) && (zt = null), Ft !== null && Ci(Ft) && (Ft = null), $t !== null && Ci($t) && ($t = null), Or.forEach(bu), Tr.forEach(bu) } function Zn(e, t) { e.blockedOn === t && (e.blockedOn = null, Fs || (Fs = !0, je.unstable_scheduleCallback(je.unstable_NormalPriority, hp))) } function Dr(e) { function t(i) { return Zn(i, e) } if (0 < si.length) { Zn(si[0], e); for (var n = 1; n < si.length; n++) { var r = si[n]; r.blockedOn === e && (r.blockedOn = null) } } for (zt !== null && Zn(zt, e), Ft !== null && Zn(Ft, e), $t !== null && Zn($t, e), Or.forEach(t), Tr.forEach(t), n = 0; n < jt.length; n++)r = jt[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < jt.length && (n = jt[0], n.blockedOn === null);)Zc(n), n.blockedOn === null && jt.shift() } var An = kt.ReactCurrentBatchConfig, $i = !0; function pp(e, t, n, r) { var i = U, o = An.transition; An.transition = null; try { U = 1, Ml(e, t, n, r) } finally { U = i, An.transition = o } } function gp(e, t, n, r) { var i = U, o = An.transition; An.transition = null; try { U = 4, Ml(e, t, n, r) } finally { U = i, An.transition = o } } function Ml(e, t, n, r) { if ($i) { var i = $s(e, t, n, r); if (i === null) Zo(e, t, r, Ui, n), Au(e, r); else if (fp(i, e, t, n, r)) r.stopPropagation(); else if (Au(e, r), t & 4 && -1 < dp.indexOf(e)) { for (; i !== null;) { var o = Qr(i); if (o !== null && Gc(o), o = $s(e, t, n, r), o === null && Zo(e, t, r, Ui, n), o === i) break; i = o } i !== null && r.stopPropagation() } else Zo(e, t, r, null, n) } } var Ui = null; function $s(e, t, n, r) { if (Ui = null, e = Il(r), e = tn(e), e !== null) if (t = gn(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = Uc(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return Ui = e, null } function ed(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (np()) { case Ll: return 1; case Vc: return 4; case zi: case rp: return 16; case Qc: return 536870912; default: return 16 }default: return 16 } } var At = null, Al = null, ki = null; function td() { if (ki) return ki; var e, t = Al, n = t.length, r, i = "value" in At ? At.value : At.textContent, o = i.length; for (e = 0; e < n && t[e] === i[e]; e++); var s = n - e; for (r = 1; r <= s && t[n - r] === i[o - r]; r++); return ki = i.slice(e, 1 < r ? 1 - r : void 0) } function _i(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function li() { return !0 } function zu() { return !1 } function Me(e) { function t(n, r, i, o, s) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = o, this.target = s, this.currentTarget = null; for (var l in e) e.hasOwnProperty(l) && (n = e[l], this[l] = n ? n(o) : o[l]); return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? li : zu, this.isPropagationStopped = zu, this } return Y(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = li) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = li) }, persist: function () { }, isPersistent: li }), t } var qn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, bl = Me(qn), Vr = Y({}, qn, { view: 0, detail: 0 }), mp = Me(Vr), Bo, Vo, er, uo = Y({}, Vr, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zl, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== er && (er && e.type === "mousemove" ? (Bo = e.screenX - er.screenX, Vo = e.screenY - er.screenY) : Vo = Bo = 0, er = e), Bo) }, movementY: function (e) { return "movementY" in e ? e.movementY : Vo } }), Fu = Me(uo), vp = Y({}, uo, { dataTransfer: 0 }), yp = Me(vp), Sp = Y({}, Vr, { relatedTarget: 0 }), Qo = Me(Sp), wp = Y({}, qn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Ep = Me(wp), Cp = Y({}, qn, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), kp = Me(Cp), _p = Y({}, qn, { data: 0 }), $u = Me(_p), xp = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Op = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Tp = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Dp(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = Tp[e]) ? !!t[e] : !1 } function zl() { return Dp } var Pp = Y({}, Vr, { key: function (e) { if (e.key) { var t = xp[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = _i(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? Op[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zl, charCode: function (e) { return e.type === "keypress" ? _i(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? _i(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Np = Me(Pp), Ip = Y({}, uo, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Uu = Me(Ip), Lp = Y({}, Vr, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zl }), jp = Me(Lp), Rp = Y({}, qn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Mp = Me(Rp), Ap = Y({}, uo, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), bp = Me(Ap), zp = [9, 13, 27, 32], Fl = St && "CompositionEvent" in window, pr = null; St && "documentMode" in document && (pr = document.documentMode); var Fp = St && "TextEvent" in window && !pr, nd = St && (!Fl || pr && 8 < pr && 11 >= pr), Hu = String.fromCharCode(32), Wu = !1; function rd(e, t) { switch (e) { case "keyup": return zp.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function id(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var kn = !1; function $p(e, t) { switch (e) { case "compositionend": return id(t); case "keypress": return t.which !== 32 ? null : (Wu = !0, Hu); case "textInput": return e = t.data, e === Hu && Wu ? null : e; default: return null } } function Up(e, t) { if (kn) return e === "compositionend" || !Fl && rd(e, t) ? (e = td(), ki = Al = At = null, kn = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return nd && t.locale !== "ko" ? null : t.data; default: return null } } var Hp = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function Bu(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!Hp[e.type] : t === "textarea" } function od(e, t, n, r) { Ac(r), t = Hi(t, "onChange"), 0 < t.length && (n = new bl("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var gr = null, Pr = null; function Wp(e) { md(e, 0) } function ao(e) { var t = On(e); if (Pc(t)) return e } function Bp(e, t) { if (e === "change") return t } var sd = !1; if (St) { var Ko; if (St) { var qo = "oninput" in document; if (!qo) { var Vu = document.createElement("div"); Vu.setAttribute("oninput", "return;"), qo = typeof Vu.oninput == "function" } Ko = qo } else Ko = !1; sd = Ko && (!document.documentMode || 9 < document.documentMode) } function Qu() { gr && (gr.detachEvent("onpropertychange", ld), Pr = gr = null) } function ld(e) { if (e.propertyName === "value" && ao(Pr)) { var t = []; od(t, Pr, e, Il(e)), $c(Wp, t) } } function Vp(e, t, n) { e === "focusin" ? (Qu(), gr = t, Pr = n, gr.attachEvent("onpropertychange", ld)) : e === "focusout" && Qu() } function Qp(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return ao(Pr) } function Kp(e, t) { if (e === "click") return ao(t) } function qp(e, t) { if (e === "input" || e === "change") return ao(t) } function Gp(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var it = typeof Object.is == "function" ? Object.is : Gp; function Nr(e, t) { if (it(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!Cs.call(t, i) || !it(e[i], t[i])) return !1 } return !0 } function Ku(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function qu(e, t) { var n = Ku(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = Ku(n) } } function ud(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? ud(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function ad() { for (var e = window, t = Mi(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (n) e = t.contentWindow; else break; t = Mi(e.document) } return t } function $l(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function Yp(e) { var t = ad(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && ud(n.ownerDocument.documentElement, n)) { if (r !== null && $l(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var i = n.textContent.length, o = Math.min(r.start, i); r = r.end === void 0 ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = qu(n, o); var s = qu(n, r); i && s && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var Xp = St && "documentMode" in document && 11 >= document.documentMode, _n = null, Us = null, mr = null, Hs = !1; function Gu(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Hs || _n == null || _n !== Mi(r) || (r = _n, "selectionStart" in r && $l(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), mr && Nr(mr, r) || (mr = r, r = Hi(Us, "onSelect"), 0 < r.length && (t = new bl("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = _n))) } function ui(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var xn = { animationend: ui("Animation", "AnimationEnd"), animationiteration: ui("Animation", "AnimationIteration"), animationstart: ui("Animation", "AnimationStart"), transitionend: ui("Transition", "TransitionEnd") }, Go = {}, cd = {}; St && (cd = document.createElement("div").style, "AnimationEvent" in window || (delete xn.animationend.animation, delete xn.animationiteration.animation, delete xn.animationstart.animation), "TransitionEvent" in window || delete xn.transitionend.transition); function co(e) { if (Go[e]) return Go[e]; if (!xn[e]) return e; var t = xn[e], n; for (n in t) if (t.hasOwnProperty(n) && n in cd) return Go[e] = t[n]; return e } var dd = co("animationend"), fd = co("animationiteration"), hd = co("animationstart"), pd = co("transitionend"), gd = new Map, Yu = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Gt(e, t) { gd.set(e, t), pn(t, [e]) } for (var Yo = 0; Yo < Yu.length; Yo++) { var Xo = Yu[Yo], Jp = Xo.toLowerCase(), Zp = Xo[0].toUpperCase() + Xo.slice(1); Gt(Jp, "on" + Zp) } Gt(dd, "onAnimationEnd"); Gt(fd, "onAnimationIteration"); Gt(hd, "onAnimationStart"); Gt("dblclick", "onDoubleClick"); Gt("focusin", "onFocus"); Gt("focusout", "onBlur"); Gt(pd, "onTransitionEnd"); Fn("onMouseEnter", ["mouseout", "mouseover"]); Fn("onMouseLeave", ["mouseout", "mouseover"]); Fn("onPointerEnter", ["pointerout", "pointerover"]); Fn("onPointerLeave", ["pointerout", "pointerover"]); pn("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); pn("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); pn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); pn("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); pn("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); pn("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var cr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), eg = new Set("cancel close invalid load scroll toggle".split(" ").concat(cr)); function Xu(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, Jh(r, t, void 0, e), e.currentTarget = null } function md(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var o = void 0; if (t) for (var s = r.length - 1; 0 <= s; s--) { var l = r[s], u = l.instance, a = l.currentTarget; if (l = l.listener, u !== o && i.isPropagationStopped()) break e; Xu(i, l, a), o = u } else for (s = 0; s < r.length; s++) { if (l = r[s], u = l.instance, a = l.currentTarget, l = l.listener, u !== o && i.isPropagationStopped()) break e; Xu(i, l, a), o = u } } } if (bi) throw e = bs, bi = !1, bs = null, e } function B(e, t) { var n = t[Ks]; n === void 0 && (n = t[Ks] = new Set); var r = e + "__bubble"; n.has(r) || (vd(t, e, 2, !1), n.add(r)) } function Jo(e, t, n) { var r = 0; t && (r |= 4), vd(n, e, r, t) } var ai = "_reactListening" + Math.random().toString(36).slice(2); function Ir(e) { if (!e[ai]) { e[ai] = !0, _c.forEach(function (n) { n !== "selectionchange" && (eg.has(n) || Jo(n, !1, e), Jo(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[ai] || (t[ai] = !0, Jo("selectionchange", !1, t)) } } function vd(e, t, n, r) { switch (ed(t)) { case 1: var i = pp; break; case 4: i = gp; break; default: i = Ml }n = i.bind(null, t, n, e), i = void 0, !As || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), r ? i !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function Zo(e, t, n, r, i) { var o = r; if (!(t & 1) && !(t & 2) && r !== null) e: for (; ;) { if (r === null) return; var s = r.tag; if (s === 3 || s === 4) { var l = r.stateNode.containerInfo; if (l === i || l.nodeType === 8 && l.parentNode === i) break; if (s === 4) for (s = r.return; s !== null;) { var u = s.tag; if ((u === 3 || u === 4) && (u = s.stateNode.containerInfo, u === i || u.nodeType === 8 && u.parentNode === i)) return; s = s.return } for (; l !== null;) { if (s = tn(l), s === null) return; if (u = s.tag, u === 5 || u === 6) { r = o = s; continue e } l = l.parentNode } } r = r.return } $c(function () { var a = o, g = Il(n), p = []; e: { var f = gd.get(e); if (f !== void 0) { var y = bl, m = e; switch (e) { case "keypress": if (_i(n) === 0) break e; case "keydown": case "keyup": y = Np; break; case "focusin": m = "focus", y = Qo; break; case "focusout": m = "blur", y = Qo; break; case "beforeblur": case "afterblur": y = Qo; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": y = Fu; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": y = yp; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": y = jp; break; case dd: case fd: case hd: y = Ep; break; case pd: y = Mp; break; case "scroll": y = mp; break; case "wheel": y = bp; break; case "copy": case "cut": case "paste": y = kp; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": y = Uu }var v = (t & 4) !== 0, E = !v && e === "scroll", d = v ? f !== null ? f + "Capture" : null : f; v = []; for (var c = a, h; c !== null;) { h = c; var w = h.stateNode; if (h.tag === 5 && w !== null && (h = w, d !== null && (w = xr(c, d), w != null && v.push(Lr(c, w, h)))), E) break; c = c.return } 0 < v.length && (f = new y(f, m, null, n, g), p.push({ event: f, listeners: v })) } } if (!(t & 7)) { e: { if (f = e === "mouseover" || e === "pointerover", y = e === "mouseout" || e === "pointerout", f && n !== Rs && (m = n.relatedTarget || n.fromElement) && (tn(m) || m[wt])) break e; if ((y || f) && (f = g.window === g ? g : (f = g.ownerDocument) ? f.defaultView || f.parentWindow : window, y ? (m = n.relatedTarget || n.toElement, y = a, m = m ? tn(m) : null, m !== null && (E = gn(m), m !== E || m.tag !== 5 && m.tag !== 6) && (m = null)) : (y = null, m = a), y !== m)) { if (v = Fu, w = "onMouseLeave", d = "onMouseEnter", c = "mouse", (e === "pointerout" || e === "pointerover") && (v = Uu, w = "onPointerLeave", d = "onPointerEnter", c = "pointer"), E = y == null ? f : On(y), h = m == null ? f : On(m), f = new v(w, c + "leave", y, n, g), f.target = E, f.relatedTarget = h, w = null, tn(g) === a && (v = new v(d, c + "enter", m, n, g), v.target = h, v.relatedTarget = E, w = v), E = w, y && m) t: { for (v = y, d = m, c = 0, h = v; h; h = Sn(h))c++; for (h = 0, w = d; w; w = Sn(w))h++; for (; 0 < c - h;)v = Sn(v), c--; for (; 0 < h - c;)d = Sn(d), h--; for (; c--;) { if (v === d || d !== null && v === d.alternate) break t; v = Sn(v), d = Sn(d) } v = null } else v = null; y !== null && Ju(p, f, y, v, !1), m !== null && E !== null && Ju(p, E, m, v, !0) } } e: { if (f = a ? On(a) : window, y = f.nodeName && f.nodeName.toLowerCase(), y === "select" || y === "input" && f.type === "file") var k = Bp; else if (Bu(f)) if (sd) k = qp; else { k = Qp; var O = Vp } else (y = f.nodeName) && y.toLowerCase() === "input" && (f.type === "checkbox" || f.type === "radio") && (k = Kp); if (k && (k = k(e, a))) { od(p, k, n, g); break e } O && O(e, f, a), e === "focusout" && (O = f._wrapperState) && O.controlled && f.type === "number" && Ps(f, "number", f.value) } switch (O = a ? On(a) : window, e) { case "focusin": (Bu(O) || O.contentEditable === "true") && (_n = O, Us = a, mr = null); break; case "focusout": mr = Us = _n = null; break; case "mousedown": Hs = !0; break; case "contextmenu": case "mouseup": case "dragend": Hs = !1, Gu(p, n, g); break; case "selectionchange": if (Xp) break; case "keydown": case "keyup": Gu(p, n, g) }var x; if (Fl) e: { switch (e) { case "compositionstart": var T = "onCompositionStart"; break e; case "compositionend": T = "onCompositionEnd"; break e; case "compositionupdate": T = "onCompositionUpdate"; break e }T = void 0 } else kn ? rd(e, n) && (T = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (T = "onCompositionStart"); T && (nd && n.locale !== "ko" && (kn || T !== "onCompositionStart" ? T === "onCompositionEnd" && kn && (x = td()) : (At = g, Al = "value" in At ? At.value : At.textContent, kn = !0)), O = Hi(a, T), 0 < O.length && (T = new $u(T, e, null, n, g), p.push({ event: T, listeners: O }), x ? T.data = x : (x = id(n), x !== null && (T.data = x)))), (x = Fp ? $p(e, n) : Up(e, n)) && (a = Hi(a, "onBeforeInput"), 0 < a.length && (g = new $u("onBeforeInput", "beforeinput", null, n, g), p.push({ event: g, listeners: a }), g.data = x)) } md(p, t) }) } function Lr(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Hi(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var i = e, o = i.stateNode; i.tag === 5 && o !== null && (i = o, o = xr(e, n), o != null && r.unshift(Lr(e, o, i)), o = xr(e, t), o != null && r.push(Lr(e, o, i))), e = e.return } return r } function Sn(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Ju(e, t, n, r, i) { for (var o = t._reactName, s = []; n !== null && n !== r;) { var l = n, u = l.alternate, a = l.stateNode; if (u !== null && u === r) break; l.tag === 5 && a !== null && (l = a, i ? (u = xr(n, o), u != null && s.unshift(Lr(n, u, l))) : i || (u = xr(n, o), u != null && s.push(Lr(n, u, l)))), n = n.return } s.length !== 0 && e.push({ event: t, listeners: s }) } var tg = /\r\n?/g, ng = /\u0000|\uFFFD/g; function Zu(e) {
    return (typeof e == "string" ? e : "" + e).replace(tg, `
`).replace(ng, "")
} function ci(e, t, n) { if (t = Zu(t), Zu(e) !== t && n) throw Error(_(425)) } function Wi() { } var Ws = null, Bs = null; function Vs(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var Qs = typeof setTimeout == "function" ? setTimeout : void 0, rg = typeof clearTimeout == "function" ? clearTimeout : void 0, ea = typeof Promise == "function" ? Promise : void 0, ig = typeof queueMicrotask == "function" ? queueMicrotask : typeof ea < "u" ? function (e) { return ea.resolve(null).then(e).catch(og) } : Qs; function og(e) { setTimeout(function () { throw e }) } function es(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { e.removeChild(i), Dr(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); Dr(t) } function Ut(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function ta(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var Gn = Math.random().toString(36).slice(2), ut = "__reactFiber$" + Gn, jr = "__reactProps$" + Gn, wt = "__reactContainer$" + Gn, Ks = "__reactEvents$" + Gn, sg = "__reactListeners$" + Gn, lg = "__reactHandles$" + Gn; function tn(e) { var t = e[ut]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[wt] || n[ut]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = ta(e); e !== null;) { if (n = e[ut]) return n; e = ta(e) } return t } e = n, n = e.parentNode } return null } function Qr(e) { return e = e[ut] || e[wt], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function On(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(_(33)) } function fo(e) { return e[jr] || null } var qs = [], Tn = -1; function Yt(e) { return { current: e } } function V(e) { 0 > Tn || (e.current = qs[Tn], qs[Tn] = null, Tn--) } function W(e, t) { Tn++, qs[Tn] = e.current, e.current = t } var qt = {}, me = Yt(qt), xe = Yt(!1), un = qt; function $n(e, t) { var n = e.type.contextTypes; if (!n) return qt; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i = {}, o; for (o in n) i[o] = t[o]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i } function Oe(e) { return e = e.childContextTypes, e != null } function Bi() { V(xe), V(me) } function na(e, t, n) { if (me.current !== qt) throw Error(_(168)); W(me, t), W(xe, n) } function yd(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in t)) throw Error(_(108, Vh(e) || "Unknown", i)); return Y({}, n, r) } function Vi(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || qt, un = me.current, W(me, e), W(xe, xe.current), !0 } function ra(e, t, n) { var r = e.stateNode; if (!r) throw Error(_(169)); n ? (e = yd(e, t, un), r.__reactInternalMemoizedMergedChildContext = e, V(xe), V(me), W(me, e)) : V(xe), W(xe, n) } var gt = null, ho = !1, ts = !1; function Sd(e) { gt === null ? gt = [e] : gt.push(e) } function ug(e) { ho = !0, Sd(e) } function Xt() { if (!ts && gt !== null) { ts = !0; var e = 0, t = U; try { var n = gt; for (U = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } gt = null, ho = !1 } catch (i) { throw gt !== null && (gt = gt.slice(e + 1)), Bc(Ll, Xt), i } finally { U = t, ts = !1 } } return null } var Dn = [], Pn = 0, Qi = null, Ki = 0, Ue = [], He = 0, an = null, mt = 1, vt = ""; function Zt(e, t) { Dn[Pn++] = Ki, Dn[Pn++] = Qi, Qi = e, Ki = t } function wd(e, t, n) { Ue[He++] = mt, Ue[He++] = vt, Ue[He++] = an, an = e; var r = mt; e = vt; var i = 32 - nt(r) - 1; r &= ~(1 << i), n += 1; var o = 32 - nt(t) + i; if (30 < o) { var s = i - i % 5; o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, mt = 1 << 32 - nt(t) + i | n << i | r, vt = o + e } else mt = 1 << o | n << i | r, vt = e } function Ul(e) { e.return !== null && (Zt(e, 1), wd(e, 1, 0)) } function Hl(e) { for (; e === Qi;)Qi = Dn[--Pn], Dn[Pn] = null, Ki = Dn[--Pn], Dn[Pn] = null; for (; e === an;)an = Ue[--He], Ue[He] = null, vt = Ue[--He], Ue[He] = null, mt = Ue[--He], Ue[He] = null } var Le = null, Ie = null, Q = !1, tt = null; function Ed(e, t) { var n = Be(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function ia(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, Le = e, Ie = Ut(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, Le = e, Ie = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (n = an !== null ? { id: mt, overflow: vt } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = Be(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, Le = e, Ie = null, !0) : !1; default: return !1 } } function Gs(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function Ys(e) { if (Q) { var t = Ie; if (t) { var n = t; if (!ia(e, t)) { if (Gs(e)) throw Error(_(418)); t = Ut(n.nextSibling); var r = Le; t && ia(e, t) ? Ed(r, n) : (e.flags = e.flags & -4097 | 2, Q = !1, Le = e) } } else { if (Gs(e)) throw Error(_(418)); e.flags = e.flags & -4097 | 2, Q = !1, Le = e } } } function oa(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; Le = e } function di(e) { if (e !== Le) return !1; if (!Q) return oa(e), Q = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !Vs(e.type, e.memoizedProps)), t && (t = Ie)) { if (Gs(e)) throw Cd(), Error(_(418)); for (; t;)Ed(e, t), t = Ut(t.nextSibling) } if (oa(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(_(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { Ie = Ut(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } Ie = null } } else Ie = Le ? Ut(e.stateNode.nextSibling) : null; return !0 } function Cd() { for (var e = Ie; e;)e = Ut(e.nextSibling) } function Un() { Ie = Le = null, Q = !1 } function Wl(e) { tt === null ? tt = [e] : tt.push(e) } var ag = kt.ReactCurrentBatchConfig; function Ze(e, t) { if (e && e.defaultProps) { t = Y({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } var qi = Yt(null), Gi = null, Nn = null, Bl = null; function Vl() { Bl = Nn = Gi = null } function Ql(e) { var t = qi.current; V(qi), e._currentValue = t } function Xs(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function bn(e, t) { Gi = e, Bl = Nn = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (_e = !0), e.firstContext = null) } function Qe(e) { var t = e._currentValue; if (Bl !== e) if (e = { context: e, memoizedValue: t, next: null }, Nn === null) { if (Gi === null) throw Error(_(308)); Nn = e, Gi.dependencies = { lanes: 0, firstContext: e } } else Nn = Nn.next = e; return t } var nn = null; function Kl(e) { nn === null ? nn = [e] : nn.push(e) } function kd(e, t, n, r) { var i = t.interleaved; return i === null ? (n.next = n, Kl(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Et(e, r) } function Et(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var It = !1; function ql(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function _d(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function yt(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Ht(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, F & 2) { var i = r.pending; return i === null ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Et(e, n) } return i = r.interleaved, i === null ? (t.next = t, Kl(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Et(e, n) } function xi(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, jl(e, n) } } function sa(e, t) { var n = e.updateQueue, r = e.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var i = null, o = null; if (n = n.firstBaseUpdate, n !== null) { do { var s = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; o === null ? i = o = s : o = o.next = s, n = n.next } while (n !== null); o === null ? i = o = t : o = o.next = t } else i = o = t; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: o, shared: r.shared, effects: r.effects }, e.updateQueue = n; return } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Yi(e, t, n, r) { var i = e.updateQueue; It = !1; var o = i.firstBaseUpdate, s = i.lastBaseUpdate, l = i.shared.pending; if (l !== null) { i.shared.pending = null; var u = l, a = u.next; u.next = null, s === null ? o = a : s.next = a, s = u; var g = e.alternate; g !== null && (g = g.updateQueue, l = g.lastBaseUpdate, l !== s && (l === null ? g.firstBaseUpdate = a : l.next = a, g.lastBaseUpdate = u)) } if (o !== null) { var p = i.baseState; s = 0, g = a = u = null, l = o; do { var f = l.lane, y = l.eventTime; if ((r & f) === f) { g !== null && (g = g.next = { eventTime: y, lane: 0, tag: l.tag, payload: l.payload, callback: l.callback, next: null }); e: { var m = e, v = l; switch (f = t, y = n, v.tag) { case 1: if (m = v.payload, typeof m == "function") { p = m.call(y, p, f); break e } p = m; break e; case 3: m.flags = m.flags & -65537 | 128; case 0: if (m = v.payload, f = typeof m == "function" ? m.call(y, p, f) : m, f == null) break e; p = Y({}, p, f); break e; case 2: It = !0 } } l.callback !== null && l.lane !== 0 && (e.flags |= 64, f = i.effects, f === null ? i.effects = [l] : f.push(l)) } else y = { eventTime: y, lane: f, tag: l.tag, payload: l.payload, callback: l.callback, next: null }, g === null ? (a = g = y, u = p) : g = g.next = y, s |= f; if (l = l.next, l === null) { if (l = i.shared.pending, l === null) break; f = l, l = f.next, f.next = null, i.lastBaseUpdate = f, i.shared.pending = null } } while (1); if (g === null && (u = p), i.baseState = u, i.firstBaseUpdate = a, i.lastBaseUpdate = g, t = i.shared.interleaved, t !== null) { i = t; do s |= i.lane, i = i.next; while (i !== t) } else o === null && (i.shared.lanes = 0); dn |= s, e.lanes = s, e.memoizedState = p } } function la(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(_(191, i)); i.call(r) } } } var xd = new kc.Component().refs; function Js(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : Y({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var po = { isMounted: function (e) { return (e = e._reactInternals) ? gn(e) === e : !1 }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = ye(), i = Bt(e), o = yt(r, i); o.payload = t, n != null && (o.callback = n), t = Ht(e, o, i), t !== null && (rt(t, e, i, r), xi(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = ye(), i = Bt(e), o = yt(r, i); o.tag = 1, o.payload = t, n != null && (o.callback = n), t = Ht(e, o, i), t !== null && (rt(t, e, i, r), xi(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = ye(), r = Bt(e), i = yt(n, r); i.tag = 2, t != null && (i.callback = t), t = Ht(e, i, r), t !== null && (rt(t, e, r, n), xi(t, e, r)) } }; function ua(e, t, n, r, i, o, s) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, o, s) : t.prototype && t.prototype.isPureReactComponent ? !Nr(n, r) || !Nr(i, o) : !0 } function Od(e, t, n) { var r = !1, i = qt, o = t.contextType; return typeof o == "object" && o !== null ? o = Qe(o) : (i = Oe(t) ? un : me.current, r = t.contextTypes, o = (r = r != null) ? $n(e, i) : qt), t = new t(n, o), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = po, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t } function aa(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && po.enqueueReplaceState(t, t.state, null) } function Zs(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = xd, ql(e); var o = t.contextType; typeof o == "object" && o !== null ? i.context = Qe(o) : (o = Oe(t) ? un : me.current, i.context = $n(e, o)), i.state = e.memoizedState, o = t.getDerivedStateFromProps, typeof o == "function" && (Js(e, t, o, n), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && po.enqueueReplaceState(i, i.state, null), Yi(e, n, i, r), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308) } function tr(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(_(309)); var r = n.stateNode } if (!r) throw Error(_(147, e)); var i = r, o = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === o ? t.ref : (t = function (s) { var l = i.refs; l === xd && (l = i.refs = {}), s === null ? delete l[o] : l[o] = s }, t._stringRef = o, t) } if (typeof e != "string") throw Error(_(284)); if (!n._owner) throw Error(_(290, e)) } return e } function fi(e, t) { throw e = Object.prototype.toString.call(t), Error(_(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function ca(e) { var t = e._init; return t(e._payload) } function Td(e) { function t(d, c) { if (e) { var h = d.deletions; h === null ? (d.deletions = [c], d.flags |= 16) : h.push(c) } } function n(d, c) { if (!e) return null; for (; c !== null;)t(d, c), c = c.sibling; return null } function r(d, c) { for (d = new Map; c !== null;)c.key !== null ? d.set(c.key, c) : d.set(c.index, c), c = c.sibling; return d } function i(d, c) { return d = Vt(d, c), d.index = 0, d.sibling = null, d } function o(d, c, h) { return d.index = h, e ? (h = d.alternate, h !== null ? (h = h.index, h < c ? (d.flags |= 2, c) : h) : (d.flags |= 2, c)) : (d.flags |= 1048576, c) } function s(d) { return e && d.alternate === null && (d.flags |= 2), d } function l(d, c, h, w) { return c === null || c.tag !== 6 ? (c = us(h, d.mode, w), c.return = d, c) : (c = i(c, h), c.return = d, c) } function u(d, c, h, w) { var k = h.type; return k === Cn ? g(d, c, h.props.children, w, h.key) : c !== null && (c.elementType === k || typeof k == "object" && k !== null && k.$$typeof === Nt && ca(k) === c.type) ? (w = i(c, h.props), w.ref = tr(d, c, h), w.return = d, w) : (w = Ii(h.type, h.key, h.props, null, d.mode, w), w.ref = tr(d, c, h), w.return = d, w) } function a(d, c, h, w) { return c === null || c.tag !== 4 || c.stateNode.containerInfo !== h.containerInfo || c.stateNode.implementation !== h.implementation ? (c = as(h, d.mode, w), c.return = d, c) : (c = i(c, h.children || []), c.return = d, c) } function g(d, c, h, w, k) { return c === null || c.tag !== 7 ? (c = sn(h, d.mode, w, k), c.return = d, c) : (c = i(c, h), c.return = d, c) } function p(d, c, h) { if (typeof c == "string" && c !== "" || typeof c == "number") return c = us("" + c, d.mode, h), c.return = d, c; if (typeof c == "object" && c !== null) { switch (c.$$typeof) { case ti: return h = Ii(c.type, c.key, c.props, null, d.mode, h), h.ref = tr(d, null, c), h.return = d, h; case En: return c = as(c, d.mode, h), c.return = d, c; case Nt: var w = c._init; return p(d, w(c._payload), h) }if (ur(c) || Yn(c)) return c = sn(c, d.mode, h, null), c.return = d, c; fi(d, c) } return null } function f(d, c, h, w) { var k = c !== null ? c.key : null; if (typeof h == "string" && h !== "" || typeof h == "number") return k !== null ? null : l(d, c, "" + h, w); if (typeof h == "object" && h !== null) { switch (h.$$typeof) { case ti: return h.key === k ? u(d, c, h, w) : null; case En: return h.key === k ? a(d, c, h, w) : null; case Nt: return k = h._init, f(d, c, k(h._payload), w) }if (ur(h) || Yn(h)) return k !== null ? null : g(d, c, h, w, null); fi(d, h) } return null } function y(d, c, h, w, k) { if (typeof w == "string" && w !== "" || typeof w == "number") return d = d.get(h) || null, l(c, d, "" + w, k); if (typeof w == "object" && w !== null) { switch (w.$$typeof) { case ti: return d = d.get(w.key === null ? h : w.key) || null, u(c, d, w, k); case En: return d = d.get(w.key === null ? h : w.key) || null, a(c, d, w, k); case Nt: var O = w._init; return y(d, c, h, O(w._payload), k) }if (ur(w) || Yn(w)) return d = d.get(h) || null, g(c, d, w, k, null); fi(c, w) } return null } function m(d, c, h, w) { for (var k = null, O = null, x = c, T = c = 0, z = null; x !== null && T < h.length; T++) { x.index > T ? (z = x, x = null) : z = x.sibling; var M = f(d, x, h[T], w); if (M === null) { x === null && (x = z); break } e && x && M.alternate === null && t(d, x), c = o(M, c, T), O === null ? k = M : O.sibling = M, O = M, x = z } if (T === h.length) return n(d, x), Q && Zt(d, T), k; if (x === null) { for (; T < h.length; T++)x = p(d, h[T], w), x !== null && (c = o(x, c, T), O === null ? k = x : O.sibling = x, O = x); return Q && Zt(d, T), k } for (x = r(d, x); T < h.length; T++)z = y(x, d, T, h[T], w), z !== null && (e && z.alternate !== null && x.delete(z.key === null ? T : z.key), c = o(z, c, T), O === null ? k = z : O.sibling = z, O = z); return e && x.forEach(function ($) { return t(d, $) }), Q && Zt(d, T), k } function v(d, c, h, w) { var k = Yn(h); if (typeof k != "function") throw Error(_(150)); if (h = k.call(h), h == null) throw Error(_(151)); for (var O = k = null, x = c, T = c = 0, z = null, M = h.next(); x !== null && !M.done; T++, M = h.next()) { x.index > T ? (z = x, x = null) : z = x.sibling; var $ = f(d, x, M.value, w); if ($ === null) { x === null && (x = z); break } e && x && $.alternate === null && t(d, x), c = o($, c, T), O === null ? k = $ : O.sibling = $, O = $, x = z } if (M.done) return n(d, x), Q && Zt(d, T), k; if (x === null) { for (; !M.done; T++, M = h.next())M = p(d, M.value, w), M !== null && (c = o(M, c, T), O === null ? k = M : O.sibling = M, O = M); return Q && Zt(d, T), k } for (x = r(d, x); !M.done; T++, M = h.next())M = y(x, d, T, M.value, w), M !== null && (e && M.alternate !== null && x.delete(M.key === null ? T : M.key), c = o(M, c, T), O === null ? k = M : O.sibling = M, O = M); return e && x.forEach(function (K) { return t(d, K) }), Q && Zt(d, T), k } function E(d, c, h, w) { if (typeof h == "object" && h !== null && h.type === Cn && h.key === null && (h = h.props.children), typeof h == "object" && h !== null) { switch (h.$$typeof) { case ti: e: { for (var k = h.key, O = c; O !== null;) { if (O.key === k) { if (k = h.type, k === Cn) { if (O.tag === 7) { n(d, O.sibling), c = i(O, h.props.children), c.return = d, d = c; break e } } else if (O.elementType === k || typeof k == "object" && k !== null && k.$$typeof === Nt && ca(k) === O.type) { n(d, O.sibling), c = i(O, h.props), c.ref = tr(d, O, h), c.return = d, d = c; break e } n(d, O); break } else t(d, O); O = O.sibling } h.type === Cn ? (c = sn(h.props.children, d.mode, w, h.key), c.return = d, d = c) : (w = Ii(h.type, h.key, h.props, null, d.mode, w), w.ref = tr(d, c, h), w.return = d, d = w) } return s(d); case En: e: { for (O = h.key; c !== null;) { if (c.key === O) if (c.tag === 4 && c.stateNode.containerInfo === h.containerInfo && c.stateNode.implementation === h.implementation) { n(d, c.sibling), c = i(c, h.children || []), c.return = d, d = c; break e } else { n(d, c); break } else t(d, c); c = c.sibling } c = as(h, d.mode, w), c.return = d, d = c } return s(d); case Nt: return O = h._init, E(d, c, O(h._payload), w) }if (ur(h)) return m(d, c, h, w); if (Yn(h)) return v(d, c, h, w); fi(d, h) } return typeof h == "string" && h !== "" || typeof h == "number" ? (h = "" + h, c !== null && c.tag === 6 ? (n(d, c.sibling), c = i(c, h), c.return = d, d = c) : (n(d, c), c = us(h, d.mode, w), c.return = d, d = c), s(d)) : n(d, c) } return E } var Hn = Td(!0), Dd = Td(!1), Kr = {}, ct = Yt(Kr), Rr = Yt(Kr), Mr = Yt(Kr); function rn(e) { if (e === Kr) throw Error(_(174)); return e } function Gl(e, t) { switch (W(Mr, t), W(Rr, e), W(ct, Kr), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : Is(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Is(t, e) }V(ct), W(ct, t) } function Wn() { V(ct), V(Rr), V(Mr) } function Pd(e) { rn(Mr.current); var t = rn(ct.current), n = Is(t, e.type); t !== n && (W(Rr, e), W(ct, n)) } function Yl(e) { Rr.current === e && (V(ct), V(Rr)) } var q = Yt(0); function Xi(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var ns = []; function Xl() { for (var e = 0; e < ns.length; e++)ns[e]._workInProgressVersionPrimary = null; ns.length = 0 } var Oi = kt.ReactCurrentDispatcher, rs = kt.ReactCurrentBatchConfig, cn = 0, G = null, re = null, se = null, Ji = !1, vr = !1, Ar = 0, cg = 0; function fe() { throw Error(_(321)) } function Jl(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!it(e[n], t[n])) return !1; return !0 } function Zl(e, t, n, r, i, o) { if (cn = o, G = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, Oi.current = e === null || e.memoizedState === null ? pg : gg, e = n(r, i), vr) { o = 0; do { if (vr = !1, Ar = 0, 25 <= o) throw Error(_(301)); o += 1, se = re = null, t.updateQueue = null, Oi.current = mg, e = n(r, i) } while (vr) } if (Oi.current = Zi, t = re !== null && re.next !== null, cn = 0, se = re = G = null, Ji = !1, t) throw Error(_(300)); return e } function eu() { var e = Ar !== 0; return Ar = 0, e } function lt() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return se === null ? G.memoizedState = se = e : se = se.next = e, se } function Ke() { if (re === null) { var e = G.alternate; e = e !== null ? e.memoizedState : null } else e = re.next; var t = se === null ? G.memoizedState : se.next; if (t !== null) se = t, re = e; else { if (e === null) throw Error(_(310)); re = e, e = { memoizedState: re.memoizedState, baseState: re.baseState, baseQueue: re.baseQueue, queue: re.queue, next: null }, se === null ? G.memoizedState = se = e : se = se.next = e } return se } function br(e, t) { return typeof t == "function" ? t(e) : t } function is(e) { var t = Ke(), n = t.queue; if (n === null) throw Error(_(311)); n.lastRenderedReducer = e; var r = re, i = r.baseQueue, o = n.pending; if (o !== null) { if (i !== null) { var s = i.next; i.next = o.next, o.next = s } r.baseQueue = i = o, n.pending = null } if (i !== null) { o = i.next, r = r.baseState; var l = s = null, u = null, a = o; do { var g = a.lane; if ((cn & g) === g) u !== null && (u = u.next = { lane: 0, action: a.action, hasEagerState: a.hasEagerState, eagerState: a.eagerState, next: null }), r = a.hasEagerState ? a.eagerState : e(r, a.action); else { var p = { lane: g, action: a.action, hasEagerState: a.hasEagerState, eagerState: a.eagerState, next: null }; u === null ? (l = u = p, s = r) : u = u.next = p, G.lanes |= g, dn |= g } a = a.next } while (a !== null && a !== o); u === null ? s = r : u.next = l, it(r, t.memoizedState) || (_e = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = u, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { i = e; do o = i.lane, G.lanes |= o, dn |= o, i = i.next; while (i !== e) } else i === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function os(e) { var t = Ke(), n = t.queue; if (n === null) throw Error(_(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, o = t.memoizedState; if (i !== null) { n.pending = null; var s = i = i.next; do o = e(o, s.action), s = s.next; while (s !== i); it(o, t.memoizedState) || (_e = !0), t.memoizedState = o, t.baseQueue === null && (t.baseState = o), n.lastRenderedState = o } return [o, r] } function Nd() { } function Id(e, t) { var n = G, r = Ke(), i = t(), o = !it(r.memoizedState, i); if (o && (r.memoizedState = i, _e = !0), r = r.queue, tu(Rd.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || se !== null && se.memoizedState.tag & 1) { if (n.flags |= 2048, zr(9, jd.bind(null, n, r, i, t), void 0, null), le === null) throw Error(_(349)); cn & 30 || Ld(n, t, i) } return i } function Ld(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = G.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, G.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function jd(e, t, n, r) { t.value = n, t.getSnapshot = r, Md(t) && Ad(e) } function Rd(e, t, n) { return n(function () { Md(t) && Ad(e) }) } function Md(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !it(e, n) } catch { return !0 } } function Ad(e) { var t = Et(e, 1); t !== null && rt(t, e, 1, -1) } function da(e) { var t = lt(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: br, lastRenderedState: e }, t.queue = e, e = e.dispatch = hg.bind(null, G, e), [t.memoizedState, e] } function zr(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = G.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, G.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function bd() { return Ke().memoizedState } function Ti(e, t, n, r) { var i = lt(); G.flags |= e, i.memoizedState = zr(1 | t, n, void 0, r === void 0 ? null : r) } function go(e, t, n, r) { var i = Ke(); r = r === void 0 ? null : r; var o = void 0; if (re !== null) { var s = re.memoizedState; if (o = s.destroy, r !== null && Jl(r, s.deps)) { i.memoizedState = zr(t, n, o, r); return } } G.flags |= e, i.memoizedState = zr(1 | t, n, o, r) } function fa(e, t) { return Ti(8390656, 8, e, t) } function tu(e, t) { return go(2048, 8, e, t) } function zd(e, t) { return go(4, 2, e, t) } function Fd(e, t) { return go(4, 4, e, t) } function $d(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function Ud(e, t, n) { return n = n != null ? n.concat([e]) : null, go(4, 4, $d.bind(null, t, e), n) } function nu() { } function Hd(e, t) { var n = Ke(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Jl(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function Wd(e, t) { var n = Ke(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Jl(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Bd(e, t, n) { return cn & 21 ? (it(n, t) || (n = Kc(), G.lanes |= n, dn |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, _e = !0), e.memoizedState = n) } function dg(e, t) { var n = U; U = n !== 0 && 4 > n ? n : 4, e(!0); var r = rs.transition; rs.transition = {}; try { e(!1), t() } finally { U = n, rs.transition = r } } function Vd() { return Ke().memoizedState } function fg(e, t, n) { var r = Bt(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, Qd(e)) Kd(t, n); else if (n = kd(e, t, n, r), n !== null) { var i = ye(); rt(n, e, r, i), qd(n, t, r) } } function hg(e, t, n) { var r = Bt(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Qd(e)) Kd(t, i); else { var o = e.alternate; if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer, o !== null)) try { var s = t.lastRenderedState, l = o(s, n); if (i.hasEagerState = !0, i.eagerState = l, it(l, s)) { var u = t.interleaved; u === null ? (i.next = i, Kl(t)) : (i.next = u.next, u.next = i), t.interleaved = i; return } } catch { } finally { } n = kd(e, t, i, r), n !== null && (i = ye(), rt(n, e, r, i), qd(n, t, r)) } } function Qd(e) { var t = e.alternate; return e === G || t !== null && t === G } function Kd(e, t) { vr = Ji = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function qd(e, t, n) { if (n & 4194240) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, jl(e, n) } } var Zi = { readContext: Qe, useCallback: fe, useContext: fe, useEffect: fe, useImperativeHandle: fe, useInsertionEffect: fe, useLayoutEffect: fe, useMemo: fe, useReducer: fe, useRef: fe, useState: fe, useDebugValue: fe, useDeferredValue: fe, useTransition: fe, useMutableSource: fe, useSyncExternalStore: fe, useId: fe, unstable_isNewReconciler: !1 }, pg = { readContext: Qe, useCallback: function (e, t) { return lt().memoizedState = [e, t === void 0 ? null : t], e }, useContext: Qe, useEffect: fa, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, Ti(4194308, 4, $d.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Ti(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Ti(4, 2, e, t) }, useMemo: function (e, t) { var n = lt(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = lt(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = fg.bind(null, G, e), [r.memoizedState, e] }, useRef: function (e) { var t = lt(); return e = { current: e }, t.memoizedState = e }, useState: da, useDebugValue: nu, useDeferredValue: function (e) { return lt().memoizedState = e }, useTransition: function () { var e = da(!1), t = e[0]; return e = dg.bind(null, e[1]), lt().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = G, i = lt(); if (Q) { if (n === void 0) throw Error(_(407)); n = n() } else { if (n = t(), le === null) throw Error(_(349)); cn & 30 || Ld(r, t, n) } i.memoizedState = n; var o = { value: n, getSnapshot: t }; return i.queue = o, fa(Rd.bind(null, r, o, e), [e]), r.flags |= 2048, zr(9, jd.bind(null, r, o, n, t), void 0, null), n }, useId: function () { var e = lt(), t = le.identifierPrefix; if (Q) { var n = vt, r = mt; n = (r & ~(1 << 32 - nt(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = Ar++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = cg++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, gg = { readContext: Qe, useCallback: Hd, useContext: Qe, useEffect: tu, useImperativeHandle: Ud, useInsertionEffect: zd, useLayoutEffect: Fd, useMemo: Wd, useReducer: is, useRef: bd, useState: function () { return is(br) }, useDebugValue: nu, useDeferredValue: function (e) { var t = Ke(); return Bd(t, re.memoizedState, e) }, useTransition: function () { var e = is(br)[0], t = Ke().memoizedState; return [e, t] }, useMutableSource: Nd, useSyncExternalStore: Id, useId: Vd, unstable_isNewReconciler: !1 }, mg = { readContext: Qe, useCallback: Hd, useContext: Qe, useEffect: tu, useImperativeHandle: Ud, useInsertionEffect: zd, useLayoutEffect: Fd, useMemo: Wd, useReducer: os, useRef: bd, useState: function () { return os(br) }, useDebugValue: nu, useDeferredValue: function (e) { var t = Ke(); return re === null ? t.memoizedState = e : Bd(t, re.memoizedState, e) }, useTransition: function () { var e = os(br)[0], t = Ke().memoizedState; return [e, t] }, useMutableSource: Nd, useSyncExternalStore: Id, useId: Vd, unstable_isNewReconciler: !1 }; function Bn(e, t) {
    try { var n = "", r = t; do n += Bh(r), r = r.return; while (r); var i = n } catch (o) {
        i = `
Error generating stack: `+ o.message + `
`+ o.stack
    } return { value: e, source: t, stack: i, digest: null }
} function ss(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function el(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var vg = typeof WeakMap == "function" ? WeakMap : Map; function Gd(e, t, n) { n = yt(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { to || (to = !0, cl = r), el(e, t) }, n } function Yd(e, t, n) { n = yt(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { el(e, t) } } var o = e.stateNode; return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function () { el(e, t), typeof r != "function" && (Wt === null ? Wt = new Set([this]) : Wt.add(this)); var s = t.stack; this.componentDidCatch(t.value, { componentStack: s !== null ? s : "" }) }), n } function ha(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new vg; var i = new Set; r.set(t, i) } else i = r.get(t), i === void 0 && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = Ig.bind(null, e, t, n), t.then(e, e)) } function pa(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function ga(e, t, n, r, i) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = yt(-1, 1), t.tag = 2, Ht(n, t, 1))), n.lanes |= 1), e) } var yg = kt.ReactCurrentOwner, _e = !1; function ve(e, t, n, r) { t.child = e === null ? Dd(t, null, n, r) : Hn(t, e.child, n, r) } function ma(e, t, n, r, i) { n = n.render; var o = t.ref; return bn(t, i), r = Zl(e, t, n, r, o, i), n = eu(), e !== null && !_e ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ct(e, t, i)) : (Q && n && Ul(t), t.flags |= 1, ve(e, t, r, i), t.child) } function va(e, t, n, r, i) { if (e === null) { var o = n.type; return typeof o == "function" && !cu(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = o, Xd(e, t, o, r, i)) : (e = Ii(n.type, null, r, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e) } if (o = e.child, !(e.lanes & i)) { var s = o.memoizedProps; if (n = n.compare, n = n !== null ? n : Nr, n(s, r) && e.ref === t.ref) return Ct(e, t, i) } return t.flags |= 1, e = Vt(o, r), e.ref = t.ref, e.return = t, t.child = e } function Xd(e, t, n, r, i) { if (e !== null) { var o = e.memoizedProps; if (Nr(o, r) && e.ref === t.ref) if (_e = !1, t.pendingProps = r = o, (e.lanes & i) !== 0) e.flags & 131072 && (_e = !0); else return t.lanes = e.lanes, Ct(e, t, i) } return tl(e, t, n, r, i) } function Jd(e, t, n) { var r = t.pendingProps, i = r.children, o = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, W(Ln, Ne), Ne |= n; else { if (!(n & 1073741824)) return e = o !== null ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, W(Ln, Ne), Ne |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = o !== null ? o.baseLanes : n, W(Ln, Ne), Ne |= r } else o !== null ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, W(Ln, Ne), Ne |= r; return ve(e, t, i, n), t.child } function Zd(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function tl(e, t, n, r, i) { var o = Oe(n) ? un : me.current; return o = $n(t, o), bn(t, i), n = Zl(e, t, n, r, o, i), r = eu(), e !== null && !_e ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ct(e, t, i)) : (Q && r && Ul(t), t.flags |= 1, ve(e, t, n, i), t.child) } function ya(e, t, n, r, i) { if (Oe(n)) { var o = !0; Vi(t) } else o = !1; if (bn(t, i), t.stateNode === null) Di(e, t), Od(t, n, r), Zs(t, n, r, i), r = !0; else if (e === null) { var s = t.stateNode, l = t.memoizedProps; s.props = l; var u = s.context, a = n.contextType; typeof a == "object" && a !== null ? a = Qe(a) : (a = Oe(n) ? un : me.current, a = $n(t, a)); var g = n.getDerivedStateFromProps, p = typeof g == "function" || typeof s.getSnapshotBeforeUpdate == "function"; p || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (l !== r || u !== a) && aa(t, s, r, a), It = !1; var f = t.memoizedState; s.state = f, Yi(t, r, s, i), u = t.memoizedState, l !== r || f !== u || xe.current || It ? (typeof g == "function" && (Js(t, n, g, r), u = t.memoizedState), (l = It || ua(t, n, l, r, f, u, a)) ? (p || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = u), s.props = r, s.state = u, s.context = a, r = l) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { s = t.stateNode, _d(e, t), l = t.memoizedProps, a = t.type === t.elementType ? l : Ze(t.type, l), s.props = a, p = t.pendingProps, f = s.context, u = n.contextType, typeof u == "object" && u !== null ? u = Qe(u) : (u = Oe(n) ? un : me.current, u = $n(t, u)); var y = n.getDerivedStateFromProps; (g = typeof y == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (l !== p || f !== u) && aa(t, s, r, u), It = !1, f = t.memoizedState, s.state = f, Yi(t, r, s, i); var m = t.memoizedState; l !== p || f !== m || xe.current || It ? (typeof y == "function" && (Js(t, n, y, r), m = t.memoizedState), (a = It || ua(t, n, a, r, f, m, u) || !1) ? (g || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, m, u), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, m, u)), typeof s.componentDidUpdate == "function" && (t.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || l === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || l === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = m), s.props = r, s.state = m, s.context = u, r = a) : (typeof s.componentDidUpdate != "function" || l === e.memoizedProps && f === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || l === e.memoizedProps && f === e.memoizedState || (t.flags |= 1024), r = !1) } return nl(e, t, n, r, o, i) } function nl(e, t, n, r, i, o) { Zd(e, t); var s = (t.flags & 128) !== 0; if (!r && !s) return i && ra(t, n, !1), Ct(e, t, o); r = t.stateNode, yg.current = t; var l = s && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && s ? (t.child = Hn(t, e.child, null, o), t.child = Hn(t, null, l, o)) : ve(e, t, l, o), t.memoizedState = r.state, i && ra(t, n, !0), t.child } function ef(e) { var t = e.stateNode; t.pendingContext ? na(e, t.pendingContext, t.pendingContext !== t.context) : t.context && na(e, t.context, !1), Gl(e, t.containerInfo) } function Sa(e, t, n, r, i) { return Un(), Wl(i), t.flags |= 256, ve(e, t, n, r), t.child } var rl = { dehydrated: null, treeContext: null, retryLane: 0 }; function il(e) { return { baseLanes: e, cachePool: null, transitions: null } } function tf(e, t, n) { var r = t.pendingProps, i = q.current, o = !1, s = (t.flags & 128) !== 0, l; if ((l = s) || (l = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0), l ? (o = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1), W(q, i & 1), e === null) return Ys(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (s = r.children, e = r.fallback, o ? (r = t.mode, o = t.child, s = { mode: "hidden", children: s }, !(r & 1) && o !== null ? (o.childLanes = 0, o.pendingProps = s) : o = yo(s, r, 0, null), e = sn(e, r, n, null), o.return = t, e.return = t, o.sibling = e, t.child = o, t.child.memoizedState = il(n), t.memoizedState = rl, e) : ru(t, s)); if (i = e.memoizedState, i !== null && (l = i.dehydrated, l !== null)) return Sg(e, t, s, r, l, i, n); if (o) { o = r.fallback, s = t.mode, i = e.child, l = i.sibling; var u = { mode: "hidden", children: r.children }; return !(s & 1) && t.child !== i ? (r = t.child, r.childLanes = 0, r.pendingProps = u, t.deletions = null) : (r = Vt(i, u), r.subtreeFlags = i.subtreeFlags & 14680064), l !== null ? o = Vt(l, o) : (o = sn(o, s, n, null), o.flags |= 2), o.return = t, r.return = t, r.sibling = o, t.child = r, r = o, o = t.child, s = e.child.memoizedState, s = s === null ? il(n) : { baseLanes: s.baseLanes | n, cachePool: null, transitions: s.transitions }, o.memoizedState = s, o.childLanes = e.childLanes & ~n, t.memoizedState = rl, r } return o = e.child, e = o.sibling, r = Vt(o, { mode: "visible", children: r.children }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r } function ru(e, t) { return t = yo({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function hi(e, t, n, r) { return r !== null && Wl(r), Hn(t, e.child, null, n), e = ru(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function Sg(e, t, n, r, i, o, s) { if (n) return t.flags & 256 ? (t.flags &= -257, r = ss(Error(_(422))), hi(e, t, s, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (o = r.fallback, i = t.mode, r = yo({ mode: "visible", children: r.children }, i, 0, null), o = sn(o, i, s, null), o.flags |= 2, r.return = t, o.return = t, r.sibling = o, t.child = r, t.mode & 1 && Hn(t, e.child, null, s), t.child.memoizedState = il(s), t.memoizedState = rl, o); if (!(t.mode & 1)) return hi(e, t, s, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var l = r.dgst; return r = l, o = Error(_(419)), r = ss(o, r, void 0), hi(e, t, s, r) } if (l = (s & e.childLanes) !== 0, _e || l) { if (r = le, r !== null) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | s) ? 0 : i, i !== 0 && i !== o.retryLane && (o.retryLane = i, Et(e, i), rt(r, e, i, -1)) } return au(), r = ss(Error(_(421))), hi(e, t, s, r) } return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = Lg.bind(null, e), i._reactRetry = t, null) : (e = o.treeContext, Ie = Ut(i.nextSibling), Le = t, Q = !0, tt = null, e !== null && (Ue[He++] = mt, Ue[He++] = vt, Ue[He++] = an, mt = e.id, vt = e.overflow, an = t), t = ru(t, r.children), t.flags |= 4096, t) } function wa(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), Xs(e.return, t, n) } function ls(e, t, n, r, i) { var o = e.memoizedState; o === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i) } function nf(e, t, n) { var r = t.pendingProps, i = r.revealOrder, o = r.tail; if (ve(e, t, r.children, n), r = q.current, r & 2) r = r & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && wa(e, n, t); else if (e.tag === 19) wa(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (W(q, r), !(t.mode & 1)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; n !== null;)e = n.alternate, e !== null && Xi(e) === null && (i = n), n = n.sibling; n = i, n === null ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), ls(t, !1, i, n, o); break; case "backwards": for (n = null, i = t.child, t.child = null; i !== null;) { if (e = i.alternate, e !== null && Xi(e) === null) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } ls(t, !0, n, null, o); break; case "together": ls(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Di(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Ct(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), dn |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(_(153)); if (t.child !== null) { for (e = t.child, n = Vt(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = Vt(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function wg(e, t, n) { switch (t.tag) { case 3: ef(t), Un(); break; case 5: Pd(t); break; case 1: Oe(t.type) && Vi(t); break; case 4: Gl(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; W(qi, r._currentValue), r._currentValue = i; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (W(q, q.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? tf(e, t, n) : (W(q, q.current & 1), e = Ct(e, t, n), e !== null ? e.sibling : null); W(q, q.current & 1); break; case 19: if (r = (n & t.childLanes) !== 0, e.flags & 128) { if (r) return nf(e, t, n); t.flags |= 128 } if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), W(q, q.current), r) break; return null; case 22: case 23: return t.lanes = 0, Jd(e, t, n) }return Ct(e, t, n) } var rf, ol, of, sf; rf = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; ol = function () { }; of = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, rn(ct.current); var o = null; switch (n) { case "input": i = Ts(e, i), r = Ts(e, r), o = []; break; case "select": i = Y({}, i, { value: void 0 }), r = Y({}, r, { value: void 0 }), o = []; break; case "textarea": i = Ns(e, i), r = Ns(e, r), o = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = Wi) }Ls(n, r); var s; n = null; for (a in i) if (!r.hasOwnProperty(a) && i.hasOwnProperty(a) && i[a] != null) if (a === "style") { var l = i[a]; for (s in l) l.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else a !== "dangerouslySetInnerHTML" && a !== "children" && a !== "suppressContentEditableWarning" && a !== "suppressHydrationWarning" && a !== "autoFocus" && (kr.hasOwnProperty(a) ? o || (o = []) : (o = o || []).push(a, null)); for (a in r) { var u = r[a]; if (l = i != null ? i[a] : void 0, r.hasOwnProperty(a) && u !== l && (u != null || l != null)) if (a === "style") if (l) { for (s in l) !l.hasOwnProperty(s) || u && u.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in u) u.hasOwnProperty(s) && l[s] !== u[s] && (n || (n = {}), n[s] = u[s]) } else n || (o || (o = []), o.push(a, n)), n = u; else a === "dangerouslySetInnerHTML" ? (u = u ? u.__html : void 0, l = l ? l.__html : void 0, u != null && l !== u && (o = o || []).push(a, u)) : a === "children" ? typeof u != "string" && typeof u != "number" || (o = o || []).push(a, "" + u) : a !== "suppressContentEditableWarning" && a !== "suppressHydrationWarning" && (kr.hasOwnProperty(a) ? (u != null && a === "onScroll" && B("scroll", e), o || l === u || (o = [])) : (o = o || []).push(a, u)) } n && (o = o || []).push("style", n); var a = o; (t.updateQueue = a) && (t.flags |= 4) } }; sf = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function nr(e, t) { if (!Q) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function he(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = e, i = i.sibling; else for (i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function Eg(e, t, n) { var r = t.pendingProps; switch (Hl(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return he(t), null; case 1: return Oe(t.type) && Bi(), he(t), null; case 3: return r = t.stateNode, Wn(), V(xe), V(me), Xl(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (di(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, tt !== null && (hl(tt), tt = null))), ol(e, t), he(t), null; case 5: Yl(t); var i = rn(Mr.current); if (n = t.type, e !== null && t.stateNode != null) of(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(_(166)); return he(t), null } if (e = rn(ct.current), di(t)) { r = t.stateNode, n = t.type; var o = t.memoizedProps; switch (r[ut] = t, r[jr] = o, e = (t.mode & 1) !== 0, n) { case "dialog": B("cancel", r), B("close", r); break; case "iframe": case "object": case "embed": B("load", r); break; case "video": case "audio": for (i = 0; i < cr.length; i++)B(cr[i], r); break; case "source": B("error", r); break; case "img": case "image": case "link": B("error", r), B("load", r); break; case "details": B("toggle", r); break; case "input": Pu(r, o), B("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!o.multiple }, B("invalid", r); break; case "textarea": Iu(r, o), B("invalid", r) }Ls(n, o), i = null; for (var s in o) if (o.hasOwnProperty(s)) { var l = o[s]; s === "children" ? typeof l == "string" ? r.textContent !== l && (o.suppressHydrationWarning !== !0 && ci(r.textContent, l, e), i = ["children", l]) : typeof l == "number" && r.textContent !== "" + l && (o.suppressHydrationWarning !== !0 && ci(r.textContent, l, e), i = ["children", "" + l]) : kr.hasOwnProperty(s) && l != null && s === "onScroll" && B("scroll", r) } switch (n) { case "input": ni(r), Nu(r, o, !0); break; case "textarea": ni(r), Lu(r); break; case "select": case "option": break; default: typeof o.onClick == "function" && (r.onclick = Wi) }r = i, t.updateQueue = r, r !== null && (t.flags |= 4) } else { s = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = Lc(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = s.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = s.createElement(n, { is: r.is }) : (e = s.createElement(n), n === "select" && (s = e, r.multiple ? s.multiple = !0 : r.size && (s.size = r.size))) : e = s.createElementNS(e, n), e[ut] = t, e[jr] = r, rf(e, t, !1, !1), t.stateNode = e; e: { switch (s = js(n, r), n) { case "dialog": B("cancel", e), B("close", e), i = r; break; case "iframe": case "object": case "embed": B("load", e), i = r; break; case "video": case "audio": for (i = 0; i < cr.length; i++)B(cr[i], e); i = r; break; case "source": B("error", e), i = r; break; case "img": case "image": case "link": B("error", e), B("load", e), i = r; break; case "details": B("toggle", e), i = r; break; case "input": Pu(e, r), i = Ts(e, r), B("invalid", e); break; case "option": i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = Y({}, r, { value: void 0 }), B("invalid", e); break; case "textarea": Iu(e, r), i = Ns(e, r), B("invalid", e); break; default: i = r }Ls(n, i), l = i; for (o in l) if (l.hasOwnProperty(o)) { var u = l[o]; o === "style" ? Mc(e, u) : o === "dangerouslySetInnerHTML" ? (u = u ? u.__html : void 0, u != null && jc(e, u)) : o === "children" ? typeof u == "string" ? (n !== "textarea" || u !== "") && _r(e, u) : typeof u == "number" && _r(e, "" + u) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (kr.hasOwnProperty(o) ? u != null && o === "onScroll" && B("scroll", e) : u != null && Tl(e, o, u, s)) } switch (n) { case "input": ni(e), Nu(e, r, !1); break; case "textarea": ni(e), Lu(e); break; case "option": r.value != null && e.setAttribute("value", "" + Kt(r.value)); break; case "select": e.multiple = !!r.multiple, o = r.value, o != null ? jn(e, !!r.multiple, o, !1) : r.defaultValue != null && jn(e, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (e.onclick = Wi) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return he(t), null; case 6: if (e && t.stateNode != null) sf(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(_(166)); if (n = rn(Mr.current), rn(ct.current), di(t)) { if (r = t.stateNode, n = t.memoizedProps, r[ut] = t, (o = r.nodeValue !== n) && (e = Le, e !== null)) switch (e.tag) { case 3: ci(r.nodeValue, n, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && ci(r.nodeValue, n, (e.mode & 1) !== 0) }o && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[ut] = t, t.stateNode = r } return he(t), null; case 13: if (V(q), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (Q && Ie !== null && t.mode & 1 && !(t.flags & 128)) Cd(), Un(), t.flags |= 98560, o = !1; else if (o = di(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!o) throw Error(_(318)); if (o = t.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(_(317)); o[ut] = t } else Un(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; he(t), o = !1 } else tt !== null && (hl(tt), tt = null), o = !0; if (!o) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || q.current & 1 ? ie === 0 && (ie = 3) : au())), t.updateQueue !== null && (t.flags |= 4), he(t), null); case 4: return Wn(), ol(e, t), e === null && Ir(t.stateNode.containerInfo), he(t), null; case 10: return Ql(t.type._context), he(t), null; case 17: return Oe(t.type) && Bi(), he(t), null; case 19: if (V(q), o = t.memoizedState, o === null) return he(t), null; if (r = (t.flags & 128) !== 0, s = o.rendering, s === null) if (r) nr(o, !1); else { if (ie !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (s = Xi(e), s !== null) { for (t.flags |= 128, nr(o, !1), r = s.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)o = n, e = r, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, e = s.dependencies, o.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return W(q, q.current & 1 | 2), t.child } e = e.sibling } o.tail !== null && Z() > Vn && (t.flags |= 128, r = !0, nr(o, !1), t.lanes = 4194304) } else { if (!r) if (e = Xi(s), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), nr(o, !0), o.tail === null && o.tailMode === "hidden" && !s.alternate && !Q) return he(t), null } else 2 * Z() - o.renderingStartTime > Vn && n !== 1073741824 && (t.flags |= 128, r = !0, nr(o, !1), t.lanes = 4194304); o.isBackwards ? (s.sibling = t.child, t.child = s) : (n = o.last, n !== null ? n.sibling = s : t.child = s, o.last = s) } return o.tail !== null ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = Z(), t.sibling = null, n = q.current, W(q, r ? n & 1 | 2 : n & 1), t) : (he(t), null); case 22: case 23: return uu(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? Ne & 1073741824 && (he(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : he(t), null; case 24: return null; case 25: return null }throw Error(_(156, t.tag)) } function Cg(e, t) { switch (Hl(t), t.tag) { case 1: return Oe(t.type) && Bi(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return Wn(), V(xe), V(me), Xl(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return Yl(t), null; case 13: if (V(q), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(_(340)); Un() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return V(q), null; case 4: return Wn(), null; case 10: return Ql(t.type._context), null; case 22: case 23: return uu(), null; case 24: return null; default: return null } } var pi = !1, ge = !1, kg = typeof WeakSet == "function" ? WeakSet : Set, P = null; function In(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { J(e, t, r) } else n.current = null } function sl(e, t, n) { try { n() } catch (r) { J(e, t, r) } } var Ea = !1; function _g(e, t) { if (Ws = $i, e = ad(), $l(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, o = r.focusNode; r = r.focusOffset; try { n.nodeType, o.nodeType } catch { n = null; break e } var s = 0, l = -1, u = -1, a = 0, g = 0, p = e, f = null; t: for (; ;) { for (var y; p !== n || i !== 0 && p.nodeType !== 3 || (l = s + i), p !== o || r !== 0 && p.nodeType !== 3 || (u = s + r), p.nodeType === 3 && (s += p.nodeValue.length), (y = p.firstChild) !== null;)f = p, p = y; for (; ;) { if (p === e) break t; if (f === n && ++a === i && (l = s), f === o && ++g === r && (u = s), (y = p.nextSibling) !== null) break; p = f, f = p.parentNode } p = y } n = l === -1 || u === -1 ? null : { start: l, end: u } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (Bs = { focusedElem: e, selectionRange: n }, $i = !1, P = t; P !== null;)if (t = P, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, P = e; else for (; P !== null;) { t = P; try { var m = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (m !== null) { var v = m.memoizedProps, E = m.memoizedState, d = t.stateNode, c = d.getSnapshotBeforeUpdate(t.elementType === t.type ? v : Ze(t.type, v), E); d.__reactInternalSnapshotBeforeUpdate = c } break; case 3: var h = t.stateNode.containerInfo; h.nodeType === 1 ? h.textContent = "" : h.nodeType === 9 && h.documentElement && h.removeChild(h.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(_(163)) } } catch (w) { J(t, t.return, w) } if (e = t.sibling, e !== null) { e.return = t.return, P = e; break } P = t.return } return m = Ea, Ea = !1, m } function yr(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & e) === e) { var o = i.destroy; i.destroy = void 0, o !== void 0 && sl(t, n, o) } i = i.next } while (i !== r) } } function mo(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function ll(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function lf(e) { var t = e.alternate; t !== null && (e.alternate = null, lf(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[ut], delete t[jr], delete t[Ks], delete t[sg], delete t[lg])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function uf(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function Ca(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || uf(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function ul(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Wi)); else if (r !== 4 && (e = e.child, e !== null)) for (ul(e, t, n), e = e.sibling; e !== null;)ul(e, t, n), e = e.sibling } function al(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (al(e, t, n), e = e.sibling; e !== null;)al(e, t, n), e = e.sibling } var ue = null, et = !1; function Tt(e, t, n) { for (n = n.child; n !== null;)af(e, t, n), n = n.sibling } function af(e, t, n) { if (at && typeof at.onCommitFiberUnmount == "function") try { at.onCommitFiberUnmount(lo, n) } catch { } switch (n.tag) { case 5: ge || In(n, t); case 6: var r = ue, i = et; ue = null, Tt(e, t, n), ue = r, et = i, ue !== null && (et ? (e = ue, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : ue.removeChild(n.stateNode)); break; case 18: ue !== null && (et ? (e = ue, n = n.stateNode, e.nodeType === 8 ? es(e.parentNode, n) : e.nodeType === 1 && es(e, n), Dr(e)) : es(ue, n.stateNode)); break; case 4: r = ue, i = et, ue = n.stateNode.containerInfo, et = !0, Tt(e, t, n), ue = r, et = i; break; case 0: case 11: case 14: case 15: if (!ge && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var o = i, s = o.destroy; o = o.tag, s !== void 0 && (o & 2 || o & 4) && sl(n, t, s), i = i.next } while (i !== r) } Tt(e, t, n); break; case 1: if (!ge && (In(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (l) { J(n, t, l) } Tt(e, t, n); break; case 21: Tt(e, t, n); break; case 22: n.mode & 1 ? (ge = (r = ge) || n.memoizedState !== null, Tt(e, t, n), ge = r) : Tt(e, t, n); break; default: Tt(e, t, n) } } function ka(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new kg), t.forEach(function (r) { var i = jg.bind(null, e, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function Je(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var o = e, s = t, l = s; e: for (; l !== null;) { switch (l.tag) { case 5: ue = l.stateNode, et = !1; break e; case 3: ue = l.stateNode.containerInfo, et = !0; break e; case 4: ue = l.stateNode.containerInfo, et = !0; break e }l = l.return } if (ue === null) throw Error(_(160)); af(o, s, i), ue = null, et = !1; var u = i.alternate; u !== null && (u.return = null), i.return = null } catch (a) { J(i, t, a) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)cf(t, e), t = t.sibling } function cf(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Je(t, e), st(e), r & 4) { try { yr(3, e, e.return), mo(3, e) } catch (v) { J(e, e.return, v) } try { yr(5, e, e.return) } catch (v) { J(e, e.return, v) } } break; case 1: Je(t, e), st(e), r & 512 && n !== null && In(n, n.return); break; case 5: if (Je(t, e), st(e), r & 512 && n !== null && In(n, n.return), e.flags & 32) { var i = e.stateNode; try { _r(i, "") } catch (v) { J(e, e.return, v) } } if (r & 4 && (i = e.stateNode, i != null)) { var o = e.memoizedProps, s = n !== null ? n.memoizedProps : o, l = e.type, u = e.updateQueue; if (e.updateQueue = null, u !== null) try { l === "input" && o.type === "radio" && o.name != null && Nc(i, o), js(l, s); var a = js(l, o); for (s = 0; s < u.length; s += 2) { var g = u[s], p = u[s + 1]; g === "style" ? Mc(i, p) : g === "dangerouslySetInnerHTML" ? jc(i, p) : g === "children" ? _r(i, p) : Tl(i, g, p, a) } switch (l) { case "input": Ds(i, o); break; case "textarea": Ic(i, o); break; case "select": var f = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!o.multiple; var y = o.value; y != null ? jn(i, !!o.multiple, y, !1) : f !== !!o.multiple && (o.defaultValue != null ? jn(i, !!o.multiple, o.defaultValue, !0) : jn(i, !!o.multiple, o.multiple ? [] : "", !1)) }i[jr] = o } catch (v) { J(e, e.return, v) } } break; case 6: if (Je(t, e), st(e), r & 4) { if (e.stateNode === null) throw Error(_(162)); i = e.stateNode, o = e.memoizedProps; try { i.nodeValue = o } catch (v) { J(e, e.return, v) } } break; case 3: if (Je(t, e), st(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try { Dr(t.containerInfo) } catch (v) { J(e, e.return, v) } break; case 4: Je(t, e), st(e); break; case 13: Je(t, e), st(e), i = e.child, i.flags & 8192 && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (su = Z())), r & 4 && ka(e); break; case 22: if (g = n !== null && n.memoizedState !== null, e.mode & 1 ? (ge = (a = ge) || g, Je(t, e), ge = a) : Je(t, e), st(e), r & 8192) { if (a = e.memoizedState !== null, (e.stateNode.isHidden = a) && !g && e.mode & 1) for (P = e, g = e.child; g !== null;) { for (p = P = g; P !== null;) { switch (f = P, y = f.child, f.tag) { case 0: case 11: case 14: case 15: yr(4, f, f.return); break; case 1: In(f, f.return); var m = f.stateNode; if (typeof m.componentWillUnmount == "function") { r = f, n = f.return; try { t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount() } catch (v) { J(r, n, v) } } break; case 5: In(f, f.return); break; case 22: if (f.memoizedState !== null) { xa(p); continue } }y !== null ? (y.return = f, P = y) : xa(p) } g = g.sibling } e: for (g = null, p = e; ;) { if (p.tag === 5) { if (g === null) { g = p; try { i = p.stateNode, a ? (o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (l = p.stateNode, u = p.memoizedProps.style, s = u != null && u.hasOwnProperty("display") ? u.display : null, l.style.display = Rc("display", s)) } catch (v) { J(e, e.return, v) } } } else if (p.tag === 6) { if (g === null) try { p.stateNode.nodeValue = a ? "" : p.memoizedProps } catch (v) { J(e, e.return, v) } } else if ((p.tag !== 22 && p.tag !== 23 || p.memoizedState === null || p === e) && p.child !== null) { p.child.return = p, p = p.child; continue } if (p === e) break e; for (; p.sibling === null;) { if (p.return === null || p.return === e) break e; g === p && (g = null), p = p.return } g === p && (g = null), p.sibling.return = p.return, p = p.sibling } } break; case 19: Je(t, e), st(e), r & 4 && ka(e); break; case 21: break; default: Je(t, e), st(e) } } function st(e) { var t = e.flags; if (t & 2) { try { e: { for (var n = e.return; n !== null;) { if (uf(n)) { var r = n; break e } n = n.return } throw Error(_(160)) } switch (r.tag) { case 5: var i = r.stateNode; r.flags & 32 && (_r(i, ""), r.flags &= -33); var o = Ca(e); al(e, o, i); break; case 3: case 4: var s = r.stateNode.containerInfo, l = Ca(e); ul(e, l, s); break; default: throw Error(_(161)) } } catch (u) { J(e, e.return, u) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function xg(e, t, n) { P = e, df(e) } function df(e, t, n) { for (var r = (e.mode & 1) !== 0; P !== null;) { var i = P, o = i.child; if (i.tag === 22 && r) { var s = i.memoizedState !== null || pi; if (!s) { var l = i.alternate, u = l !== null && l.memoizedState !== null || ge; l = pi; var a = ge; if (pi = s, (ge = u) && !a) for (P = i; P !== null;)s = P, u = s.child, s.tag === 22 && s.memoizedState !== null ? Oa(i) : u !== null ? (u.return = s, P = u) : Oa(i); for (; o !== null;)P = o, df(o), o = o.sibling; P = i, pi = l, ge = a } _a(e) } else i.subtreeFlags & 8772 && o !== null ? (o.return = i, P = o) : _a(e) } } function _a(e) { for (; P !== null;) { var t = P; if (t.flags & 8772) { var n = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: ge || mo(5, t); break; case 1: var r = t.stateNode; if (t.flags & 4 && !ge) if (n === null) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : Ze(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var o = t.updateQueue; o !== null && la(t, o, r); break; case 3: var s = t.updateQueue; if (s !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }la(t, s, n) } break; case 5: var l = t.stateNode; if (n === null && t.flags & 4) { n = l; var u = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": u.autoFocus && n.focus(); break; case "img": u.src && (n.src = u.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var a = t.alternate; if (a !== null) { var g = a.memoizedState; if (g !== null) { var p = g.dehydrated; p !== null && Dr(p) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(_(163)) }ge || t.flags & 512 && ll(t) } catch (f) { J(t, t.return, f) } } if (t === e) { P = null; break } if (n = t.sibling, n !== null) { n.return = t.return, P = n; break } P = t.return } } function xa(e) { for (; P !== null;) { var t = P; if (t === e) { P = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, P = n; break } P = t.return } } function Oa(e) { for (; P !== null;) { var t = P; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { mo(4, t) } catch (u) { J(t, n, u) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var i = t.return; try { r.componentDidMount() } catch (u) { J(t, i, u) } } var o = t.return; try { ll(t) } catch (u) { J(t, o, u) } break; case 5: var s = t.return; try { ll(t) } catch (u) { J(t, s, u) } } } catch (u) { J(t, t.return, u) } if (t === e) { P = null; break } var l = t.sibling; if (l !== null) { l.return = t.return, P = l; break } P = t.return } } var Og = Math.ceil, eo = kt.ReactCurrentDispatcher, iu = kt.ReactCurrentOwner, Ve = kt.ReactCurrentBatchConfig, F = 0, le = null, te = null, ae = 0, Ne = 0, Ln = Yt(0), ie = 0, Fr = null, dn = 0, vo = 0, ou = 0, Sr = null, ke = null, su = 0, Vn = 1 / 0, pt = null, to = !1, cl = null, Wt = null, gi = !1, bt = null, no = 0, wr = 0, dl = null, Pi = -1, Ni = 0; function ye() { return F & 6 ? Z() : Pi !== -1 ? Pi : Pi = Z() } function Bt(e) { return e.mode & 1 ? F & 2 && ae !== 0 ? ae & -ae : ag.transition !== null ? (Ni === 0 && (Ni = Kc()), Ni) : (e = U, e !== 0 || (e = window.event, e = e === void 0 ? 16 : ed(e.type)), e) : 1 } function rt(e, t, n, r) { if (50 < wr) throw wr = 0, dl = null, Error(_(185)); Br(e, n, r), (!(F & 2) || e !== le) && (e === le && (!(F & 2) && (vo |= n), ie === 4 && Rt(e, ae)), Te(e, r), n === 1 && F === 0 && !(t.mode & 1) && (Vn = Z() + 500, ho && Xt())) } function Te(e, t) { var n = e.callbackNode; ap(e, t); var r = Fi(e, e === le ? ae : 0); if (r === 0) n !== null && Mu(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && Mu(n), t === 1) e.tag === 0 ? ug(Ta.bind(null, e)) : Sd(Ta.bind(null, e)), ig(function () { !(F & 6) && Xt() }), n = null; else { switch (qc(r)) { case 1: n = Ll; break; case 4: n = Vc; break; case 16: n = zi; break; case 536870912: n = Qc; break; default: n = zi }n = Sf(n, ff.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function ff(e, t) { if (Pi = -1, Ni = 0, F & 6) throw Error(_(327)); var n = e.callbackNode; if (zn() && e.callbackNode !== n) return null; var r = Fi(e, e === le ? ae : 0); if (r === 0) return null; if (r & 30 || r & e.expiredLanes || t) t = ro(e, r); else { t = r; var i = F; F |= 2; var o = pf(); (le !== e || ae !== t) && (pt = null, Vn = Z() + 500, on(e, t)); do try { Pg(); break } catch (l) { hf(e, l) } while (1); Vl(), eo.current = o, F = i, te !== null ? t = 0 : (le = null, ae = 0, t = ie) } if (t !== 0) { if (t === 2 && (i = zs(e), i !== 0 && (r = i, t = fl(e, i))), t === 1) throw n = Fr, on(e, 0), Rt(e, r), Te(e, Z()), n; if (t === 6) Rt(e, r); else { if (i = e.current.alternate, !(r & 30) && !Tg(i) && (t = ro(e, r), t === 2 && (o = zs(e), o !== 0 && (r = o, t = fl(e, o))), t === 1)) throw n = Fr, on(e, 0), Rt(e, r), Te(e, Z()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(_(345)); case 2: en(e, ke, pt); break; case 3: if (Rt(e, r), (r & 130023424) === r && (t = su + 500 - Z(), 10 < t)) { if (Fi(e, 0) !== 0) break; if (i = e.suspendedLanes, (i & r) !== r) { ye(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = Qs(en.bind(null, e, ke, pt), t); break } en(e, ke, pt); break; case 4: if (Rt(e, r), (r & 4194240) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - nt(r); o = 1 << s, s = t[s], s > i && (i = s), r &= ~o } if (r = i, r = Z() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Og(r / 1960)) - r, 10 < r) { e.timeoutHandle = Qs(en.bind(null, e, ke, pt), r); break } en(e, ke, pt); break; case 5: en(e, ke, pt); break; default: throw Error(_(329)) } } } return Te(e, Z()), e.callbackNode === n ? ff.bind(null, e) : null } function fl(e, t) { var n = Sr; return e.current.memoizedState.isDehydrated && (on(e, t).flags |= 256), e = ro(e, t), e !== 2 && (t = ke, ke = n, t !== null && hl(t)), e } function hl(e) { ke === null ? ke = e : ke.push.apply(ke, e) } function Tg(e) { for (var t = e; ;) { if (t.flags & 16384) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], o = i.getSnapshot; i = i.value; try { if (!it(o(), i)) return !1 } catch { return !1 } } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function Rt(e, t) { for (t &= ~ou, t &= ~vo, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - nt(t), r = 1 << n; e[n] = -1, t &= ~r } } function Ta(e) { if (F & 6) throw Error(_(327)); zn(); var t = Fi(e, 0); if (!(t & 1)) return Te(e, Z()), null; var n = ro(e, t); if (e.tag !== 0 && n === 2) { var r = zs(e); r !== 0 && (t = r, n = fl(e, r)) } if (n === 1) throw n = Fr, on(e, 0), Rt(e, t), Te(e, Z()), n; if (n === 6) throw Error(_(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, en(e, ke, pt), Te(e, Z()), null } function lu(e, t) { var n = F; F |= 1; try { return e(t) } finally { F = n, F === 0 && (Vn = Z() + 500, ho && Xt()) } } function fn(e) { bt !== null && bt.tag === 0 && !(F & 6) && zn(); var t = F; F |= 1; var n = Ve.transition, r = U; try { if (Ve.transition = null, U = 1, e) return e() } finally { U = r, Ve.transition = n, F = t, !(F & 6) && Xt() } } function uu() { Ne = Ln.current, V(Ln) } function on(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, rg(n)), te !== null) for (n = te.return; n !== null;) { var r = n; switch (Hl(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Bi(); break; case 3: Wn(), V(xe), V(me), Xl(); break; case 5: Yl(r); break; case 4: Wn(); break; case 13: V(q); break; case 19: V(q); break; case 10: Ql(r.type._context); break; case 22: case 23: uu() }n = n.return } if (le = e, te = e = Vt(e.current, null), ae = Ne = t, ie = 0, Fr = null, ou = vo = dn = 0, ke = Sr = null, nn !== null) { for (t = 0; t < nn.length; t++)if (n = nn[t], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, o = n.pending; if (o !== null) { var s = o.next; o.next = i, r.next = s } n.pending = r } nn = null } return e } function hf(e, t) { do { var n = te; try { if (Vl(), Oi.current = Zi, Ji) { for (var r = G.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } Ji = !1 } if (cn = 0, se = re = G = null, vr = !1, Ar = 0, iu.current = null, n === null || n.return === null) { ie = 1, Fr = t, te = null; break } e: { var o = e, s = n.return, l = n, u = t; if (t = ae, l.flags |= 32768, u !== null && typeof u == "object" && typeof u.then == "function") { var a = u, g = l, p = g.tag; if (!(g.mode & 1) && (p === 0 || p === 11 || p === 15)) { var f = g.alternate; f ? (g.updateQueue = f.updateQueue, g.memoizedState = f.memoizedState, g.lanes = f.lanes) : (g.updateQueue = null, g.memoizedState = null) } var y = pa(s); if (y !== null) { y.flags &= -257, ga(y, s, l, o, t), y.mode & 1 && ha(o, a, t), t = y, u = a; var m = t.updateQueue; if (m === null) { var v = new Set; v.add(u), t.updateQueue = v } else m.add(u); break e } else { if (!(t & 1)) { ha(o, a, t), au(); break e } u = Error(_(426)) } } else if (Q && l.mode & 1) { var E = pa(s); if (E !== null) { !(E.flags & 65536) && (E.flags |= 256), ga(E, s, l, o, t), Wl(Bn(u, l)); break e } } o = u = Bn(u, l), ie !== 4 && (ie = 2), Sr === null ? Sr = [o] : Sr.push(o), o = s; do { switch (o.tag) { case 3: o.flags |= 65536, t &= -t, o.lanes |= t; var d = Gd(o, u, t); sa(o, d); break e; case 1: l = u; var c = o.type, h = o.stateNode; if (!(o.flags & 128) && (typeof c.getDerivedStateFromError == "function" || h !== null && typeof h.componentDidCatch == "function" && (Wt === null || !Wt.has(h)))) { o.flags |= 65536, t &= -t, o.lanes |= t; var w = Yd(o, l, t); sa(o, w); break e } }o = o.return } while (o !== null) } mf(n) } catch (k) { t = k, te === n && n !== null && (te = n = n.return); continue } break } while (1) } function pf() { var e = eo.current; return eo.current = Zi, e === null ? Zi : e } function au() { (ie === 0 || ie === 3 || ie === 2) && (ie = 4), le === null || !(dn & 268435455) && !(vo & 268435455) || Rt(le, ae) } function ro(e, t) { var n = F; F |= 2; var r = pf(); (le !== e || ae !== t) && (pt = null, on(e, t)); do try { Dg(); break } catch (i) { hf(e, i) } while (1); if (Vl(), F = n, eo.current = r, te !== null) throw Error(_(261)); return le = null, ae = 0, ie } function Dg() { for (; te !== null;)gf(te) } function Pg() { for (; te !== null && !ep();)gf(te) } function gf(e) { var t = yf(e.alternate, e, Ne); e.memoizedProps = e.pendingProps, t === null ? mf(e) : te = t, iu.current = null } function mf(e) { var t = e; do { var n = t.alternate; if (e = t.return, t.flags & 32768) { if (n = Cg(n, t), n !== null) { n.flags &= 32767, te = n; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { ie = 6, te = null; return } } else if (n = Eg(n, t, Ne), n !== null) { te = n; return } if (t = t.sibling, t !== null) { te = t; return } te = t = e } while (t !== null); ie === 0 && (ie = 5) } function en(e, t, n) { var r = U, i = Ve.transition; try { Ve.transition = null, U = 1, Ng(e, t, n, r) } finally { Ve.transition = i, U = r } return null } function Ng(e, t, n, r) { do zn(); while (bt !== null); if (F & 6) throw Error(_(327)); n = e.finishedWork; var i = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(_(177)); e.callbackNode = null, e.callbackPriority = 0; var o = n.lanes | n.childLanes; if (cp(e, o), e === le && (te = le = null, ae = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || gi || (gi = !0, Sf(zi, function () { return zn(), null })), o = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || o) { o = Ve.transition, Ve.transition = null; var s = U; U = 1; var l = F; F |= 4, iu.current = null, _g(e, n), cf(n, e), Yp(Bs), $i = !!Ws, Bs = Ws = null, e.current = n, xg(n), tp(), F = l, U = s, Ve.transition = o } else e.current = n; if (gi && (gi = !1, bt = e, no = i), o = e.pendingLanes, o === 0 && (Wt = null), ip(n.stateNode), Te(e, Z()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (to) throw to = !1, e = cl, cl = null, e; return no & 1 && e.tag !== 0 && zn(), o = e.pendingLanes, o & 1 ? e === dl ? wr++ : (wr = 0, dl = e) : wr = 0, Xt(), null } function zn() { if (bt !== null) { var e = qc(no), t = Ve.transition, n = U; try { if (Ve.transition = null, U = 16 > e ? 16 : e, bt === null) var r = !1; else { if (e = bt, bt = null, no = 0, F & 6) throw Error(_(331)); var i = F; for (F |= 4, P = e.current; P !== null;) { var o = P, s = o.child; if (P.flags & 16) { var l = o.deletions; if (l !== null) { for (var u = 0; u < l.length; u++) { var a = l[u]; for (P = a; P !== null;) { var g = P; switch (g.tag) { case 0: case 11: case 15: yr(8, g, o) }var p = g.child; if (p !== null) p.return = g, P = p; else for (; P !== null;) { g = P; var f = g.sibling, y = g.return; if (lf(g), g === a) { P = null; break } if (f !== null) { f.return = y, P = f; break } P = y } } } var m = o.alternate; if (m !== null) { var v = m.child; if (v !== null) { m.child = null; do { var E = v.sibling; v.sibling = null, v = E } while (v !== null) } } P = o } } if (o.subtreeFlags & 2064 && s !== null) s.return = o, P = s; else e: for (; P !== null;) { if (o = P, o.flags & 2048) switch (o.tag) { case 0: case 11: case 15: yr(9, o, o.return) }var d = o.sibling; if (d !== null) { d.return = o.return, P = d; break e } P = o.return } } var c = e.current; for (P = c; P !== null;) { s = P; var h = s.child; if (s.subtreeFlags & 2064 && h !== null) h.return = s, P = h; else e: for (s = c; P !== null;) { if (l = P, l.flags & 2048) try { switch (l.tag) { case 0: case 11: case 15: mo(9, l) } } catch (k) { J(l, l.return, k) } if (l === s) { P = null; break e } var w = l.sibling; if (w !== null) { w.return = l.return, P = w; break e } P = l.return } } if (F = i, Xt(), at && typeof at.onPostCommitFiberRoot == "function") try { at.onPostCommitFiberRoot(lo, e) } catch { } r = !0 } return r } finally { U = n, Ve.transition = t } } return !1 } function Da(e, t, n) { t = Bn(n, t), t = Gd(e, t, 1), e = Ht(e, t, 1), t = ye(), e !== null && (Br(e, 1, t), Te(e, t)) } function J(e, t, n) { if (e.tag === 3) Da(e, e, n); else for (; t !== null;) { if (t.tag === 3) { Da(t, e, n); break } else if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Wt === null || !Wt.has(r))) { e = Bn(n, e), e = Yd(t, e, 1), t = Ht(t, e, 1), e = ye(), t !== null && (Br(t, 1, e), Te(t, e)); break } } t = t.return } } function Ig(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = ye(), e.pingedLanes |= e.suspendedLanes & n, le === e && (ae & n) === n && (ie === 4 || ie === 3 && (ae & 130023424) === ae && 500 > Z() - su ? on(e, 0) : ou |= n), Te(e, t) } function vf(e, t) { t === 0 && (e.mode & 1 ? (t = oi, oi <<= 1, !(oi & 130023424) && (oi = 4194304)) : t = 1); var n = ye(); e = Et(e, t), e !== null && (Br(e, t, n), Te(e, n)) } function Lg(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), vf(e, n) } function jg(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(_(314)) }r !== null && r.delete(t), vf(e, n) } var yf; yf = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || xe.current) _e = !0; else { if (!(e.lanes & n) && !(t.flags & 128)) return _e = !1, wg(e, t, n); _e = !!(e.flags & 131072) } else _e = !1, Q && t.flags & 1048576 && wd(t, Ki, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Di(e, t), e = t.pendingProps; var i = $n(t, me.current); bn(t, n), i = Zl(null, t, r, e, i, n); var o = eu(); return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Oe(r) ? (o = !0, Vi(t)) : o = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, ql(t), i.updater = po, t.stateNode = i, i._reactInternals = t, Zs(t, r, e, n), t = nl(null, t, r, !0, o, n)) : (t.tag = 0, Q && o && Ul(t), ve(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Di(e, t), e = t.pendingProps, i = r._init, r = i(r._payload), t.type = r, i = t.tag = Mg(r), e = Ze(r, e), i) { case 0: t = tl(null, t, r, e, n); break e; case 1: t = ya(null, t, r, e, n); break e; case 11: t = ma(null, t, r, e, n); break e; case 14: t = va(null, t, r, Ze(r.type, e), n); break e }throw Error(_(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Ze(r, i), tl(e, t, r, i, n); case 1: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Ze(r, i), ya(e, t, r, i, n); case 3: e: { if (ef(t), e === null) throw Error(_(387)); r = t.pendingProps, o = t.memoizedState, i = o.element, _d(e, t), Yi(t, r, null, n); var s = t.memoizedState; if (r = s.element, o.isDehydrated) if (o = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = o, t.memoizedState = o, t.flags & 256) { i = Bn(Error(_(423)), t), t = Sa(e, t, r, n, i); break e } else if (r !== i) { i = Bn(Error(_(424)), t), t = Sa(e, t, r, n, i); break e } else for (Ie = Ut(t.stateNode.containerInfo.firstChild), Le = t, Q = !0, tt = null, n = Dd(t, null, r, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (Un(), r === i) { t = Ct(e, t, n); break e } ve(e, t, r, n) } t = t.child } return t; case 5: return Pd(t), e === null && Ys(t), r = t.type, i = t.pendingProps, o = e !== null ? e.memoizedProps : null, s = i.children, Vs(r, i) ? s = null : o !== null && Vs(r, o) && (t.flags |= 32), Zd(e, t), ve(e, t, s, n), t.child; case 6: return e === null && Ys(t), null; case 13: return tf(e, t, n); case 4: return Gl(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = Hn(t, null, r, n) : ve(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Ze(r, i), ma(e, t, r, i, n); case 7: return ve(e, t, t.pendingProps, n), t.child; case 8: return ve(e, t, t.pendingProps.children, n), t.child; case 12: return ve(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, o = t.memoizedProps, s = i.value, W(qi, r._currentValue), r._currentValue = s, o !== null) if (it(o.value, s)) { if (o.children === i.children && !xe.current) { t = Ct(e, t, n); break e } } else for (o = t.child, o !== null && (o.return = t); o !== null;) { var l = o.dependencies; if (l !== null) { s = o.child; for (var u = l.firstContext; u !== null;) { if (u.context === r) { if (o.tag === 1) { u = yt(-1, n & -n), u.tag = 2; var a = o.updateQueue; if (a !== null) { a = a.shared; var g = a.pending; g === null ? u.next = u : (u.next = g.next, g.next = u), a.pending = u } } o.lanes |= n, u = o.alternate, u !== null && (u.lanes |= n), Xs(o.return, n, t), l.lanes |= n; break } u = u.next } } else if (o.tag === 10) s = o.type === t.type ? null : o.child; else if (o.tag === 18) { if (s = o.return, s === null) throw Error(_(341)); s.lanes |= n, l = s.alternate, l !== null && (l.lanes |= n), Xs(s, n, t), s = o.sibling } else s = o.child; if (s !== null) s.return = o; else for (s = o; s !== null;) { if (s === t) { s = null; break } if (o = s.sibling, o !== null) { o.return = s.return, s = o; break } s = s.return } o = s } ve(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, bn(t, n), i = Qe(i), r = r(i), t.flags |= 1, ve(e, t, r, n), t.child; case 14: return r = t.type, i = Ze(r, t.pendingProps), i = Ze(r.type, i), va(e, t, r, i, n); case 15: return Xd(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Ze(r, i), Di(e, t), t.tag = 1, Oe(r) ? (e = !0, Vi(t)) : e = !1, bn(t, n), Od(t, r, i), Zs(t, r, i, n), nl(null, t, r, !0, e, n); case 19: return nf(e, t, n); case 22: return Jd(e, t, n) }throw Error(_(156, t.tag)) }; function Sf(e, t) { return Bc(e, t) } function Rg(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Be(e, t, n, r) { return new Rg(e, t, n, r) } function cu(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function Mg(e) { if (typeof e == "function") return cu(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === Pl) return 11; if (e === Nl) return 14 } return 2 } function Vt(e, t) { var n = e.alternate; return n === null ? (n = Be(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Ii(e, t, n, r, i, o) { var s = 2; if (r = e, typeof e == "function") cu(e) && (s = 1); else if (typeof e == "string") s = 5; else e: switch (e) { case Cn: return sn(n.children, i, o, t); case Dl: s = 8, i |= 8; break; case ks: return e = Be(12, n, t, i | 2), e.elementType = ks, e.lanes = o, e; case _s: return e = Be(13, n, t, i), e.elementType = _s, e.lanes = o, e; case xs: return e = Be(19, n, t, i), e.elementType = xs, e.lanes = o, e; case Tc: return yo(n, i, o, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case xc: s = 10; break e; case Oc: s = 9; break e; case Pl: s = 11; break e; case Nl: s = 14; break e; case Nt: s = 16, r = null; break e }throw Error(_(130, e == null ? e : typeof e, "")) }return t = Be(s, n, t, i), t.elementType = e, t.type = r, t.lanes = o, t } function sn(e, t, n, r) { return e = Be(7, e, r, t), e.lanes = n, e } function yo(e, t, n, r) { return e = Be(22, e, r, t), e.elementType = Tc, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function us(e, t, n) { return e = Be(6, e, null, t), e.lanes = n, e } function as(e, t, n) { return t = Be(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function Ag(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Wo(0), this.expirationTimes = Wo(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Wo(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function du(e, t, n, r, i, o, s, l, u) { return e = new Ag(e, t, n, l, u), t === 1 ? (t = 1, o === !0 && (t |= 8)) : t = 0, o = Be(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ql(o), e } function bg(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: En, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function wf(e) { if (!e) return qt; e = e._reactInternals; e: { if (gn(e) !== e || e.tag !== 1) throw Error(_(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Oe(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(_(171)) } if (e.tag === 1) { var n = e.type; if (Oe(n)) return yd(e, n, t) } return t } function Ef(e, t, n, r, i, o, s, l, u) { return e = du(n, r, !0, e, i, o, s, l, u), e.context = wf(null), n = e.current, r = ye(), i = Bt(n), o = yt(r, i), o.callback = t ?? null, Ht(n, o, i), e.current.lanes = i, Br(e, i, r), Te(e, r), e } function So(e, t, n, r) { var i = t.current, o = ye(), s = Bt(i); return n = wf(n), t.context === null ? t.context = n : t.pendingContext = n, t = yt(o, s), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = Ht(i, t, s), e !== null && (rt(e, i, s, o), xi(e, i, s)), s } function io(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function Pa(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function fu(e, t) { Pa(e, t), (e = e.alternate) && Pa(e, t) } function zg() { return null } var Cf = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function hu(e) { this._internalRoot = e } wo.prototype.render = hu.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(_(409)); So(e, t, null, null) }; wo.prototype.unmount = hu.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; fn(function () { So(null, e, null, null) }), t[wt] = null } }; function wo(e) { this._internalRoot = e } wo.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = Xc(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < jt.length && t !== 0 && t < jt[n].priority; n++); jt.splice(n, 0, e), n === 0 && Zc(e) } }; function pu(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function Eo(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function Na() { } function Fg(e, t, n, r, i) { if (i) { if (typeof r == "function") { var o = r; r = function () { var a = io(s); o.call(a) } } var s = Ef(t, r, e, 0, null, !1, !1, "", Na); return e._reactRootContainer = s, e[wt] = s.current, Ir(e.nodeType === 8 ? e.parentNode : e), fn(), s } for (; i = e.lastChild;)e.removeChild(i); if (typeof r == "function") { var l = r; r = function () { var a = io(u); l.call(a) } } var u = du(e, 0, !1, null, null, !1, !1, "", Na); return e._reactRootContainer = u, e[wt] = u.current, Ir(e.nodeType === 8 ? e.parentNode : e), fn(function () { So(t, u, n, r) }), u } function Co(e, t, n, r, i) { var o = n._reactRootContainer; if (o) { var s = o; if (typeof i == "function") { var l = i; i = function () { var u = io(s); l.call(u) } } So(t, s, e, i) } else s = Fg(n, t, e, i, r); return io(s) } Gc = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = ar(t.pendingLanes); n !== 0 && (jl(t, n | 1), Te(t, Z()), !(F & 6) && (Vn = Z() + 500, Xt())) } break; case 13: fn(function () { var r = Et(e, 1); if (r !== null) { var i = ye(); rt(r, e, 1, i) } }), fu(e, 1) } }; Rl = function (e) { if (e.tag === 13) { var t = Et(e, 134217728); if (t !== null) { var n = ye(); rt(t, e, 134217728, n) } fu(e, 134217728) } }; Yc = function (e) { if (e.tag === 13) { var t = Bt(e), n = Et(e, t); if (n !== null) { var r = ye(); rt(n, e, t, r) } fu(e, t) } }; Xc = function () { return U }; Jc = function (e, t) { var n = U; try { return U = e, t() } finally { U = n } }; Ms = function (e, t, n) { switch (t) { case "input": if (Ds(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = fo(r); if (!i) throw Error(_(90)); Pc(r), Ds(r, i) } } } break; case "textarea": Ic(e, n); break; case "select": t = n.value, t != null && jn(e, !!n.multiple, t, !1) } }; zc = lu; Fc = fn; var $g = { usingClientEntryPoint: !1, Events: [Qr, On, fo, Ac, bc, lu] }, rr = { findFiberByHostInstance: tn, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, Ug = { bundleType: rr.bundleType, version: rr.version, rendererPackageName: rr.rendererPackageName, rendererConfig: rr.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: kt.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Hc(e), e === null ? null : e.stateNode }, findFiberByHostInstance: rr.findFiberByHostInstance || zg, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var mi = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!mi.isDisabled && mi.supportsFiber) try { lo = mi.inject(Ug), at = mi } catch { } } Re.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = $g; Re.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!pu(t)) throw Error(_(200)); return bg(e, t, null, n) }; Re.createRoot = function (e, t) { if (!pu(e)) throw Error(_(299)); var n = !1, r = "", i = Cf; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = du(e, 1, !1, null, null, n, !1, r, i), e[wt] = t.current, Ir(e.nodeType === 8 ? e.parentNode : e), new hu(t) }; Re.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(_(188)) : (e = Object.keys(e).join(","), Error(_(268, e))); return e = Hc(t), e = e === null ? null : e.stateNode, e }; Re.flushSync = function (e) { return fn(e) }; Re.hydrate = function (e, t, n) { if (!Eo(t)) throw Error(_(200)); return Co(null, e, t, !0, n) }; Re.hydrateRoot = function (e, t, n) { if (!pu(e)) throw Error(_(405)); var r = n != null && n.hydratedSources || null, i = !1, o = "", s = Cf; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), t = Ef(t, null, e, 1, n ?? null, i, !1, o, s), e[wt] = t.current, Ir(e), r) for (e = 0; e < r.length; e++)n = r[e], i = n._getVersion, i = i(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new wo(t) }; Re.render = function (e, t, n) { if (!Eo(t)) throw Error(_(200)); return Co(null, e, t, !1, n) }; Re.unmountComponentAtNode = function (e) { if (!Eo(e)) throw Error(_(40)); return e._reactRootContainer ? (fn(function () { Co(null, null, e, !1, function () { e._reactRootContainer = null, e[wt] = null }) }), !0) : !1 }; Re.unstable_batchedUpdates = lu; Re.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Eo(n)) throw Error(_(200)); if (e == null || e._reactInternals === void 0) throw Error(_(38)); return Co(e, t, n, !1, r) }; Re.version = "18.2.0-next-9e3b772b8-20220608"; function kf() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(kf) } catch (e) { console.error(e) } } kf(), wc.exports = Re; var Hg = wc.exports, Ia = Hg; Es.createRoot = Ia.createRoot, Es.hydrateRoot = Ia.hydrateRoot;/**
 * @license
 * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */const pe = "w", $e = "b", oe = "p", pl = "n", Li = "b", dr = "r", Lt = "q", ne = "k", cs = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", Ce = -1, Wg = { NORMAL: "n", CAPTURE: "c", BIG_PAWN: "b", EP_CAPTURE: "e", PROMOTION: "p", KSIDE_CASTLE: "k", QSIDE_CASTLE: "q" }, I = { NORMAL: 1, CAPTURE: 2, BIG_PAWN: 4, EP_CAPTURE: 8, PROMOTION: 16, KSIDE_CASTLE: 32, QSIDE_CASTLE: 64 }, R = { a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7, a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23, a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39, a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55, a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71, a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87, a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103, a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119 }, ds = { b: [16, 32, 17, 15], w: [-16, -32, -17, -15] }, La = { n: [-18, -33, -31, -14, 18, 33, 31, 14], b: [-17, -15, 17, 15], r: [-16, 1, 16, -1], q: [-17, -16, -15, 1, 17, 16, 15, -1], k: [-17, -16, -15, 1, 17, 16, 15, -1] }, Bg = [20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0, 0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0, 0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0, 0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0, 20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20], Vg = [17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0, 0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0, 0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0, -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17], Qg = { p: 1, n: 2, b: 4, r: 8, q: 16, k: 32 }, Kg = "pnbrqkPNBRQK", ja = [pl, Li, dr, Lt], qg = 7, Gg = 6, Yg = 1, Xg = 0, vi = { [ne]: I.KSIDE_CASTLE, [Lt]: I.QSIDE_CASTLE }, Dt = { w: [{ square: R.a1, flag: I.QSIDE_CASTLE }, { square: R.h1, flag: I.KSIDE_CASTLE }], b: [{ square: R.a8, flag: I.QSIDE_CASTLE }, { square: R.h8, flag: I.KSIDE_CASTLE }] }, Jg = { b: Yg, w: Gg }, Zg = ["1-0", "0-1", "1/2-1/2", "*"]; function ln(e) { return e >> 4 } function $r(e) { return e & 15 } function _f(e) { return "0123456789".indexOf(e) !== -1 } function Pe(e) { const t = $r(e), n = ln(e); return "abcdefgh".substring(t, t + 1) + "87654321".substring(n, n + 1) } function ir(e) { return e === pe ? $e : pe } function e0(e) { const t = e.split(/\s+/); if (t.length !== 6) return { ok: !1, error: "Invalid FEN: must contain six space-delimited fields" }; const n = parseInt(t[5], 10); if (isNaN(n) || n <= 0) return { ok: !1, error: "Invalid FEN: move number must be a positive integer" }; const r = parseInt(t[4], 10); if (isNaN(r) || r < 0) return { ok: !1, error: "Invalid FEN: half move counter number must be a non-negative integer" }; if (!/^(-|[abcdefgh][36])$/.test(t[3])) return { ok: !1, error: "Invalid FEN: en-passant square is invalid" }; if (/[^kKqQ-]/.test(t[2])) return { ok: !1, error: "Invalid FEN: castling availability is invalid" }; if (!/^(w|b)$/.test(t[1])) return { ok: !1, error: "Invalid FEN: side-to-move is invalid" }; const i = t[0].split("/"); if (i.length !== 8) return { ok: !1, error: "Invalid FEN: piece data does not contain 8 '/'-delimited rows" }; for (let s = 0; s < i.length; s++) { let l = 0, u = !1; for (let a = 0; a < i[s].length; a++)if (_f(i[s][a])) { if (u) return { ok: !1, error: "Invalid FEN: piece data is invalid (consecutive number)" }; l += parseInt(i[s][a], 10), u = !0 } else { if (!/^[prnbqkPRNBQK]$/.test(i[s][a])) return { ok: !1, error: "Invalid FEN: piece data is invalid (invalid piece)" }; l += 1, u = !1 } if (l !== 8) return { ok: !1, error: "Invalid FEN: piece data is invalid (too many squares in rank)" } } if (t[3][1] == "3" && t[1] == "w" || t[3][1] == "6" && t[1] == "b") return { ok: !1, error: "Invalid FEN: illegal en-passant square" }; const o = [{ color: "white", regex: /K/g }, { color: "black", regex: /k/g }]; for (const { color: s, regex: l } of o) { if (!l.test(t[0])) return { ok: !1, error: `Invalid FEN: missing ${s} king` }; if ((t[0].match(l) || []).length > 1) return { ok: !1, error: `Invalid FEN: too many ${s} kings` } } return Array.from(i[0] + i[7]).some(s => s.toUpperCase() === "P") ? { ok: !1, error: "Invalid FEN: some pawns are on the edge rows" } : { ok: !0 } } function t0(e, t) { const n = e.from, r = e.to, i = e.piece; let o = 0, s = 0, l = 0; for (let u = 0, a = t.length; u < a; u++) { const g = t[u].from, p = t[u].to, f = t[u].piece; i === f && n !== g && r === p && (o++, ln(n) === ln(g) && s++, $r(n) === $r(g) && l++) } return o > 0 ? s > 0 && l > 0 ? Pe(n) : l > 0 ? Pe(n).charAt(1) : Pe(n).charAt(0) : "" } function Pt(e, t, n, r, i, o = void 0, s = I.NORMAL) { const l = ln(r); if (i === oe && (l === qg || l === Xg)) for (let u = 0; u < ja.length; u++) { const a = ja[u]; e.push({ color: t, from: n, to: r, piece: i, captured: o, promotion: a, flags: s | I.PROMOTION }) } else e.push({ color: t, from: n, to: r, piece: i, captured: o, flags: s }) } function Ra(e) { let t = e.charAt(0); return t >= "a" && t <= "h" ? e.match(/[a-h]\d.*[a-h]\d/) ? void 0 : oe : (t = t.toLowerCase(), t === "o" ? ne : t) } function fs(e) { return e.replace(/=/, "").replace(/[+#]?[?!]*$/, "") } function Ma(e) { return e.split(" ").slice(0, 4).join(" ") } class n0 {
    constructor(t = cs) { ze(this, "_board", new Array(128)); ze(this, "_turn", pe); ze(this, "_header", {}); ze(this, "_kings", { w: Ce, b: Ce }); ze(this, "_epSquare", -1); ze(this, "_halfMoves", 0); ze(this, "_moveNumber", 0); ze(this, "_history", []); ze(this, "_comments", {}); ze(this, "_castling", { w: 0, b: 0 }); ze(this, "_positionCounts", {}); this.load(t) } clear({ preserveHeaders: t = !1 } = {}) { this._board = new Array(128), this._kings = { w: Ce, b: Ce }, this._turn = pe, this._castling = { w: 0, b: 0 }, this._epSquare = Ce, this._halfMoves = 0, this._moveNumber = 1, this._history = [], this._comments = {}, this._header = t ? this._header : {}, delete this._header.SetUp, delete this._header.FEN, this._positionCounts = new Proxy({}, { get: (n, r) => r === "length" ? Object.keys(n).length : (n == null ? void 0 : n[Ma(r)]) || 0, set: (n, r, i) => { const o = Ma(r); return i === 0 ? delete n[o] : n[o] = i, !0 } }) } removeHeader(t) { t in this._header && delete this._header[t] } load(t, { skipValidation: n = !1, preserveHeaders: r = !1 } = {}) { let i = t.split(/\s+/); if (i.length >= 2 && i.length < 6) { const l = ["-", "-", "0", "1"]; t = i.concat(l.slice(-(6 - i.length))).join(" ") } if (i = t.split(/\s+/), !n) { const { ok: l, error: u } = e0(t); if (!l) throw new Error(u) } const o = i[0]; let s = 0; this.clear({ preserveHeaders: r }); for (let l = 0; l < o.length; l++) { const u = o.charAt(l); if (u === "/") s += 8; else if (_f(u)) s += parseInt(u, 10); else { const a = u < "a" ? pe : $e; this._put({ type: u.toLowerCase(), color: a }, Pe(s)), s++ } } this._turn = i[1], i[2].indexOf("K") > -1 && (this._castling.w |= I.KSIDE_CASTLE), i[2].indexOf("Q") > -1 && (this._castling.w |= I.QSIDE_CASTLE), i[2].indexOf("k") > -1 && (this._castling.b |= I.KSIDE_CASTLE), i[2].indexOf("q") > -1 && (this._castling.b |= I.QSIDE_CASTLE), this._epSquare = i[3] === "-" ? Ce : R[i[3]], this._halfMoves = parseInt(i[4], 10), this._moveNumber = parseInt(i[5], 10), this._updateSetup(t), this._positionCounts[t]++ } fen() { var o, s; let t = 0, n = ""; for (let l = R.a8; l <= R.h1; l++) { if (this._board[l]) { t > 0 && (n += t, t = 0); const { color: u, type: a } = this._board[l]; n += u === pe ? a.toUpperCase() : a.toLowerCase() } else t++; l + 1 & 136 && (t > 0 && (n += t), l !== R.h1 && (n += "/"), t = 0, l += 8) } let r = ""; this._castling[pe] & I.KSIDE_CASTLE && (r += "K"), this._castling[pe] & I.QSIDE_CASTLE && (r += "Q"), this._castling[$e] & I.KSIDE_CASTLE && (r += "k"), this._castling[$e] & I.QSIDE_CASTLE && (r += "q"), r = r || "-"; let i = "-"; if (this._epSquare !== Ce) { const l = this._epSquare + (this._turn === pe ? 16 : -16), u = [l + 1, l - 1]; for (const a of u) { if (a & 136) continue; const g = this._turn; if (((o = this._board[a]) == null ? void 0 : o.color) === g && ((s = this._board[a]) == null ? void 0 : s.type) === oe) { this._makeMove({ color: g, from: a, to: this._epSquare, piece: oe, captured: oe, flags: I.EP_CAPTURE }); const p = !this._isKingAttacked(g); if (this._undoMove(), p) { i = Pe(this._epSquare); break } } } } return [n, this._turn, r, i, this._halfMoves, this._moveNumber].join(" ") } _updateSetup(t) { this._history.length > 0 || (t !== cs ? (this._header.SetUp = "1", this._header.FEN = t) : (delete this._header.SetUp, delete this._header.FEN)) } reset() { this.load(cs) } get(t) { return this._board[R[t]] || !1 } put({ type: t, color: n }, r) { return this._put({ type: t, color: n }, r) ? (this._updateCastlingRights(), this._updateEnPassantSquare(), this._updateSetup(this.fen()), !0) : !1 } _put({ type: t, color: n }, r) { if (Kg.indexOf(t.toLowerCase()) === -1 || !(r in R)) return !1; const i = R[r]; if (t == ne && !(this._kings[n] == Ce || this._kings[n] == i)) return !1; const o = this._board[i]; return o && o.type === ne && (this._kings[o.color] = Ce), this._board[i] = { type: t, color: n }, t === ne && (this._kings[n] = i), !0 } remove(t) { const n = this.get(t); return delete this._board[R[t]], n && n.type === ne && (this._kings[n.color] = Ce), this._updateCastlingRights(), this._updateEnPassantSquare(), this._updateSetup(this.fen()), n } _updateCastlingRights() { var r, i, o, s, l, u, a, g, p, f, y, m; const t = ((r = this._board[R.e1]) == null ? void 0 : r.type) === ne && ((i = this._board[R.e1]) == null ? void 0 : i.color) === pe, n = ((o = this._board[R.e8]) == null ? void 0 : o.type) === ne && ((s = this._board[R.e8]) == null ? void 0 : s.color) === $e; (!t || ((l = this._board[R.a1]) == null ? void 0 : l.type) !== dr || ((u = this._board[R.a1]) == null ? void 0 : u.color) !== pe) && (this._castling.w &= ~I.QSIDE_CASTLE), (!t || ((a = this._board[R.h1]) == null ? void 0 : a.type) !== dr || ((g = this._board[R.h1]) == null ? void 0 : g.color) !== pe) && (this._castling.w &= ~I.KSIDE_CASTLE), (!n || ((p = this._board[R.a8]) == null ? void 0 : p.type) !== dr || ((f = this._board[R.a8]) == null ? void 0 : f.color) !== $e) && (this._castling.b &= ~I.QSIDE_CASTLE), (!n || ((y = this._board[R.h8]) == null ? void 0 : y.type) !== dr || ((m = this._board[R.h8]) == null ? void 0 : m.color) !== $e) && (this._castling.b &= ~I.KSIDE_CASTLE) } _updateEnPassantSquare() { var o, s; if (this._epSquare === Ce) return; const t = this._epSquare + (this._turn === pe ? -16 : 16), n = this._epSquare + (this._turn === pe ? 16 : -16), r = [n + 1, n - 1]; if (this._board[t] !== null || this._board[this._epSquare] !== null || ((o = this._board[n]) == null ? void 0 : o.color) !== ir(this._turn) || ((s = this._board[n]) == null ? void 0 : s.type) !== oe) { this._epSquare = Ce; return } const i = l => { var u, a; return !(l & 136) && ((u = this._board[l]) == null ? void 0 : u.color) === this._turn && ((a = this._board[l]) == null ? void 0 : a.type) === oe }; r.some(i) || (this._epSquare = Ce) } _attacked(t, n) { for (let r = R.a8; r <= R.h1; r++) { if (r & 136) { r += 7; continue } if (this._board[r] === void 0 || this._board[r].color !== t) continue; const i = this._board[r], o = r - n; if (o === 0) continue; const s = o + 119; if (Bg[s] & Qg[i.type]) { if (i.type === oe) { if (o > 0) { if (i.color === pe) return !0 } else if (i.color === $e) return !0; continue } if (i.type === "n" || i.type === "k") return !0; const l = Vg[s]; let u = r + l, a = !1; for (; u !== n;) { if (this._board[u] != null) { a = !0; break } u += l } if (!a) return !0 } } return !1 } _isKingAttacked(t) { const n = this._kings[t]; return n === -1 ? !1 : this._attacked(ir(t), n) } isAttacked(t, n) { return this._attacked(n, R[t]) } isCheck() { return this._isKingAttacked(this._turn) } inCheck() { return this.isCheck() } isCheckmate() { return this.isCheck() && this._moves().length === 0 } isStalemate() { return !this.isCheck() && this._moves().length === 0 } isInsufficientMaterial() { const t = { b: 0, n: 0, r: 0, q: 0, k: 0, p: 0 }, n = []; let r = 0, i = 0; for (let o = R.a8; o <= R.h1; o++) { if (i = (i + 1) % 2, o & 136) { o += 7; continue } const s = this._board[o]; s && (t[s.type] = s.type in t ? t[s.type] + 1 : 1, s.type === Li && n.push(i), r++) } if (r === 2) return !0; if (r === 3 && (t[Li] === 1 || t[pl] === 1)) return !0; if (r === t[Li] + 2) { let o = 0; const s = n.length; for (let l = 0; l < s; l++)o += n[l]; if (o === 0 || o === s) return !0 } return !1 } _getRepetitionCount() { return this._positionCounts[this.fen()] } isThreefoldRepetition() { return this._getRepetitionCount() >= 3 } isDraw() { return this._halfMoves >= 100 || this.isStalemate() || this.isInsufficientMaterial() || this.isThreefoldRepetition() } isGameOver() { return this.isCheckmate() || this.isStalemate() || this.isDraw() } moves({ verbose: t = !1, square: n = void 0, piece: r = void 0 } = {}) { const i = this._moves({ square: n, piece: r }); return t ? i.map(o => this._makePretty(o)) : i.map(o => this._moveToSan(o, i)) } _moves({ legal: t = !0, piece: n = void 0, square: r = void 0 } = {}) { var y; const i = r ? r.toLowerCase() : void 0, o = n == null ? void 0 : n.toLowerCase(), s = [], l = this._turn, u = ir(l); let a = R.a8, g = R.h1, p = !1; if (i) if (i in R) a = g = R[i], p = !0; else return []; for (let m = a; m <= g; m++) { if (m & 136) { m += 7; continue } if (!this._board[m] || this._board[m].color === u) continue; const { type: v } = this._board[m]; let E; if (v === oe) { if (o && o !== v) continue; E = m + ds[l][0], this._board[E] || (Pt(s, l, m, E, oe), E = m + ds[l][1], Jg[l] === ln(m) && !this._board[E] && Pt(s, l, m, E, oe, void 0, I.BIG_PAWN)); for (let d = 2; d < 4; d++)E = m + ds[l][d], !(E & 136) && (((y = this._board[E]) == null ? void 0 : y.color) === u ? Pt(s, l, m, E, oe, this._board[E].type, I.CAPTURE) : E === this._epSquare && Pt(s, l, m, E, oe, oe, I.EP_CAPTURE)) } else { if (o && o !== v) continue; for (let d = 0, c = La[v].length; d < c; d++) { const h = La[v][d]; for (E = m; E += h, !(E & 136);) { if (!this._board[E]) Pt(s, l, m, E, v); else { if (this._board[E].color === l) break; Pt(s, l, m, E, v, this._board[E].type, I.CAPTURE); break } if (v === pl || v === ne) break } } } } if ((o === void 0 || o === ne) && (!p || g === this._kings[l])) { if (this._castling[l] & I.KSIDE_CASTLE) { const m = this._kings[l], v = m + 2; !this._board[m + 1] && !this._board[v] && !this._attacked(u, this._kings[l]) && !this._attacked(u, m + 1) && !this._attacked(u, v) && Pt(s, l, this._kings[l], v, ne, void 0, I.KSIDE_CASTLE) } if (this._castling[l] & I.QSIDE_CASTLE) { const m = this._kings[l], v = m - 2; !this._board[m - 1] && !this._board[m - 2] && !this._board[m - 3] && !this._attacked(u, this._kings[l]) && !this._attacked(u, m - 1) && !this._attacked(u, v) && Pt(s, l, this._kings[l], v, ne, void 0, I.QSIDE_CASTLE) } } if (!t || this._kings[l] === -1) return s; const f = []; for (let m = 0, v = s.length; m < v; m++)this._makeMove(s[m]), this._isKingAttacked(l) || f.push(s[m]), this._undoMove(); return f } move(t, { strict: n = !1 } = {}) { let r = null; if (typeof t == "string") r = this._moveFromSan(t, n); else if (typeof t == "object") { const o = this._moves(); for (let s = 0, l = o.length; s < l; s++)if (t.from === Pe(o[s].from) && t.to === Pe(o[s].to) && (!("promotion" in o[s]) || t.promotion === o[s].promotion)) { r = o[s]; break } } if (!r) throw typeof t == "string" ? new Error(`Invalid move: ${t}`) : new Error(`Invalid move: ${JSON.stringify(t)}`); const i = this._makePretty(r); return this._makeMove(r), this._positionCounts[i.after]++, i } _push(t) { this._history.push({ move: t, kings: { b: this._kings.b, w: this._kings.w }, turn: this._turn, castling: { b: this._castling.b, w: this._castling.w }, epSquare: this._epSquare, halfMoves: this._halfMoves, moveNumber: this._moveNumber }) } _makeMove(t) { const n = this._turn, r = ir(n); if (this._push(t), this._board[t.to] = this._board[t.from], delete this._board[t.from], t.flags & I.EP_CAPTURE && (this._turn === $e ? delete this._board[t.to - 16] : delete this._board[t.to + 16]), t.promotion && (this._board[t.to] = { type: t.promotion, color: n }), this._board[t.to].type === ne) { if (this._kings[n] = t.to, t.flags & I.KSIDE_CASTLE) { const i = t.to - 1, o = t.to + 1; this._board[i] = this._board[o], delete this._board[o] } else if (t.flags & I.QSIDE_CASTLE) { const i = t.to + 1, o = t.to - 2; this._board[i] = this._board[o], delete this._board[o] } this._castling[n] = 0 } if (this._castling[n]) { for (let i = 0, o = Dt[n].length; i < o; i++)if (t.from === Dt[n][i].square && this._castling[n] & Dt[n][i].flag) { this._castling[n] ^= Dt[n][i].flag; break } } if (this._castling[r]) { for (let i = 0, o = Dt[r].length; i < o; i++)if (t.to === Dt[r][i].square && this._castling[r] & Dt[r][i].flag) { this._castling[r] ^= Dt[r][i].flag; break } } t.flags & I.BIG_PAWN ? n === $e ? this._epSquare = t.to - 16 : this._epSquare = t.to + 16 : this._epSquare = Ce, t.piece === oe ? this._halfMoves = 0 : t.flags & (I.CAPTURE | I.EP_CAPTURE) ? this._halfMoves = 0 : this._halfMoves++, n === $e && this._moveNumber++, this._turn = r } undo() { const t = this._undoMove(); if (t) { const n = this._makePretty(t); return this._positionCounts[n.after]--, n } return null } _undoMove() { const t = this._history.pop(); if (t === void 0) return null; const n = t.move; this._kings = t.kings, this._turn = t.turn, this._castling = t.castling, this._epSquare = t.epSquare, this._halfMoves = t.halfMoves, this._moveNumber = t.moveNumber; const r = this._turn, i = ir(r); if (this._board[n.from] = this._board[n.to], this._board[n.from].type = n.piece, delete this._board[n.to], n.captured) if (n.flags & I.EP_CAPTURE) { let o; r === $e ? o = n.to - 16 : o = n.to + 16, this._board[o] = { type: oe, color: i } } else this._board[n.to] = { type: n.captured, color: i }; if (n.flags & (I.KSIDE_CASTLE | I.QSIDE_CASTLE)) { let o, s; n.flags & I.KSIDE_CASTLE ? (o = n.to + 1, s = n.to - 1) : (o = n.to - 2, s = n.to + 1), this._board[o] = this._board[s], delete this._board[s] } return n } pgn({ newline: t = `
`, maxWidth: n = 0 } = {}) { const r = []; let i = !1; for (const f in this._header) r.push("[" + f + ' "' + this._header[f] + '"]' + t), i = !0; i && this._history.length && r.push(t); const o = f => { const y = this._comments[this.fen()]; if (typeof y < "u") { const m = f.length > 0 ? " " : ""; f = `${f}${m}{${y}}` } return f }, s = []; for (; this._history.length > 0;)s.push(this._undoMove()); const l = []; let u = ""; for (s.length === 0 && l.push(o("")); s.length > 0;) { u = o(u); const f = s.pop(); if (!f) break; if (!this._history.length && f.color === "b") { const y = `${this._moveNumber}. ...`; u = u ? `${u} ${y}` : y } else f.color === "w" && (u.length && l.push(u), u = this._moveNumber + "."); u = u + " " + this._moveToSan(f, this._moves({ legal: !0 })), this._makeMove(f) } if (u.length && l.push(o(u)), typeof this._header.Result < "u" && l.push(this._header.Result), n === 0) return r.join("") + l.join(" "); const a = function () { return r.length > 0 && r[r.length - 1] === " " ? (r.pop(), !0) : !1 }, g = function (f, y) { for (const m of y.split(" ")) if (m) { if (f + m.length > n) { for (; a();)f--; r.push(t), f = 0 } r.push(m), f += m.length, r.push(" "), f++ } return a() && f--, f }; let p = 0; for (let f = 0; f < l.length; f++) { if (p + l[f].length > n && l[f].includes("{")) { p = g(p, l[f]); continue } p + l[f].length > n && f !== 0 ? (r[r.length - 1] === " " && r.pop(), r.push(t), p = 0) : f !== 0 && (r.push(" "), p++), r.push(l[f]), p += l[f].length } return r.join("") } header(...t) { for (let n = 0; n < t.length; n += 2)typeof t[n] == "string" && typeof t[n + 1] == "string" && (this._header[t[n]] = t[n + 1]); return this._header } loadPgn(t, { strict: n = !1, newlineChar: r = `\r?
`} = {}) { function i(h) { return h.replace(/\\/g, "\\") } function o(h) { const w = {}, k = h.split(new RegExp(i(r))); let O = "", x = ""; for (let T = 0; T < k.length; T++) { const z = /^\s*\[\s*([A-Za-z]+)\s*"(.*)"\s*\]\s*$/; O = k[T].replace(z, "$1"), x = k[T].replace(z, "$2"), O.trim().length > 0 && (w[O] = x) } return w } t = t.trim(); const l = new RegExp("^(\\[((?:" + i(r) + ")|.)*\\])((?:\\s*" + i(r) + "){2}|(?:\\s*" + i(r) + ")*$)").exec(t), u = l && l.length >= 2 ? l[1] : ""; this.reset(); const a = o(u); let g = ""; for (const h in a) h.toLowerCase() === "fen" && (g = a[h]), this.header(h, a[h]); if (!n) g && this.load(g, { preserveHeaders: !0 }); else if (a.SetUp === "1") { if (!("FEN" in a)) throw new Error("Invalid PGN: FEN tag must be supplied with SetUp tag"); this.load(a.FEN, { preserveHeaders: !0 }) } function p(h) { return Array.from(h).map(function (w) { return w.charCodeAt(0) < 128 ? w.charCodeAt(0).toString(16) : encodeURIComponent(w).replace(/%/g, "").toLowerCase() }).join("") } function f(h) { return h.length == 0 ? "" : decodeURIComponent("%" + (h.match(/.{1,2}/g) || []).join("%")) } const y = function (h) { return h = h.replace(new RegExp(i(r), "g"), " "), `{${p(h.slice(1, h.length - 1))}}` }, m = function (h) { if (h.startsWith("{") && h.endsWith("}")) return f(h.slice(1, h.length - 1)) }; let v = t.replace(u, "").replace(new RegExp(`({[^}]*})+?|;([^${i(r)}]*)`, "g"), function (h, w, k) { return w !== void 0 ? y(w) : " " + y(`{${k.slice(1)}}`) }).replace(new RegExp(i(r), "g"), " "); const E = /(\([^()]+\))+?/g; for (; E.test(v);)v = v.replace(E, ""); v = v.replace(/\d+\.(\.\.)?/g, ""), v = v.replace(/\.\.\./g, ""), v = v.replace(/\$\d+/g, ""); let d = v.trim().split(new RegExp(/\s+/)); d = d.filter(h => h !== ""); let c = ""; for (let h = 0; h < d.length; h++) { const w = m(d[h]); if (w !== void 0) { this._comments[this.fen()] = w; continue } const k = this._moveFromSan(d[h], n); if (k == null) if (Zg.indexOf(d[h]) > -1) c = d[h]; else throw new Error(`Invalid move in PGN: ${d[h]}`); else c = "", this._makeMove(k), this._positionCounts[this.fen()]++ } c && Object.keys(this._header).length && !this._header.Result && this.header("Result", c) } _moveToSan(t, n) { let r = ""; if (t.flags & I.KSIDE_CASTLE) r = "O-O"; else if (t.flags & I.QSIDE_CASTLE) r = "O-O-O"; else { if (t.piece !== oe) { const i = t0(t, n); r += t.piece.toUpperCase() + i } t.flags & (I.CAPTURE | I.EP_CAPTURE) && (t.piece === oe && (r += Pe(t.from)[0]), r += "x"), r += Pe(t.to), t.promotion && (r += "=" + t.promotion.toUpperCase()) } return this._makeMove(t), this.isCheck() && (this.isCheckmate() ? r += "#" : r += "+"), this._undoMove(), r } _moveFromSan(t, n = !1) { const r = fs(t); let i = Ra(r), o = this._moves({ legal: !0, piece: i }); for (let f = 0, y = o.length; f < y; f++)if (r === fs(this._moveToSan(o[f], o))) return o[f]; if (n) return null; let s, l, u, a, g, p = !1; if (l = r.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/), l ? (s = l[1], u = l[2], a = l[3], g = l[4], u.length == 1 && (p = !0)) : (l = r.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/), l && (s = l[1], u = l[2], a = l[3], g = l[4], u.length == 1 && (p = !0))), i = Ra(r), o = this._moves({ legal: !0, piece: s || i }), !a) return null; for (let f = 0, y = o.length; f < y; f++)if (u) { if ((!s || s.toLowerCase() == o[f].piece) && R[u] == o[f].from && R[a] == o[f].to && (!g || g.toLowerCase() == o[f].promotion)) return o[f]; if (p) { const m = Pe(o[f].from); if ((!s || s.toLowerCase() == o[f].piece) && R[a] == o[f].to && (u == m[0] || u == m[1]) && (!g || g.toLowerCase() == o[f].promotion)) return o[f] } } else if (r === fs(this._moveToSan(o[f], o)).replace("x", "")) return o[f]; return null } ascii() {
        let t = `   +------------------------+
`; for (let n = R.a8; n <= R.h1; n++) {
            if ($r(n) === 0 && (t += " " + "87654321"[ln(n)] + " |"), this._board[n]) { const r = this._board[n].type, o = this._board[n].color === pe ? r.toUpperCase() : r.toLowerCase(); t += " " + o + " " } else t += " . "; n + 1 & 136 && (t += `|
`, n += 8)
        } return t += `   +------------------------+
`, t += "     a  b  c  d  e  f  g  h", t
    } perft(t) { const n = this._moves({ legal: !1 }); let r = 0; const i = this._turn; for (let o = 0, s = n.length; o < s; o++)this._makeMove(n[o]), this._isKingAttacked(i) || (t - 1 > 0 ? r += this.perft(t - 1) : r++), this._undoMove(); return r } _makePretty(t) { const { color: n, piece: r, from: i, to: o, flags: s, captured: l, promotion: u } = t; let a = ""; for (const y in I) I[y] & s && (a += Wg[y]); const g = Pe(i), p = Pe(o), f = { color: n, piece: r, from: g, to: p, san: this._moveToSan(t, this._moves({ legal: !0 })), flags: a, lan: g + p, before: this.fen(), after: "" }; return this._makeMove(t), f.after = this.fen(), this._undoMove(), l && (f.captured = l), u && (f.promotion = u, f.lan += u), f } turn() { return this._turn } board() { const t = []; let n = []; for (let r = R.a8; r <= R.h1; r++)this._board[r] == null ? n.push(null) : n.push({ square: Pe(r), type: this._board[r].type, color: this._board[r].color }), r + 1 & 136 && (t.push(n), n = [], r += 8); return t } squareColor(t) { if (t in R) { const n = R[t]; return (ln(n) + $r(n)) % 2 === 0 ? "light" : "dark" } return null } history({ verbose: t = !1 } = {}) { const n = [], r = []; for (; this._history.length > 0;)n.push(this._undoMove()); for (; ;) { const i = n.pop(); if (!i) break; t ? r.push(this._makePretty(i)) : r.push(this._moveToSan(i, this._moves())), this._makeMove(i) } return r } _pruneComments() { const t = [], n = {}, r = i => { i in this._comments && (n[i] = this._comments[i]) }; for (; this._history.length > 0;)t.push(this._undoMove()); for (r(this.fen()); ;) { const i = t.pop(); if (!i) break; this._makeMove(i), r(this.fen()) } this._comments = n } getComment() { return this._comments[this.fen()] } setComment(t) { this._comments[this.fen()] = t.replace("{", "[").replace("}", "]") } deleteComment() { const t = this._comments[this.fen()]; return delete this._comments[this.fen()], t } getComments() { return this._pruneComments(), Object.keys(this._comments).map(t => ({ fen: t, comment: this._comments[t] })) } deleteComments() { return this._pruneComments(), Object.keys(this._comments).map(t => { const n = this._comments[t]; return delete this._comments[t], { fen: t, comment: n } }) } setCastlingRights(t, n) { for (const i of [ne, Lt]) n[i] !== void 0 && (n[i] ? this._castling[t] |= vi[i] : this._castling[t] &= ~vi[i]); this._updateCastlingRights(); const r = this.getCastlingRights(t); return (n[ne] === void 0 || n[ne] === r[ne]) && (n[Lt] === void 0 || n[Lt] === r[Lt]) } getCastlingRights(t) { return { [ne]: (this._castling[t] & vi[ne]) !== 0, [Lt]: (this._castling[t] & vi[Lt]) !== 0 } } moveNumber() { return this._moveNumber }
} function r0(e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]); return n } const xf = C.createContext({ dragDropManager: void 0 }); function Fe(e) { return "Minified Redux error #" + e + "; visit https://redux.js.org/Errors?code=" + e + " for the full message or use the non-minified dev environment for full errors. " } var Aa = function () { return typeof Symbol == "function" && Symbol.observable || "@@observable" }(), hs = function () { return Math.random().toString(36).substring(7).split("").join(".") }, ba = { INIT: "@@redux/INIT" + hs(), REPLACE: "@@redux/REPLACE" + hs(), PROBE_UNKNOWN_ACTION: function () { return "@@redux/PROBE_UNKNOWN_ACTION" + hs() } }; function i0(e) { if (typeof e != "object" || e === null) return !1; for (var t = e; Object.getPrototypeOf(t) !== null;)t = Object.getPrototypeOf(t); return Object.getPrototypeOf(e) === t } function Of(e, t, n) { var r; if (typeof t == "function" && typeof n == "function" || typeof n == "function" && typeof arguments[3] == "function") throw new Error(Fe(0)); if (typeof t == "function" && typeof n > "u" && (n = t, t = void 0), typeof n < "u") { if (typeof n != "function") throw new Error(Fe(1)); return n(Of)(e, t) } if (typeof e != "function") throw new Error(Fe(2)); var i = e, o = t, s = [], l = s, u = !1; function a() { l === s && (l = s.slice()) } function g() { if (u) throw new Error(Fe(3)); return o } function p(v) { if (typeof v != "function") throw new Error(Fe(4)); if (u) throw new Error(Fe(5)); var E = !0; return a(), l.push(v), function () { if (E) { if (u) throw new Error(Fe(6)); E = !1, a(); var c = l.indexOf(v); l.splice(c, 1), s = null } } } function f(v) { if (!i0(v)) throw new Error(Fe(7)); if (typeof v.type > "u") throw new Error(Fe(8)); if (u) throw new Error(Fe(9)); try { u = !0, o = i(o, v) } finally { u = !1 } for (var E = s = l, d = 0; d < E.length; d++) { var c = E[d]; c() } return v } function y(v) { if (typeof v != "function") throw new Error(Fe(10)); i = v, f({ type: ba.REPLACE }) } function m() { var v, E = p; return v = { subscribe: function (c) { if (typeof c != "object" || c === null) throw new Error(Fe(11)); function h() { c.next && c.next(g()) } h(); var w = E(h); return { unsubscribe: w } } }, v[Aa] = function () { return this }, v } return f({ type: ba.INIT }), r = { dispatch: f, subscribe: p, getState: g, replaceReducer: y }, r[Aa] = m, r } function L(e, t, ...n) { if (o0() && t === void 0) throw new Error("invariant requires an error message argument"); if (!e) { let r; if (t === void 0) r = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { let i = 0; r = new Error(t.replace(/%s/g, function () { return n[i++] })), r.name = "Invariant Violation" } throw r.framesToPop = 1, r } } function o0() { return typeof process < "u" && process.env.NODE_ENV === "production" } function s0(e, t, n) { return t.split(".").reduce((r, i) => r && r[i] ? r[i] : n || null, e) } function l0(e, t) { return e.filter(n => n !== t) } function Tf(e) { return typeof e == "object" } function u0(e, t) { const n = new Map, r = o => { n.set(o, n.has(o) ? n.get(o) + 1 : 1) }; e.forEach(r), t.forEach(r); const i = []; return n.forEach((o, s) => { o === 1 && i.push(s) }), i } function a0(e, t) { return e.filter(n => t.indexOf(n) > -1) } const gu = "dnd-core/INIT_COORDS", ko = "dnd-core/BEGIN_DRAG", mu = "dnd-core/PUBLISH_DRAG_SOURCE", _o = "dnd-core/HOVER", xo = "dnd-core/DROP", Oo = "dnd-core/END_DRAG"; function za(e, t) { return { type: gu, payload: { sourceClientOffset: t || null, clientOffset: e || null } } } const c0 = { type: gu, payload: { clientOffset: null, sourceClientOffset: null } }; function d0(e) { return function (n = [], r = { publishSource: !0 }) { const { publishSource: i = !0, clientOffset: o, getSourceClientOffset: s } = r, l = e.getMonitor(), u = e.getRegistry(); e.dispatch(za(o)), f0(n, l, u); const a = g0(n, l); if (a == null) { e.dispatch(c0); return } let g = null; if (o) { if (!s) throw new Error("getSourceClientOffset must be defined"); h0(s), g = s(a) } e.dispatch(za(o, g)); const f = u.getSource(a).beginDrag(l, a); if (f == null) return; p0(f), u.pinSource(a); const y = u.getSourceType(a); return { type: ko, payload: { itemType: y, item: f, sourceId: a, clientOffset: o || null, sourceClientOffset: g || null, isSourcePublic: !!i } } } } function f0(e, t, n) { L(!t.isDragging(), "Cannot call beginDrag while dragging."), e.forEach(function (r) { L(n.getSource(r), "Expected sourceIds to be registered.") }) } function h0(e) { L(typeof e == "function", "When clientOffset is provided, getSourceClientOffset must be a function.") } function p0(e) { L(Tf(e), "Item must be an object.") } function g0(e, t) { let n = null; for (let r = e.length - 1; r >= 0; r--)if (t.canDragSource(e[r])) { n = e[r]; break } return n } function m0(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function v0(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}, r = Object.keys(n); typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function (i) { return Object.getOwnPropertyDescriptor(n, i).enumerable }))), r.forEach(function (i) { m0(e, i, n[i]) }) } return e } function y0(e) { return function (n = {}) { const r = e.getMonitor(), i = e.getRegistry(); S0(r), C0(r).forEach((s, l) => { const u = w0(s, l, i, r), a = { type: xo, payload: { dropResult: v0({}, n, u) } }; e.dispatch(a) }) } } function S0(e) { L(e.isDragging(), "Cannot call drop while not dragging."), L(!e.didDrop(), "Cannot call drop twice during one drag operation.") } function w0(e, t, n, r) { const i = n.getTarget(e); let o = i ? i.drop(r, e) : void 0; return E0(o), typeof o > "u" && (o = t === 0 ? {} : r.getDropResult()), o } function E0(e) { L(typeof e > "u" || Tf(e), "Drop result must either be an object or undefined.") } function C0(e) { const t = e.getTargetIds().filter(e.canDropOnTarget, e); return t.reverse(), t } function k0(e) { return function () { const n = e.getMonitor(), r = e.getRegistry(); _0(n); const i = n.getSourceId(); return i != null && (r.getSource(i, !0).endDrag(n, i), r.unpinSource()), { type: Oo } } } function _0(e) { L(e.isDragging(), "Cannot call endDrag while not dragging.") } function gl(e, t) { return t === null ? e === null : Array.isArray(e) ? e.some(n => n === t) : e === t } function x0(e) { return function (n, { clientOffset: r } = {}) { O0(n); const i = n.slice(0), o = e.getMonitor(), s = e.getRegistry(), l = o.getItemType(); return D0(i, s, l), T0(i, o, s), P0(i, o, s), { type: _o, payload: { targetIds: i, clientOffset: r || null } } } } function O0(e) { L(Array.isArray(e), "Expected targetIds to be an array.") } function T0(e, t, n) { L(t.isDragging(), "Cannot call hover while not dragging."), L(!t.didDrop(), "Cannot call hover after drop."); for (let r = 0; r < e.length; r++) { const i = e[r]; L(e.lastIndexOf(i) === r, "Expected targetIds to be unique in the passed array."); const o = n.getTarget(i); L(o, "Expected targetIds to be registered.") } } function D0(e, t, n) { for (let r = e.length - 1; r >= 0; r--) { const i = e[r], o = t.getTargetType(i); gl(o, n) || e.splice(r, 1) } } function P0(e, t, n) { e.forEach(function (r) { n.getTarget(r).hover(t, r) }) } function N0(e) { return function () { if (e.getMonitor().isDragging()) return { type: mu } } } function I0(e) { return { beginDrag: d0(e), publishDragSource: N0(e), hover: x0(e), drop: y0(e), endDrag: k0(e) } } class L0 { receiveBackend(t) { this.backend = t } getMonitor() { return this.monitor } getBackend() { return this.backend } getRegistry() { return this.monitor.registry } getActions() { const t = this, { dispatch: n } = this.store; function r(o) { return (...s) => { const l = o.apply(t, s); typeof l < "u" && n(l) } } const i = I0(this); return Object.keys(i).reduce((o, s) => { const l = i[s]; return o[s] = r(l), o }, {}) } dispatch(t) { this.store.dispatch(t) } constructor(t, n) { this.isSetUp = !1, this.handleRefCountChange = () => { const r = this.store.getState().refCount > 0; this.backend && (r && !this.isSetUp ? (this.backend.setup(), this.isSetUp = !0) : !r && this.isSetUp && (this.backend.teardown(), this.isSetUp = !1)) }, this.store = t, this.monitor = n, t.subscribe(this.handleRefCountChange) } } function j0(e, t) { return { x: e.x + t.x, y: e.y + t.y } } function Df(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function R0(e) { const { clientOffset: t, initialClientOffset: n, initialSourceClientOffset: r } = e; return !t || !n || !r ? null : Df(j0(t, r), n) } function M0(e) { const { clientOffset: t, initialClientOffset: n } = e; return !t || !n ? null : Df(t, n) } const Er = [], vu = []; Er.__IS_NONE__ = !0; vu.__IS_ALL__ = !0; function A0(e, t) { return e === Er ? !1 : e === vu || typeof t > "u" ? !0 : a0(t, e).length > 0 } class b0 { subscribeToStateChange(t, n = {}) { const { handlerIds: r } = n; L(typeof t == "function", "listener must be a function."), L(typeof r > "u" || Array.isArray(r), "handlerIds, when specified, must be an array of strings."); let i = this.store.getState().stateId; const o = () => { const s = this.store.getState(), l = s.stateId; try { l === i || l === i + 1 && !A0(s.dirtyHandlerIds, r) || t() } finally { i = l } }; return this.store.subscribe(o) } subscribeToOffsetChange(t) { L(typeof t == "function", "listener must be a function."); let n = this.store.getState().dragOffset; const r = () => { const i = this.store.getState().dragOffset; i !== n && (n = i, t()) }; return this.store.subscribe(r) } canDragSource(t) { if (!t) return !1; const n = this.registry.getSource(t); return L(n, `Expected to find a valid source. sourceId=${t}`), this.isDragging() ? !1 : n.canDrag(this, t) } canDropOnTarget(t) { if (!t) return !1; const n = this.registry.getTarget(t); if (L(n, `Expected to find a valid target. targetId=${t}`), !this.isDragging() || this.didDrop()) return !1; const r = this.registry.getTargetType(t), i = this.getItemType(); return gl(r, i) && n.canDrop(this, t) } isDragging() { return !!this.getItemType() } isDraggingSource(t) { if (!t) return !1; const n = this.registry.getSource(t, !0); if (L(n, `Expected to find a valid source. sourceId=${t}`), !this.isDragging() || !this.isSourcePublic()) return !1; const r = this.registry.getSourceType(t), i = this.getItemType(); return r !== i ? !1 : n.isDragging(this, t) } isOverTarget(t, n = { shallow: !1 }) { if (!t) return !1; const { shallow: r } = n; if (!this.isDragging()) return !1; const i = this.registry.getTargetType(t), o = this.getItemType(); if (o && !gl(i, o)) return !1; const s = this.getTargetIds(); if (!s.length) return !1; const l = s.indexOf(t); return r ? l === s.length - 1 : l > -1 } getItemType() { return this.store.getState().dragOperation.itemType } getItem() { return this.store.getState().dragOperation.item } getSourceId() { return this.store.getState().dragOperation.sourceId } getTargetIds() { return this.store.getState().dragOperation.targetIds } getDropResult() { return this.store.getState().dragOperation.dropResult } didDrop() { return this.store.getState().dragOperation.didDrop } isSourcePublic() { return !!this.store.getState().dragOperation.isSourcePublic } getInitialClientOffset() { return this.store.getState().dragOffset.initialClientOffset } getInitialSourceClientOffset() { return this.store.getState().dragOffset.initialSourceClientOffset } getClientOffset() { return this.store.getState().dragOffset.clientOffset } getSourceClientOffset() { return R0(this.store.getState().dragOffset) } getDifferenceFromInitialOffset() { return M0(this.store.getState().dragOffset) } constructor(t, n) { this.store = t, this.registry = n } } const Fa = typeof global < "u" ? global : self, Pf = Fa.MutationObserver || Fa.WebKitMutationObserver; function Nf(e) { return function () { const n = setTimeout(i, 0), r = setInterval(i, 50); function i() { clearTimeout(n), clearInterval(r), e() } } } function z0(e) { let t = 1; const n = new Pf(e), r = document.createTextNode(""); return n.observe(r, { characterData: !0 }), function () { t = -t, r.data = t } } const F0 = typeof Pf == "function" ? z0 : Nf; class $0 { enqueueTask(t) { const { queue: n, requestFlush: r } = this; n.length || (r(), this.flushing = !0), n[n.length] = t } constructor() { this.queue = [], this.pendingErrors = [], this.flushing = !1, this.index = 0, this.capacity = 1024, this.flush = () => { const { queue: t } = this; for (; this.index < t.length;) { const n = this.index; if (this.index++, t[n].call(), this.index > this.capacity) { for (let r = 0, i = t.length - this.index; r < i; r++)t[r] = t[r + this.index]; t.length -= this.index, this.index = 0 } } t.length = 0, this.index = 0, this.flushing = !1 }, this.registerPendingError = t => { this.pendingErrors.push(t), this.requestErrorThrow() }, this.requestFlush = F0(this.flush), this.requestErrorThrow = Nf(() => { if (this.pendingErrors.length) throw this.pendingErrors.shift() }) } } class U0 { call() { try { this.task && this.task() } catch (t) { this.onError(t) } finally { this.task = null, this.release(this) } } constructor(t, n) { this.onError = t, this.release = n, this.task = null } } class H0 { create(t) { const n = this.freeTasks, r = n.length ? n.pop() : new U0(this.onError, i => n[n.length] = i); return r.task = t, r } constructor(t) { this.onError = t, this.freeTasks = [] } } const If = new $0, W0 = new H0(If.registerPendingError); function B0(e) { If.enqueueTask(W0.create(e)) } const yu = "dnd-core/ADD_SOURCE", Su = "dnd-core/ADD_TARGET", wu = "dnd-core/REMOVE_SOURCE", To = "dnd-core/REMOVE_TARGET"; function V0(e) { return { type: yu, payload: { sourceId: e } } } function Q0(e) { return { type: Su, payload: { targetId: e } } } function K0(e) { return { type: wu, payload: { sourceId: e } } } function q0(e) { return { type: To, payload: { targetId: e } } } function G0(e) { L(typeof e.canDrag == "function", "Expected canDrag to be a function."), L(typeof e.beginDrag == "function", "Expected beginDrag to be a function."), L(typeof e.endDrag == "function", "Expected endDrag to be a function.") } function Y0(e) { L(typeof e.canDrop == "function", "Expected canDrop to be a function."), L(typeof e.hover == "function", "Expected hover to be a function."), L(typeof e.drop == "function", "Expected beginDrag to be a function.") } function ml(e, t) { if (t && Array.isArray(e)) { e.forEach(n => ml(n, !1)); return } L(typeof e == "string" || typeof e == "symbol", t ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.") } var We; (function (e) { e.SOURCE = "SOURCE", e.TARGET = "TARGET" })(We || (We = {})); let X0 = 0; function J0() { return X0++ } function Z0(e) { const t = J0().toString(); switch (e) { case We.SOURCE: return `S${t}`; case We.TARGET: return `T${t}`; default: throw new Error(`Unknown Handler Role: ${e}`) } } function $a(e) { switch (e[0]) { case "S": return We.SOURCE; case "T": return We.TARGET; default: throw new Error(`Cannot parse handler ID: ${e}`) } } function Ua(e, t) { const n = e.entries(); let r = !1; do { const { done: i, value: [, o] } = n.next(); if (o === t) return !0; r = !!i } while (!r); return !1 } class e1 { addSource(t, n) { ml(t), G0(n); const r = this.addHandler(We.SOURCE, t, n); return this.store.dispatch(V0(r)), r } addTarget(t, n) { ml(t, !0), Y0(n); const r = this.addHandler(We.TARGET, t, n); return this.store.dispatch(Q0(r)), r } containsHandler(t) { return Ua(this.dragSources, t) || Ua(this.dropTargets, t) } getSource(t, n = !1) { return L(this.isSourceId(t), "Expected a valid source ID."), n && t === this.pinnedSourceId ? this.pinnedSource : this.dragSources.get(t) } getTarget(t) { return L(this.isTargetId(t), "Expected a valid target ID."), this.dropTargets.get(t) } getSourceType(t) { return L(this.isSourceId(t), "Expected a valid source ID."), this.types.get(t) } getTargetType(t) { return L(this.isTargetId(t), "Expected a valid target ID."), this.types.get(t) } isSourceId(t) { return $a(t) === We.SOURCE } isTargetId(t) { return $a(t) === We.TARGET } removeSource(t) { L(this.getSource(t), "Expected an existing source."), this.store.dispatch(K0(t)), B0(() => { this.dragSources.delete(t), this.types.delete(t) }) } removeTarget(t) { L(this.getTarget(t), "Expected an existing target."), this.store.dispatch(q0(t)), this.dropTargets.delete(t), this.types.delete(t) } pinSource(t) { const n = this.getSource(t); L(n, "Expected an existing source."), this.pinnedSourceId = t, this.pinnedSource = n } unpinSource() { L(this.pinnedSource, "No source is pinned at the time."), this.pinnedSourceId = null, this.pinnedSource = null } addHandler(t, n, r) { const i = Z0(t); return this.types.set(i, n), t === We.SOURCE ? this.dragSources.set(i, r) : t === We.TARGET && this.dropTargets.set(i, r), i } constructor(t) { this.types = new Map, this.dragSources = new Map, this.dropTargets = new Map, this.pinnedSourceId = null, this.pinnedSource = null, this.store = t } } const t1 = (e, t) => e === t; function n1(e, t) { return !e && !t ? !0 : !e || !t ? !1 : e.x === t.x && e.y === t.y } function r1(e, t, n = t1) { if (e.length !== t.length) return !1; for (let r = 0; r < e.length; ++r)if (!n(e[r], t[r])) return !1; return !0 } function i1(e = Er, t) { switch (t.type) { case _o: break; case yu: case Su: case To: case wu: return Er; case ko: case mu: case Oo: case xo: default: return vu }const { targetIds: n = [], prevTargetIds: r = [] } = t.payload, i = u0(n, r); if (!(i.length > 0 || !r1(n, r))) return Er; const s = r[r.length - 1], l = n[n.length - 1]; return s !== l && (s && i.push(s), l && i.push(l)), i } function o1(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function s1(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}, r = Object.keys(n); typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function (i) { return Object.getOwnPropertyDescriptor(n, i).enumerable }))), r.forEach(function (i) { o1(e, i, n[i]) }) } return e } const Ha = { initialSourceClientOffset: null, initialClientOffset: null, clientOffset: null }; function l1(e = Ha, t) { const { payload: n } = t; switch (t.type) { case gu: case ko: return { initialSourceClientOffset: n.sourceClientOffset, initialClientOffset: n.clientOffset, clientOffset: n.clientOffset }; case _o: return n1(e.clientOffset, n.clientOffset) ? e : s1({}, e, { clientOffset: n.clientOffset }); case Oo: case xo: return Ha; default: return e } } function u1(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function wn(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}, r = Object.keys(n); typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function (i) { return Object.getOwnPropertyDescriptor(n, i).enumerable }))), r.forEach(function (i) { u1(e, i, n[i]) }) } return e } const a1 = { itemType: null, item: null, sourceId: null, targetIds: [], dropResult: null, didDrop: !1, isSourcePublic: null }; function c1(e = a1, t) { const { payload: n } = t; switch (t.type) { case ko: return wn({}, e, { itemType: n.itemType, item: n.item, sourceId: n.sourceId, isSourcePublic: n.isSourcePublic, dropResult: null, didDrop: !1 }); case mu: return wn({}, e, { isSourcePublic: !0 }); case _o: return wn({}, e, { targetIds: n.targetIds }); case To: return e.targetIds.indexOf(n.targetId) === -1 ? e : wn({}, e, { targetIds: l0(e.targetIds, n.targetId) }); case xo: return wn({}, e, { dropResult: n.dropResult, didDrop: !0, targetIds: [] }); case Oo: return wn({}, e, { itemType: null, item: null, sourceId: null, dropResult: null, didDrop: !1, isSourcePublic: null, targetIds: [] }); default: return e } } function d1(e = 0, t) { switch (t.type) { case yu: case Su: return e + 1; case wu: case To: return e - 1; default: return e } } function f1(e = 0) { return e + 1 } function h1(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function p1(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}, r = Object.keys(n); typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function (i) { return Object.getOwnPropertyDescriptor(n, i).enumerable }))), r.forEach(function (i) { h1(e, i, n[i]) }) } return e } function g1(e = {}, t) { return { dirtyHandlerIds: i1(e.dirtyHandlerIds, { type: t.type, payload: p1({}, t.payload, { prevTargetIds: s0(e, "dragOperation.targetIds", []) }) }), dragOffset: l1(e.dragOffset, t), refCount: d1(e.refCount, t), dragOperation: c1(e.dragOperation, t), stateId: f1(e.stateId) } } function m1(e, t = void 0, n = {}, r = !1) { const i = v1(r), o = new b0(i, new e1(i)), s = new L0(i, o), l = e(s, t, n); return s.receiveBackend(l), s } function v1(e) { const t = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION__; return Of(g1, e && t && t({ name: "dnd-core", instanceId: "dnd-core" })) } function y1(e, t) { if (e == null) return {}; var n = S1(e, t), r, i; if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); for (i = 0; i < o.length; i++)r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]) } return n } function S1(e, t) { if (e == null) return {}; var n = {}, r = Object.keys(e), i, o; for (o = 0; o < r.length; o++)i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]); return n } let Wa = 0; const ji = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__"); var w1 = C.memo(function (t) { var { children: n } = t, r = y1(t, ["children"]); const [i, o] = E1(r); return C.useEffect(() => { if (o) { const s = Lf(); return ++Wa, () => { --Wa === 0 && (s[ji] = null) } } }, []), S.jsx(xf.Provider, { value: i, children: n }) }); function E1(e) { if ("manager" in e) return [{ dragDropManager: e.manager }, !1]; const t = C1(e.backend, e.context, e.options, e.debugMode), n = !e.context; return [t, n] } function C1(e, t = Lf(), n, r) { const i = t; return i[ji] || (i[ji] = { dragDropManager: m1(e, t, n, r) }), i[ji] } function Lf() { return typeof global < "u" ? global : window } var k1 = function e(t, n) { if (t === n) return !0; if (t && n && typeof t == "object" && typeof n == "object") { if (t.constructor !== n.constructor) return !1; var r, i, o; if (Array.isArray(t)) { if (r = t.length, r != n.length) return !1; for (i = r; i-- !== 0;)if (!e(t[i], n[i])) return !1; return !0 } if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags; if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf(); if (t.toString !== Object.prototype.toString) return t.toString() === n.toString(); if (o = Object.keys(t), r = o.length, r !== Object.keys(n).length) return !1; for (i = r; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(n, o[i])) return !1; for (i = r; i-- !== 0;) { var s = o[i]; if (!e(t[s], n[s])) return !1 } return !0 } return t !== t && n !== n }; const hn = typeof window < "u" ? C.useLayoutEffect : C.useEffect; function jf(e, t, n) { const [r, i] = C.useState(() => t(e)), o = C.useCallback(() => { const s = t(e); k1(r, s) || (i(s), n && n()) }, [r, e, n]); return hn(o), [r, o] } function _1(e, t, n) { const [r, i] = jf(e, t, n); return hn(function () { const s = e.getHandlerId(); if (s != null) return e.subscribeToStateChange(i, { handlerIds: [s] }) }, [e, i]), r } function Rf(e, t, n) { return _1(t, e || (() => ({})), () => n.reconnect()) } function Mf(e, t) { const n = [...t || []]; return t == null && typeof e != "function" && n.push(e), C.useMemo(() => typeof e == "function" ? e() : e, n) } function x1(e) { return C.useMemo(() => e.hooks.dragSource(), [e]) } function O1(e) { return C.useMemo(() => e.hooks.dragPreview(), [e]) } let ps = !1, gs = !1; class T1 { receiveHandlerId(t) { this.sourceId = t } getHandlerId() { return this.sourceId } canDrag() { L(!ps, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor"); try { return ps = !0, this.internalMonitor.canDragSource(this.sourceId) } finally { ps = !1 } } isDragging() { if (!this.sourceId) return !1; L(!gs, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor"); try { return gs = !0, this.internalMonitor.isDraggingSource(this.sourceId) } finally { gs = !1 } } subscribeToStateChange(t, n) { return this.internalMonitor.subscribeToStateChange(t, n) } isDraggingSource(t) { return this.internalMonitor.isDraggingSource(t) } isOverTarget(t, n) { return this.internalMonitor.isOverTarget(t, n) } getTargetIds() { return this.internalMonitor.getTargetIds() } isSourcePublic() { return this.internalMonitor.isSourcePublic() } getSourceId() { return this.internalMonitor.getSourceId() } subscribeToOffsetChange(t) { return this.internalMonitor.subscribeToOffsetChange(t) } canDragSource(t) { return this.internalMonitor.canDragSource(t) } canDropOnTarget(t) { return this.internalMonitor.canDropOnTarget(t) } getItemType() { return this.internalMonitor.getItemType() } getItem() { return this.internalMonitor.getItem() } getDropResult() { return this.internalMonitor.getDropResult() } didDrop() { return this.internalMonitor.didDrop() } getInitialClientOffset() { return this.internalMonitor.getInitialClientOffset() } getInitialSourceClientOffset() { return this.internalMonitor.getInitialSourceClientOffset() } getSourceClientOffset() { return this.internalMonitor.getSourceClientOffset() } getClientOffset() { return this.internalMonitor.getClientOffset() } getDifferenceFromInitialOffset() { return this.internalMonitor.getDifferenceFromInitialOffset() } constructor(t) { this.sourceId = null, this.internalMonitor = t.getMonitor() } } let ms = !1; class D1 { receiveHandlerId(t) { this.targetId = t } getHandlerId() { return this.targetId } subscribeToStateChange(t, n) { return this.internalMonitor.subscribeToStateChange(t, n) } canDrop() { if (!this.targetId) return !1; L(!ms, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor"); try { return ms = !0, this.internalMonitor.canDropOnTarget(this.targetId) } finally { ms = !1 } } isOver(t) { return this.targetId ? this.internalMonitor.isOverTarget(this.targetId, t) : !1 } getItemType() { return this.internalMonitor.getItemType() } getItem() { return this.internalMonitor.getItem() } getDropResult() { return this.internalMonitor.getDropResult() } didDrop() { return this.internalMonitor.didDrop() } getInitialClientOffset() { return this.internalMonitor.getInitialClientOffset() } getInitialSourceClientOffset() { return this.internalMonitor.getInitialSourceClientOffset() } getSourceClientOffset() { return this.internalMonitor.getSourceClientOffset() } getClientOffset() { return this.internalMonitor.getClientOffset() } getDifferenceFromInitialOffset() { return this.internalMonitor.getDifferenceFromInitialOffset() } constructor(t) { this.targetId = null, this.internalMonitor = t.getMonitor() } } function P1(e, t, n) { const r = n.getRegistry(), i = r.addTarget(e, t); return [i, () => r.removeTarget(i)] } function N1(e, t, n) { const r = n.getRegistry(), i = r.addSource(e, t); return [i, () => r.removeSource(i)] } function vl(e, t, n, r) { let i = n ? n.call(r, e, t) : void 0; if (i !== void 0) return !!i; if (e === t) return !0; if (typeof e != "object" || !e || typeof t != "object" || !t) return !1; const o = Object.keys(e), s = Object.keys(t); if (o.length !== s.length) return !1; const l = Object.prototype.hasOwnProperty.bind(t); for (let u = 0; u < o.length; u++) { const a = o[u]; if (!l(a)) return !1; const g = e[a], p = t[a]; if (i = n ? n.call(r, g, p, a) : void 0, i === !1 || i === void 0 && g !== p) return !1 } return !0 } function yl(e) { return e !== null && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } function I1(e) { if (typeof e.type == "string") return; const t = e.type.displayName || e.type.name || "the component"; throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${t} into a <div>, or turn it into a drag source or a drop target itself.`) } function L1(e) { return (t = null, n = null) => { if (!C.isValidElement(t)) { const o = t; return e(o, n), o } const r = t; return I1(r), j1(r, n ? o => e(o, n) : e) } } function Af(e) { const t = {}; return Object.keys(e).forEach(n => { const r = e[n]; if (n.endsWith("Ref")) t[n] = e[n]; else { const i = L1(r); t[n] = () => i } }), t } function Ba(e, t) { typeof e == "function" ? e(t) : e.current = t } function j1(e, t) { const n = e.ref; return L(typeof n != "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"), n ? C.cloneElement(e, { ref: r => { Ba(n, r), Ba(t, r) } }) : C.cloneElement(e, { ref: t }) } class R1 { receiveHandlerId(t) { this.handlerId !== t && (this.handlerId = t, this.reconnect()) } get connectTarget() { return this.dragSource } get dragSourceOptions() { return this.dragSourceOptionsInternal } set dragSourceOptions(t) { this.dragSourceOptionsInternal = t } get dragPreviewOptions() { return this.dragPreviewOptionsInternal } set dragPreviewOptions(t) { this.dragPreviewOptionsInternal = t } reconnect() { const t = this.reconnectDragSource(); this.reconnectDragPreview(t) } reconnectDragSource() { const t = this.dragSource, n = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange(); return n && this.disconnectDragSource(), this.handlerId ? t ? (n && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDragSource = t, this.lastConnectedDragSourceOptions = this.dragSourceOptions, this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, t, this.dragSourceOptions)), n) : (this.lastConnectedDragSource = t, n) : n } reconnectDragPreview(t = !1) { const n = this.dragPreview, r = t || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange(); if (r && this.disconnectDragPreview(), !!this.handlerId) { if (!n) { this.lastConnectedDragPreview = n; return } r && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDragPreview = n, this.lastConnectedDragPreviewOptions = this.dragPreviewOptions, this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, n, this.dragPreviewOptions)) } } didHandlerIdChange() { return this.lastConnectedHandlerId !== this.handlerId } didConnectedDragSourceChange() { return this.lastConnectedDragSource !== this.dragSource } didConnectedDragPreviewChange() { return this.lastConnectedDragPreview !== this.dragPreview } didDragSourceOptionsChange() { return !vl(this.lastConnectedDragSourceOptions, this.dragSourceOptions) } didDragPreviewOptionsChange() { return !vl(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions) } disconnectDragSource() { this.dragSourceUnsubscribe && (this.dragSourceUnsubscribe(), this.dragSourceUnsubscribe = void 0) } disconnectDragPreview() { this.dragPreviewUnsubscribe && (this.dragPreviewUnsubscribe(), this.dragPreviewUnsubscribe = void 0, this.dragPreviewNode = null, this.dragPreviewRef = null) } get dragSource() { return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current } get dragPreview() { return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current } clearDragSource() { this.dragSourceNode = null, this.dragSourceRef = null } clearDragPreview() { this.dragPreviewNode = null, this.dragPreviewRef = null } constructor(t) { this.hooks = Af({ dragSource: (n, r) => { this.clearDragSource(), this.dragSourceOptions = r || null, yl(n) ? this.dragSourceRef = n : this.dragSourceNode = n, this.reconnectDragSource() }, dragPreview: (n, r) => { this.clearDragPreview(), this.dragPreviewOptions = r || null, yl(n) ? this.dragPreviewRef = n : this.dragPreviewNode = n, this.reconnectDragPreview() } }), this.handlerId = null, this.dragSourceRef = null, this.dragSourceOptionsInternal = null, this.dragPreviewRef = null, this.dragPreviewOptionsInternal = null, this.lastConnectedHandlerId = null, this.lastConnectedDragSource = null, this.lastConnectedDragSourceOptions = null, this.lastConnectedDragPreview = null, this.lastConnectedDragPreviewOptions = null, this.backend = t } } class M1 { get connectTarget() { return this.dropTarget } reconnect() { const t = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange(); t && this.disconnectDropTarget(); const n = this.dropTarget; if (this.handlerId) { if (!n) { this.lastConnectedDropTarget = n; return } t && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDropTarget = n, this.lastConnectedDropTargetOptions = this.dropTargetOptions, this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, n, this.dropTargetOptions)) } } receiveHandlerId(t) { t !== this.handlerId && (this.handlerId = t, this.reconnect()) } get dropTargetOptions() { return this.dropTargetOptionsInternal } set dropTargetOptions(t) { this.dropTargetOptionsInternal = t } didHandlerIdChange() { return this.lastConnectedHandlerId !== this.handlerId } didDropTargetChange() { return this.lastConnectedDropTarget !== this.dropTarget } didOptionsChange() { return !vl(this.lastConnectedDropTargetOptions, this.dropTargetOptions) } disconnectDropTarget() { this.unsubscribeDropTarget && (this.unsubscribeDropTarget(), this.unsubscribeDropTarget = void 0) } get dropTarget() { return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current } clearDropTarget() { this.dropTargetRef = null, this.dropTargetNode = null } constructor(t) { this.hooks = Af({ dropTarget: (n, r) => { this.clearDropTarget(), this.dropTargetOptions = r, yl(n) ? this.dropTargetRef = n : this.dropTargetNode = n, this.reconnect() } }), this.handlerId = null, this.dropTargetRef = null, this.dropTargetOptionsInternal = null, this.lastConnectedHandlerId = null, this.lastConnectedDropTarget = null, this.lastConnectedDropTargetOptions = null, this.backend = t } } function mn() { const { dragDropManager: e } = C.useContext(xf); return L(e != null, "Expected drag drop context"), e } function A1(e, t) { const n = mn(), r = C.useMemo(() => new R1(n.getBackend()), [n]); return hn(() => (r.dragSourceOptions = e || null, r.reconnect(), () => r.disconnectDragSource()), [r, e]), hn(() => (r.dragPreviewOptions = t || null, r.reconnect(), () => r.disconnectDragPreview()), [r, t]), r } function b1() { const e = mn(); return C.useMemo(() => new T1(e), [e]) } class z1 { beginDrag() { const t = this.spec, n = this.monitor; let r = null; return typeof t.item == "object" ? r = t.item : typeof t.item == "function" ? r = t.item(n) : r = {}, r ?? null } canDrag() { const t = this.spec, n = this.monitor; return typeof t.canDrag == "boolean" ? t.canDrag : typeof t.canDrag == "function" ? t.canDrag(n) : !0 } isDragging(t, n) { const r = this.spec, i = this.monitor, { isDragging: o } = r; return o ? o(i) : n === t.getSourceId() } endDrag() { const t = this.spec, n = this.monitor, r = this.connector, { end: i } = t; i && i(n.getItem(), n), r.reconnect() } constructor(t, n, r) { this.spec = t, this.monitor = n, this.connector = r } } function F1(e, t, n) { const r = C.useMemo(() => new z1(e, t, n), [t, n]); return C.useEffect(() => { r.spec = e }, [e]), r } function $1(e) { return C.useMemo(() => { const t = e.type; return L(t != null, "spec.type must be defined"), t }, [e]) } function U1(e, t, n) { const r = mn(), i = F1(e, t, n), o = $1(e); hn(function () { if (o != null) { const [l, u] = N1(o, i, r); return t.receiveHandlerId(l), n.receiveHandlerId(l), u } }, [r, t, n, i, o]) } function H1(e, t) { const n = Mf(e, t); L(!n.begin, "useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)"); const r = b1(), i = A1(n.options, n.previewOptions); return U1(n, r, i), [Rf(n.collect, r, i), x1(i), O1(i)] } function W1(e) { const n = mn().getMonitor(), [r, i] = jf(n, e); return C.useEffect(() => n.subscribeToOffsetChange(i)), C.useEffect(() => n.subscribeToStateChange(i)), r } function B1(e) { return C.useMemo(() => e.hooks.dropTarget(), [e]) } function V1(e) { const t = mn(), n = C.useMemo(() => new M1(t.getBackend()), [t]); return hn(() => (n.dropTargetOptions = e || null, n.reconnect(), () => n.disconnectDropTarget()), [e]), n } function Q1() { const e = mn(); return C.useMemo(() => new D1(e), [e]) } function K1(e) { const { accept: t } = e; return C.useMemo(() => (L(e.accept != null, "accept must be defined"), Array.isArray(t) ? t : [t]), [t]) } class q1 { canDrop() { const t = this.spec, n = this.monitor; return t.canDrop ? t.canDrop(n.getItem(), n) : !0 } hover() { const t = this.spec, n = this.monitor; t.hover && t.hover(n.getItem(), n) } drop() { const t = this.spec, n = this.monitor; if (t.drop) return t.drop(n.getItem(), n) } constructor(t, n) { this.spec = t, this.monitor = n } } function G1(e, t) { const n = C.useMemo(() => new q1(e, t), [t]); return C.useEffect(() => { n.spec = e }, [e]), n } function Y1(e, t, n) { const r = mn(), i = G1(e, t), o = K1(e); hn(function () { const [l, u] = P1(o, i, r); return t.receiveHandlerId(l), n.receiveHandlerId(l), u }, [r, t, i, n, o.map(s => s.toString()).join("|")]) } function X1(e, t) { const n = Mf(e, t), r = Q1(), i = V1(n.options); return Y1(n, r, i), [Rf(n.collect, r, i), B1(i)] } function bf(e) { let t = null; return () => (t == null && (t = e()), t) } function J1(e, t) { return e.filter(n => n !== t) } function Z1(e, t) { const n = new Set, r = o => n.add(o); e.forEach(r), t.forEach(r); const i = []; return n.forEach(o => i.push(o)), i } class em { enter(t) { const n = this.entered.length, r = i => this.isNodeInDocument(i) && (!i.contains || i.contains(t)); return this.entered = Z1(this.entered.filter(r), [t]), n === 0 && this.entered.length > 0 } leave(t) { const n = this.entered.length; return this.entered = J1(this.entered.filter(this.isNodeInDocument), t), n > 0 && this.entered.length === 0 } reset() { this.entered = [] } constructor(t) { this.entered = [], this.isNodeInDocument = t } } class tm { initializeExposedProperties() { Object.keys(this.config.exposeProperties).forEach(t => { Object.defineProperty(this.item, t, { configurable: !0, enumerable: !0, get() { return console.warn(`Browser doesn't allow reading "${t}" until the drop event.`), null } }) }) } loadDataTransfer(t) { if (t) { const n = {}; Object.keys(this.config.exposeProperties).forEach(r => { const i = this.config.exposeProperties[r]; i != null && (n[r] = { value: i(t, this.config.matchesTypes), configurable: !0, enumerable: !0 }) }), Object.defineProperties(this.item, n) } } canDrag() { return !0 } beginDrag() { return this.item } isDragging(t, n) { return n === t.getSourceId() } endDrag() { } constructor(t) { this.config = t, this.item = {}, this.initializeExposedProperties() } } const zf = "__NATIVE_FILE__", Ff = "__NATIVE_URL__", $f = "__NATIVE_TEXT__", Uf = "__NATIVE_HTML__"; var Va = Object.freeze({ __proto__: null, FILE: zf, HTML: Uf, TEXT: $f, URL: Ff }); function vs(e, t, n) { const r = t.reduce((i, o) => i || e.getData(o), ""); return r ?? n } const Sl = {
    [zf]: { exposeProperties: { files: e => Array.prototype.slice.call(e.files), items: e => e.items, dataTransfer: e => e }, matchesTypes: ["Files"] }, [Uf]: { exposeProperties: { html: (e, t) => vs(e, t, ""), dataTransfer: e => e }, matchesTypes: ["Html", "text/html"] }, [Ff]: {
        exposeProperties: {
            urls: (e, t) => vs(e, t, "").split(`
`), dataTransfer: e => e
        }, matchesTypes: ["Url", "text/uri-list"]
    }, [$f]: { exposeProperties: { text: (e, t) => vs(e, t, ""), dataTransfer: e => e }, matchesTypes: ["Text", "text/plain"] }
}; function nm(e, t) { const n = Sl[e]; if (!n) throw new Error(`native type ${e} has no configuration`); const r = new tm(n); return r.loadDataTransfer(t), r } function ys(e) { if (!e) return null; const t = Array.prototype.slice.call(e.types || []); return Object.keys(Sl).filter(n => { const r = Sl[n]; return r != null && r.matchesTypes ? r.matchesTypes.some(i => t.indexOf(i) > -1) : !1 })[0] || null } const rm = bf(() => /firefox/i.test(navigator.userAgent)), Hf = bf(() => !!window.safari); class Qa { interpolate(t) { const { xs: n, ys: r, c1s: i, c2s: o, c3s: s } = this; let l = n.length - 1; if (t === n[l]) return r[l]; let u = 0, a = s.length - 1, g; for (; u <= a;) { g = Math.floor(.5 * (u + a)); const y = n[g]; if (y < t) u = g + 1; else if (y > t) a = g - 1; else return r[g] } l = Math.max(0, a); const p = t - n[l], f = p * p; return r[l] + i[l] * p + o[l] * f + s[l] * p * f } constructor(t, n) { const { length: r } = t, i = []; for (let y = 0; y < r; y++)i.push(y); i.sort((y, m) => t[y] < t[m] ? -1 : 1); const o = [], s = []; let l, u; for (let y = 0; y < r - 1; y++)l = t[y + 1] - t[y], u = n[y + 1] - n[y], o.push(l), s.push(u / l); const a = [s[0]]; for (let y = 0; y < o.length - 1; y++) { const m = s[y], v = s[y + 1]; if (m * v <= 0) a.push(0); else { l = o[y]; const E = o[y + 1], d = l + E; a.push(3 * d / ((d + E) / m + (d + l) / v)) } } a.push(s[s.length - 1]); const g = [], p = []; let f; for (let y = 0; y < a.length - 1; y++) { f = s[y]; const m = a[y], v = 1 / o[y], E = m + a[y + 1] - f - f; g.push((f - m - E) * v), p.push(E * v * v) } this.xs = t, this.ys = n, this.c1s = a, this.c2s = g, this.c3s = p } } const im = 1; function Wf(e) { const t = e.nodeType === im ? e : e.parentElement; if (!t) return null; const { top: n, left: r } = t.getBoundingClientRect(); return { x: r, y: n } } function yi(e) { return { x: e.clientX, y: e.clientY } } function om(e) { var t; return e.nodeName === "IMG" && (rm() || !(!((t = document.documentElement) === null || t === void 0) && t.contains(e))) } function sm(e, t, n, r) { let i = e ? t.width : n, o = e ? t.height : r; return Hf() && e && (o /= window.devicePixelRatio, i /= window.devicePixelRatio), { dragPreviewWidth: i, dragPreviewHeight: o } } function lm(e, t, n, r, i) { const o = om(t), l = Wf(o ? e : t), u = { x: n.x - l.x, y: n.y - l.y }, { offsetWidth: a, offsetHeight: g } = e, { anchorX: p, anchorY: f } = r, { dragPreviewWidth: y, dragPreviewHeight: m } = sm(o, t, a, g), v = () => { let O = new Qa([0, .5, 1], [u.y, u.y / g * m, u.y + m - g]).interpolate(f); return Hf() && o && (O += (window.devicePixelRatio - 1) * m), O }, E = () => new Qa([0, .5, 1], [u.x, u.x / a * y, u.x + y - a]).interpolate(p), { offsetX: d, offsetY: c } = i, h = d === 0 || d, w = c === 0 || c; return { x: h ? d : E(), y: w ? c : v() } } let um = class { get window() { if (this.globalContext) return this.globalContext; if (typeof window < "u") return window } get document() { var t; return !((t = this.globalContext) === null || t === void 0) && t.document ? this.globalContext.document : this.window ? this.window.document : void 0 } get rootElement() { var t; return ((t = this.optionsArgs) === null || t === void 0 ? void 0 : t.rootElement) || this.window } constructor(t, n) { this.ownerDocument = null, this.globalContext = t, this.optionsArgs = n } }; function am(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function Ka(e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t] != null ? arguments[t] : {}, r = Object.keys(n); typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function (i) { return Object.getOwnPropertyDescriptor(n, i).enumerable }))), r.forEach(function (i) { am(e, i, n[i]) }) } return e } class cm { profile() { var t, n; return { sourcePreviewNodes: this.sourcePreviewNodes.size, sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size, sourceNodeOptions: this.sourceNodeOptions.size, sourceNodes: this.sourceNodes.size, dragStartSourceIds: ((t = this.dragStartSourceIds) === null || t === void 0 ? void 0 : t.length) || 0, dropTargetIds: this.dropTargetIds.length, dragEnterTargetIds: this.dragEnterTargetIds.length, dragOverTargetIds: ((n = this.dragOverTargetIds) === null || n === void 0 ? void 0 : n.length) || 0 } } get window() { return this.options.window } get document() { return this.options.document } get rootElement() { return this.options.rootElement } setup() { const t = this.rootElement; if (t !== void 0) { if (t.__isReactDndBackendSetUp) throw new Error("Cannot have two HTML5 backends at the same time."); t.__isReactDndBackendSetUp = !0, this.addEventListeners(t) } } teardown() { const t = this.rootElement; if (t !== void 0 && (t.__isReactDndBackendSetUp = !1, this.removeEventListeners(this.rootElement), this.clearCurrentDragSourceNode(), this.asyncEndDragFrameId)) { var n; (n = this.window) === null || n === void 0 || n.cancelAnimationFrame(this.asyncEndDragFrameId) } } connectDragPreview(t, n, r) { return this.sourcePreviewNodeOptions.set(t, r), this.sourcePreviewNodes.set(t, n), () => { this.sourcePreviewNodes.delete(t), this.sourcePreviewNodeOptions.delete(t) } } connectDragSource(t, n, r) { this.sourceNodes.set(t, n), this.sourceNodeOptions.set(t, r); const i = s => this.handleDragStart(s, t), o = s => this.handleSelectStart(s); return n.setAttribute("draggable", "true"), n.addEventListener("dragstart", i), n.addEventListener("selectstart", o), () => { this.sourceNodes.delete(t), this.sourceNodeOptions.delete(t), n.removeEventListener("dragstart", i), n.removeEventListener("selectstart", o), n.setAttribute("draggable", "false") } } connectDropTarget(t, n) { const r = s => this.handleDragEnter(s, t), i = s => this.handleDragOver(s, t), o = s => this.handleDrop(s, t); return n.addEventListener("dragenter", r), n.addEventListener("dragover", i), n.addEventListener("drop", o), () => { n.removeEventListener("dragenter", r), n.removeEventListener("dragover", i), n.removeEventListener("drop", o) } } addEventListeners(t) { t.addEventListener && (t.addEventListener("dragstart", this.handleTopDragStart), t.addEventListener("dragstart", this.handleTopDragStartCapture, !0), t.addEventListener("dragend", this.handleTopDragEndCapture, !0), t.addEventListener("dragenter", this.handleTopDragEnter), t.addEventListener("dragenter", this.handleTopDragEnterCapture, !0), t.addEventListener("dragleave", this.handleTopDragLeaveCapture, !0), t.addEventListener("dragover", this.handleTopDragOver), t.addEventListener("dragover", this.handleTopDragOverCapture, !0), t.addEventListener("drop", this.handleTopDrop), t.addEventListener("drop", this.handleTopDropCapture, !0)) } removeEventListeners(t) { t.removeEventListener && (t.removeEventListener("dragstart", this.handleTopDragStart), t.removeEventListener("dragstart", this.handleTopDragStartCapture, !0), t.removeEventListener("dragend", this.handleTopDragEndCapture, !0), t.removeEventListener("dragenter", this.handleTopDragEnter), t.removeEventListener("dragenter", this.handleTopDragEnterCapture, !0), t.removeEventListener("dragleave", this.handleTopDragLeaveCapture, !0), t.removeEventListener("dragover", this.handleTopDragOver), t.removeEventListener("dragover", this.handleTopDragOverCapture, !0), t.removeEventListener("drop", this.handleTopDrop), t.removeEventListener("drop", this.handleTopDropCapture, !0)) } getCurrentSourceNodeOptions() { const t = this.monitor.getSourceId(), n = this.sourceNodeOptions.get(t); return Ka({ dropEffect: this.altKeyPressed ? "copy" : "move" }, n || {}) } getCurrentDropEffect() { return this.isDraggingNativeItem() ? "copy" : this.getCurrentSourceNodeOptions().dropEffect } getCurrentSourcePreviewNodeOptions() { const t = this.monitor.getSourceId(), n = this.sourcePreviewNodeOptions.get(t); return Ka({ anchorX: .5, anchorY: .5, captureDraggingState: !1 }, n || {}) } isDraggingNativeItem() { const t = this.monitor.getItemType(); return Object.keys(Va).some(n => Va[n] === t) } beginDragNativeItem(t, n) { this.clearCurrentDragSourceNode(), this.currentNativeSource = nm(t, n), this.currentNativeHandle = this.registry.addSource(t, this.currentNativeSource), this.actions.beginDrag([this.currentNativeHandle]) } setCurrentDragSourceNode(t) { this.clearCurrentDragSourceNode(), this.currentDragSourceNode = t; const n = 1e3; this.mouseMoveTimeoutTimer = setTimeout(() => { var r; return (r = this.rootElement) === null || r === void 0 ? void 0 : r.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, !0) }, n) } clearCurrentDragSourceNode() { if (this.currentDragSourceNode) { if (this.currentDragSourceNode = null, this.rootElement) { var t; (t = this.window) === null || t === void 0 || t.clearTimeout(this.mouseMoveTimeoutTimer || void 0), this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, !0) } return this.mouseMoveTimeoutTimer = null, !0 } return !1 } handleDragStart(t, n) { t.defaultPrevented || (this.dragStartSourceIds || (this.dragStartSourceIds = []), this.dragStartSourceIds.unshift(n)) } handleDragEnter(t, n) { this.dragEnterTargetIds.unshift(n) } handleDragOver(t, n) { this.dragOverTargetIds === null && (this.dragOverTargetIds = []), this.dragOverTargetIds.unshift(n) } handleDrop(t, n) { this.dropTargetIds.unshift(n) } constructor(t, n, r) { this.sourcePreviewNodes = new Map, this.sourcePreviewNodeOptions = new Map, this.sourceNodes = new Map, this.sourceNodeOptions = new Map, this.dragStartSourceIds = null, this.dropTargetIds = [], this.dragEnterTargetIds = [], this.currentNativeSource = null, this.currentNativeHandle = null, this.currentDragSourceNode = null, this.altKeyPressed = !1, this.mouseMoveTimeoutTimer = null, this.asyncEndDragFrameId = null, this.dragOverTargetIds = null, this.lastClientOffset = null, this.hoverRafId = null, this.getSourceClientOffset = i => { const o = this.sourceNodes.get(i); return o && Wf(o) || null }, this.endDragNativeItem = () => { this.isDraggingNativeItem() && (this.actions.endDrag(), this.currentNativeHandle && this.registry.removeSource(this.currentNativeHandle), this.currentNativeHandle = null, this.currentNativeSource = null) }, this.isNodeInDocument = i => !!(i && this.document && this.document.body && this.document.body.contains(i)), this.endDragIfSourceWasRemovedFromDOM = () => { const i = this.currentDragSourceNode; i == null || this.isNodeInDocument(i) || (this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover()) }, this.scheduleHover = i => { this.hoverRafId === null && typeof requestAnimationFrame < "u" && (this.hoverRafId = requestAnimationFrame(() => { this.monitor.isDragging() && this.actions.hover(i || [], { clientOffset: this.lastClientOffset }), this.hoverRafId = null })) }, this.cancelHover = () => { this.hoverRafId !== null && typeof cancelAnimationFrame < "u" && (cancelAnimationFrame(this.hoverRafId), this.hoverRafId = null) }, this.handleTopDragStartCapture = () => { this.clearCurrentDragSourceNode(), this.dragStartSourceIds = [] }, this.handleTopDragStart = i => { if (i.defaultPrevented) return; const { dragStartSourceIds: o } = this; this.dragStartSourceIds = null; const s = yi(i); this.monitor.isDragging() && (this.actions.endDrag(), this.cancelHover()), this.actions.beginDrag(o || [], { publishSource: !1, getSourceClientOffset: this.getSourceClientOffset, clientOffset: s }); const { dataTransfer: l } = i, u = ys(l); if (this.monitor.isDragging()) { if (l && typeof l.setDragImage == "function") { const g = this.monitor.getSourceId(), p = this.sourceNodes.get(g), f = this.sourcePreviewNodes.get(g) || p; if (f) { const { anchorX: y, anchorY: m, offsetX: v, offsetY: E } = this.getCurrentSourcePreviewNodeOptions(), h = lm(p, f, s, { anchorX: y, anchorY: m }, { offsetX: v, offsetY: E }); l.setDragImage(f, h.x, h.y) } } try { l == null || l.setData("application/json", {}) } catch { } this.setCurrentDragSourceNode(i.target); const { captureDraggingState: a } = this.getCurrentSourcePreviewNodeOptions(); a ? this.actions.publishDragSource() : setTimeout(() => this.actions.publishDragSource(), 0) } else if (u) this.beginDragNativeItem(u); else { if (l && !l.types && (i.target && !i.target.hasAttribute || !i.target.hasAttribute("draggable"))) return; i.preventDefault() } }, this.handleTopDragEndCapture = () => { this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover() }, this.handleTopDragEnterCapture = i => { if (this.dragEnterTargetIds = [], this.isDraggingNativeItem()) { var o; (o = this.currentNativeSource) === null || o === void 0 || o.loadDataTransfer(i.dataTransfer) } if (!this.enterLeaveCounter.enter(i.target) || this.monitor.isDragging()) return; const { dataTransfer: l } = i, u = ys(l); u && this.beginDragNativeItem(u, l) }, this.handleTopDragEnter = i => { const { dragEnterTargetIds: o } = this; if (this.dragEnterTargetIds = [], !this.monitor.isDragging()) return; this.altKeyPressed = i.altKey, o.length > 0 && this.actions.hover(o, { clientOffset: yi(i) }), o.some(l => this.monitor.canDropOnTarget(l)) && (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = this.getCurrentDropEffect())) }, this.handleTopDragOverCapture = i => { if (this.dragOverTargetIds = [], this.isDraggingNativeItem()) { var o; (o = this.currentNativeSource) === null || o === void 0 || o.loadDataTransfer(i.dataTransfer) } }, this.handleTopDragOver = i => { const { dragOverTargetIds: o } = this; if (this.dragOverTargetIds = [], !this.monitor.isDragging()) { i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = "none"); return } this.altKeyPressed = i.altKey, this.lastClientOffset = yi(i), this.scheduleHover(o), (o || []).some(l => this.monitor.canDropOnTarget(l)) ? (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = this.getCurrentDropEffect())) : this.isDraggingNativeItem() ? i.preventDefault() : (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = "none")) }, this.handleTopDragLeaveCapture = i => { this.isDraggingNativeItem() && i.preventDefault(), this.enterLeaveCounter.leave(i.target) && (this.isDraggingNativeItem() && setTimeout(() => this.endDragNativeItem(), 0), this.cancelHover()) }, this.handleTopDropCapture = i => { if (this.dropTargetIds = [], this.isDraggingNativeItem()) { var o; i.preventDefault(), (o = this.currentNativeSource) === null || o === void 0 || o.loadDataTransfer(i.dataTransfer) } else ys(i.dataTransfer) && i.preventDefault(); this.enterLeaveCounter.reset() }, this.handleTopDrop = i => { const { dropTargetIds: o } = this; this.dropTargetIds = [], this.actions.hover(o, { clientOffset: yi(i) }), this.actions.drop({ dropEffect: this.getCurrentDropEffect() }), this.isDraggingNativeItem() ? this.endDragNativeItem() : this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover() }, this.handleSelectStart = i => { const o = i.target; typeof o.dragDrop == "function" && (o.tagName === "INPUT" || o.tagName === "SELECT" || o.tagName === "TEXTAREA" || o.isContentEditable || (i.preventDefault(), o.dragDrop())) }, this.options = new um(n, r), this.actions = t.getActions(), this.monitor = t.getMonitor(), this.registry = t.getRegistry(), this.enterLeaveCounter = new em(this.isNodeInDocument) } } let Si; function dm() { return Si || (Si = new Image, Si.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), Si } const fm = function (t, n, r) { return new cm(t, n, r) }; var Qt; (function (e) { e.mouse = "mouse", e.touch = "touch", e.keyboard = "keyboard" })(Qt || (Qt = {})); class hm { get delay() { var t; return (t = this.args.delay) !== null && t !== void 0 ? t : 0 } get scrollAngleRanges() { return this.args.scrollAngleRanges } get getDropTargetElementsAtPoint() { return this.args.getDropTargetElementsAtPoint } get ignoreContextMenu() { var t; return (t = this.args.ignoreContextMenu) !== null && t !== void 0 ? t : !1 } get enableHoverOutsideTarget() { var t; return (t = this.args.enableHoverOutsideTarget) !== null && t !== void 0 ? t : !1 } get enableKeyboardEvents() { var t; return (t = this.args.enableKeyboardEvents) !== null && t !== void 0 ? t : !1 } get enableMouseEvents() { var t; return (t = this.args.enableMouseEvents) !== null && t !== void 0 ? t : !1 } get enableTouchEvents() { var t; return (t = this.args.enableTouchEvents) !== null && t !== void 0 ? t : !0 } get touchSlop() { return this.args.touchSlop || 0 } get delayTouchStart() { var t, n, r, i; return (i = (r = (t = this.args) === null || t === void 0 ? void 0 : t.delayTouchStart) !== null && r !== void 0 ? r : (n = this.args) === null || n === void 0 ? void 0 : n.delay) !== null && i !== void 0 ? i : 0 } get delayMouseStart() { var t, n, r, i; return (i = (r = (t = this.args) === null || t === void 0 ? void 0 : t.delayMouseStart) !== null && r !== void 0 ? r : (n = this.args) === null || n === void 0 ? void 0 : n.delay) !== null && i !== void 0 ? i : 0 } get window() { if (this.context && this.context.window) return this.context.window; if (typeof window < "u") return window } get document() { var t; if (!((t = this.context) === null || t === void 0) && t.document) return this.context.document; if (this.window) return this.window.document } get rootElement() { var t; return ((t = this.args) === null || t === void 0 ? void 0 : t.rootElement) || this.document } constructor(t, n) { this.args = t, this.context = n } } function pm(e, t, n, r) { return Math.sqrt(Math.pow(Math.abs(n - e), 2) + Math.pow(Math.abs(r - t), 2)) } function gm(e, t, n, r, i) { if (!i) return !1; const o = Math.atan2(r - t, n - e) * 180 / Math.PI + 180; for (let s = 0; s < i.length; ++s) { const l = i[s]; if (l && (l.start == null || o >= l.start) && (l.end == null || o <= l.end)) return !0 } return !1 } const mm = { Left: 1, Right: 2, Center: 4 }, vm = { Left: 0, Center: 1, Right: 2 }; function Ss(e) { return e.button === void 0 || e.button === vm.Left } function ym(e) { return e.buttons === void 0 || (e.buttons & mm.Left) === 0 } function Bf(e) { return !!e.targetTouches } const Sm = 1; function wm(e) { const t = e.nodeType === Sm ? e : e.parentElement; if (!t) return; const { top: n, left: r } = t.getBoundingClientRect(); return { x: r, y: n } } function Em(e, t) { if (e.targetTouches.length === 1) return oo(e.targetTouches[0]); if (t && e.touches.length === 1 && e.touches[0].target === t.target) return oo(e.touches[0]) } function oo(e, t) { return Bf(e) ? Em(e, t) : { x: e.clientX, y: e.clientY } } const qa = (() => { let e = !1; try { addEventListener("test", () => { }, Object.defineProperty({}, "passive", { get() { return e = !0, !0 } })) } catch { } return e })(), or = { [Qt.mouse]: { start: "mousedown", move: "mousemove", end: "mouseup", contextmenu: "contextmenu" }, [Qt.touch]: { start: "touchstart", move: "touchmove", end: "touchend" }, [Qt.keyboard]: { keydown: "keydown" } }; class Cr { profile() { var t; return { sourceNodes: this.sourceNodes.size, sourcePreviewNodes: this.sourcePreviewNodes.size, sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size, targetNodes: this.targetNodes.size, dragOverTargetIds: ((t = this.dragOverTargetIds) === null || t === void 0 ? void 0 : t.length) || 0 } } get document() { return this.options.document } setup() { const t = this.options.rootElement; t && (L(!Cr.isSetUp, "Cannot have two Touch backends at the same time."), Cr.isSetUp = !0, this.addEventListener(t, "start", this.getTopMoveStartHandler()), this.addEventListener(t, "start", this.handleTopMoveStartCapture, !0), this.addEventListener(t, "move", this.handleTopMove), this.addEventListener(t, "move", this.handleTopMoveCapture, !0), this.addEventListener(t, "end", this.handleTopMoveEndCapture, !0), this.options.enableMouseEvents && !this.options.ignoreContextMenu && this.addEventListener(t, "contextmenu", this.handleTopMoveEndCapture), this.options.enableKeyboardEvents && this.addEventListener(t, "keydown", this.handleCancelOnEscape, !0)) } teardown() { const t = this.options.rootElement; t && (Cr.isSetUp = !1, this._mouseClientOffset = {}, this.removeEventListener(t, "start", this.handleTopMoveStartCapture, !0), this.removeEventListener(t, "start", this.handleTopMoveStart), this.removeEventListener(t, "move", this.handleTopMoveCapture, !0), this.removeEventListener(t, "move", this.handleTopMove), this.removeEventListener(t, "end", this.handleTopMoveEndCapture, !0), this.options.enableMouseEvents && !this.options.ignoreContextMenu && this.removeEventListener(t, "contextmenu", this.handleTopMoveEndCapture), this.options.enableKeyboardEvents && this.removeEventListener(t, "keydown", this.handleCancelOnEscape, !0), this.uninstallSourceNodeRemovalObserver()) } addEventListener(t, n, r, i = !1) { const o = qa ? { capture: i, passive: !1 } : i; this.listenerTypes.forEach(function (s) { const l = or[s][n]; l && t.addEventListener(l, r, o) }) } removeEventListener(t, n, r, i = !1) { const o = qa ? { capture: i, passive: !1 } : i; this.listenerTypes.forEach(function (s) { const l = or[s][n]; l && t.removeEventListener(l, r, o) }) } connectDragSource(t, n) { const r = this.handleMoveStart.bind(this, t); return this.sourceNodes.set(t, n), this.addEventListener(n, "start", r), () => { this.sourceNodes.delete(t), this.removeEventListener(n, "start", r) } } connectDragPreview(t, n, r) { return this.sourcePreviewNodeOptions.set(t, r), this.sourcePreviewNodes.set(t, n), () => { this.sourcePreviewNodes.delete(t), this.sourcePreviewNodeOptions.delete(t) } } connectDropTarget(t, n) { const r = this.options.rootElement; if (!this.document || !r) return () => { }; const i = o => { if (!this.document || !r || !this.monitor.isDragging()) return; let s; switch (o.type) { case or.mouse.move: s = { x: o.clientX, y: o.clientY }; break; case or.touch.move: var l, u; s = { x: ((l = o.touches[0]) === null || l === void 0 ? void 0 : l.clientX) || 0, y: ((u = o.touches[0]) === null || u === void 0 ? void 0 : u.clientY) || 0 }; break }const a = s != null ? this.document.elementFromPoint(s.x, s.y) : void 0, g = a && n.contains(a); if (a === n || g) return this.handleMove(o, t) }; return this.addEventListener(this.document.body, "move", i), this.targetNodes.set(t, n), () => { this.document && (this.targetNodes.delete(t), this.removeEventListener(this.document.body, "move", i)) } } getTopMoveStartHandler() { return !this.options.delayTouchStart && !this.options.delayMouseStart ? this.handleTopMoveStart : this.handleTopMoveStartDelay } installSourceNodeRemovalObserver(t) { this.uninstallSourceNodeRemovalObserver(), this.draggedSourceNode = t, this.draggedSourceNodeRemovalObserver = new MutationObserver(() => { t && !t.parentElement && (this.resurrectSourceNode(), this.uninstallSourceNodeRemovalObserver()) }), !(!t || !t.parentElement) && this.draggedSourceNodeRemovalObserver.observe(t.parentElement, { childList: !0 }) } resurrectSourceNode() { this.document && this.draggedSourceNode && (this.draggedSourceNode.style.display = "none", this.draggedSourceNode.removeAttribute("data-reactid"), this.document.body.appendChild(this.draggedSourceNode)) } uninstallSourceNodeRemovalObserver() { this.draggedSourceNodeRemovalObserver && this.draggedSourceNodeRemovalObserver.disconnect(), this.draggedSourceNodeRemovalObserver = void 0, this.draggedSourceNode = void 0 } constructor(t, n, r) { this.getSourceClientOffset = i => { const o = this.sourceNodes.get(i); return o && wm(o) }, this.handleTopMoveStartCapture = i => { Ss(i) && (this.moveStartSourceIds = []) }, this.handleMoveStart = i => { Array.isArray(this.moveStartSourceIds) && this.moveStartSourceIds.unshift(i) }, this.handleTopMoveStart = i => { if (!Ss(i)) return; const o = oo(i); o && (Bf(i) && (this.lastTargetTouchFallback = i.targetTouches[0]), this._mouseClientOffset = o), this.waitingForDelay = !1 }, this.handleTopMoveStartDelay = i => { if (!Ss(i)) return; const o = i.type === or.touch.start ? this.options.delayTouchStart : this.options.delayMouseStart; this.timeout = setTimeout(this.handleTopMoveStart.bind(this, i), o), this.waitingForDelay = !0 }, this.handleTopMoveCapture = () => { this.dragOverTargetIds = [] }, this.handleMove = (i, o) => { this.dragOverTargetIds && this.dragOverTargetIds.unshift(o) }, this.handleTopMove = i => { if (this.timeout && clearTimeout(this.timeout), !this.document || this.waitingForDelay) return; const { moveStartSourceIds: o, dragOverTargetIds: s } = this, l = this.options.enableHoverOutsideTarget, u = oo(i, this.lastTargetTouchFallback); if (!u) return; if (this._isScrolling || !this.monitor.isDragging() && gm(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, u.x, u.y, this.options.scrollAngleRanges)) { this._isScrolling = !0; return } if (!this.monitor.isDragging() && this._mouseClientOffset.hasOwnProperty("x") && o && pm(this._mouseClientOffset.x || 0, this._mouseClientOffset.y || 0, u.x, u.y) > (this.options.touchSlop ? this.options.touchSlop : 0) && (this.moveStartSourceIds = void 0, this.actions.beginDrag(o, { clientOffset: this._mouseClientOffset, getSourceClientOffset: this.getSourceClientOffset, publishSource: !1 })), !this.monitor.isDragging()) return; const a = this.sourceNodes.get(this.monitor.getSourceId()); this.installSourceNodeRemovalObserver(a), this.actions.publishDragSource(), i.cancelable && i.preventDefault(); const g = (s || []).map(m => this.targetNodes.get(m)).filter(m => !!m), p = this.options.getDropTargetElementsAtPoint ? this.options.getDropTargetElementsAtPoint(u.x, u.y, g) : this.document.elementsFromPoint(u.x, u.y), f = []; for (const m in p) { if (!p.hasOwnProperty(m)) continue; let v = p[m]; for (v != null && f.push(v); v;)v = v.parentElement, v && f.indexOf(v) === -1 && f.push(v) } const y = f.filter(m => g.indexOf(m) > -1).map(m => this._getDropTargetId(m)).filter(m => !!m).filter((m, v, E) => E.indexOf(m) === v); if (l) for (const m in this.targetNodes) { const v = this.targetNodes.get(m); if (a && v && v.contains(a) && y.indexOf(m) === -1) { y.unshift(m); break } } y.reverse(), this.actions.hover(y, { clientOffset: u }) }, this._getDropTargetId = i => { const o = this.targetNodes.keys(); let s = o.next(); for (; s.done === !1;) { const l = s.value; if (i === this.targetNodes.get(l)) return l; s = o.next() } }, this.handleTopMoveEndCapture = i => { if (this._isScrolling = !1, this.lastTargetTouchFallback = void 0, !!ym(i)) { if (!this.monitor.isDragging() || this.monitor.didDrop()) { this.moveStartSourceIds = void 0; return } i.cancelable && i.preventDefault(), this._mouseClientOffset = {}, this.uninstallSourceNodeRemovalObserver(), this.actions.drop(), this.actions.endDrag() } }, this.handleCancelOnEscape = i => { i.key === "Escape" && this.monitor.isDragging() && (this._mouseClientOffset = {}, this.uninstallSourceNodeRemovalObserver(), this.actions.endDrag()) }, this.options = new hm(r, n), this.actions = t.getActions(), this.monitor = t.getMonitor(), this.sourceNodes = new Map, this.sourcePreviewNodes = new Map, this.sourcePreviewNodeOptions = new Map, this.targetNodes = new Map, this.listenerTypes = [], this._mouseClientOffset = {}, this._isScrolling = !1, this.options.enableMouseEvents && this.listenerTypes.push(Qt.mouse), this.options.enableTouchEvents && this.listenerTypes.push(Qt.touch), this.options.enableKeyboardEvents && this.listenerTypes.push(Qt.keyboard) } } const Cm = function (t, n = {}, r = {}) { return new Cr(t, n, r) }, Ur = "abcdefgh".split(""), Ri = { a8: "bR", b8: "bN", c8: "bB", d8: "bQ", e8: "bK", f8: "bB", g8: "bN", h8: "bR", a7: "bP", b7: "bP", c7: "bP", d7: "bP", e7: "bP", f7: "bP", g7: "bP", h7: "bP", a2: "wP", b2: "wP", c2: "wP", d2: "wP", e2: "wP", f2: "wP", g2: "wP", h2: "wP", a1: "wR", b1: "wN", c1: "wB", d1: "wQ", e1: "wK", f1: "wB", g1: "wN", h1: "wR" }, km = { a: 0, b: 1, c: 2, d: 3, e: 4, f: 5, g: 6, h: 7 }, _m = { a: 7, b: 6, c: 5, d: 4, e: 3, f: 2, g: 1, h: 0 }, xm = [7, 6, 5, 4, 3, 2, 1, 0], Om = [0, 1, 2, 3, 4, 5, 6, 7], Ga = { wP: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: S.jsx("path", { d: "m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z", style: { opacity: "1", fill: "#ffffff", fillOpacity: "1", fillRule: "nonzero", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "miter", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }) })), wR: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: S.jsxs("g", Object.assign({ style: { opacity: "1", fill: "#ffffff", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [S.jsx("path", { d: "M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z ", style: { strokeLinecap: "butt" } }), S.jsx("path", { d: "M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z ", style: { strokeLinecap: "butt" } }), S.jsx("path", { d: "M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14", style: { strokeLinecap: "butt" } }), S.jsx("path", { d: "M 34,14 L 31,17 L 14,17 L 11,14" }), S.jsx("path", { d: "M 31,17 L 31,29.5 L 14,29.5 L 14,17", style: { strokeLinecap: "butt", strokeLinejoin: "miter" } }), S.jsx("path", { d: "M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5" }), S.jsx("path", { d: "M 11,14 L 34,14", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } })] })) })), wN: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: S.jsxs("g", Object.assign({ style: { opacity: "1", fill: "none", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [S.jsx("path", { d: "M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18", style: { fill: "#ffffff", stroke: "#000000" } }), S.jsx("path", { d: "M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10", style: { fill: "#ffffff", stroke: "#000000" } }), S.jsx("path", { d: "M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z", style: { fill: "#000000", stroke: "#000000" } }), S.jsx("path", { d: "M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z", transform: "matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)", style: { fill: "#000000", stroke: "#000000" } })] })) })), wB: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: S.jsxs("g", Object.assign({ style: { opacity: "1", fill: "none", fillRule: "evenodd", fillOpacity: "1", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [S.jsxs("g", Object.assign({ style: { fill: "#ffffff", stroke: "#000000", strokeLinecap: "butt" } }, { children: [S.jsx("path", { d: "M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z" }), S.jsx("path", { d: "M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" }), S.jsx("path", { d: "M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" })] })), S.jsx("path", { d: "M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } })] })) })), wQ: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: S.jsxs("g", Object.assign({ style: { fill: "#ffffff", stroke: "#000000", strokeWidth: "1.5", strokeLinejoin: "round" } }, { children: [S.jsx("path", { d: "M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z" }), S.jsx("path", { d: "M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 11,36 11,36 C 9.5,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z" }), S.jsx("path", { d: "M 11.5,30 C 15,29 30,29 33.5,30", style: { fill: "none" } }), S.jsx("path", { d: "M 12,33.5 C 18,32.5 27,32.5 33,33.5", style: { fill: "none" } }), S.jsx("circle", { cx: "6", cy: "12", r: "2" }), S.jsx("circle", { cx: "14", cy: "9", r: "2" }), S.jsx("circle", { cx: "22.5", cy: "8", r: "2" }), S.jsx("circle", { cx: "31", cy: "9", r: "2" }), S.jsx("circle", { cx: "39", cy: "12", r: "2" })] })) })), wK: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: S.jsxs("g", Object.assign({ style: { fill: "none", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [S.jsx("path", { d: "M 22.5,11.63 L 22.5,6", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } }), S.jsx("path", { d: "M 20,8 L 25,8", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } }), S.jsx("path", { d: "M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25", style: { fill: "#ffffff", stroke: "#000000", strokeLinecap: "butt", strokeLinejoin: "miter" } }), S.jsx("path", { d: "M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37", style: { fill: "#ffffff", stroke: "#000000" } }), S.jsx("path", { d: "M 12.5,30 C 18,27 27,27 32.5,30", style: { fill: "none", stroke: "#000000" } }), S.jsx("path", { d: "M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5", style: { fill: "none", stroke: "#000000" } }), S.jsx("path", { d: "M 12.5,37 C 18,34 27,34 32.5,37", style: { fill: "none", stroke: "#000000" } })] })) })), bP: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: S.jsx("path", { d: "m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z", style: { opacity: "1", fill: "#000000", fillOpacity: "1", fillRule: "nonzero", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "miter", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }) })), bR: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: S.jsxs("g", Object.assign({ style: { opacity: "1", fill: "#000000", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [S.jsx("path", { d: "M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z ", style: { strokeLinecap: "butt" } }), S.jsx("path", { d: "M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z ", style: { strokeLinecap: "butt" } }), S.jsx("path", { d: "M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z ", style: { strokeLinecap: "butt" } }), S.jsx("path", { d: "M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z ", style: { strokeLinecap: "butt", strokeLinejoin: "miter" } }), S.jsx("path", { d: "M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z ", style: { strokeLinecap: "butt" } }), S.jsx("path", { d: "M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z ", style: { strokeLinecap: "butt" } }), S.jsx("path", { d: "M 12,35.5 L 33,35.5 L 33,35.5", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } }), S.jsx("path", { d: "M 13,31.5 L 32,31.5", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } }), S.jsx("path", { d: "M 14,29.5 L 31,29.5", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } }), S.jsx("path", { d: "M 14,16.5 L 31,16.5", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } }), S.jsx("path", { d: "M 11,14 L 34,14", style: { fill: "none", stroke: "#ffffff", strokeWidth: "1", strokeLinejoin: "miter" } })] })) })), bN: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: S.jsxs("g", Object.assign({ style: { opacity: "1", fill: "none", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [S.jsx("path", { d: "M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18", style: { fill: "#000000", stroke: "#000000" } }), S.jsx("path", { d: "M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10", style: { fill: "#000000", stroke: "#000000" } }), S.jsx("path", { d: "M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z", style: { fill: "#ffffff", stroke: "#ffffff" } }), S.jsx("path", { d: "M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z", transform: "matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)", style: { fill: "#ffffff", stroke: "#ffffff" } }), S.jsx("path", { d: "M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z ", style: { fill: "#ffffff", stroke: "none" } })] })) })), bB: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: S.jsxs("g", Object.assign({ style: { opacity: "1", fill: "none", fillRule: "evenodd", fillOpacity: "1", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [S.jsxs("g", Object.assign({ style: { fill: "#000000", stroke: "#000000", strokeLinecap: "butt" } }, { children: [S.jsx("path", { d: "M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z" }), S.jsx("path", { d: "M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z" }), S.jsx("path", { d: "M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z" })] })), S.jsx("path", { d: "M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18", style: { fill: "none", stroke: "#ffffff", strokeLinejoin: "miter" } })] })) })), bQ: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: S.jsxs("g", Object.assign({ style: { fill: "#000000", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" } }, { children: [S.jsx("path", { d: "M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z", style: { strokeLinecap: "butt", fill: "#000000" } }), S.jsx("path", { d: "m 9,26 c 0,2 1.5,2 2.5,4 1,1.5 1,1 0.5,3.5 -1.5,1 -1,2.5 -1,2.5 -1.5,1.5 0,2.5 0,2.5 6.5,1 16.5,1 23,0 0,0 1.5,-1 0,-2.5 0,0 0.5,-1.5 -1,-2.5 -0.5,-2.5 -0.5,-2 0.5,-3.5 1,-2 2.5,-2 2.5,-4 -8.5,-1.5 -18.5,-1.5 -27,0 z" }), S.jsx("path", { d: "M 11.5,30 C 15,29 30,29 33.5,30" }), S.jsx("path", { d: "m 12,33.5 c 6,-1 15,-1 21,0" }), S.jsx("circle", { cx: "6", cy: "12", r: "2" }), S.jsx("circle", { cx: "14", cy: "9", r: "2" }), S.jsx("circle", { cx: "22.5", cy: "8", r: "2" }), S.jsx("circle", { cx: "31", cy: "9", r: "2" }), S.jsx("circle", { cx: "39", cy: "12", r: "2" }), S.jsx("path", { d: "M 11,38.5 A 35,35 1 0 0 34,38.5", style: { fill: "none", stroke: "#000000", strokeLinecap: "butt" } }), S.jsxs("g", Object.assign({ style: { fill: "none", stroke: "#ffffff" } }, { children: [S.jsx("path", { d: "M 11,29 A 35,35 1 0 1 34,29" }), S.jsx("path", { d: "M 12.5,31.5 L 32.5,31.5" }), S.jsx("path", { d: "M 11.5,34.5 A 35,35 1 0 0 33.5,34.5" }), S.jsx("path", { d: "M 10.5,37.5 A 35,35 1 0 0 34.5,37.5" })] }))] })) })), bK: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", width: "45", height: "45" }, { children: S.jsxs("g", Object.assign({ style: { fill: "none", fillOpacity: "1", fillRule: "evenodd", stroke: "#000000", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round", strokeMiterlimit: "4", strokeDasharray: "none", strokeOpacity: "1" } }, { children: [S.jsx("path", { d: "M 22.5,11.63 L 22.5,6", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" }, id: "path6570" }), S.jsx("path", { d: "M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25", style: { fill: "#000000", fillOpacity: "1", strokeLinecap: "butt", strokeLinejoin: "miter" } }), S.jsx("path", { d: "M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37", style: { fill: "#000000", stroke: "#000000" } }), S.jsx("path", { d: "M 20,8 L 25,8", style: { fill: "none", stroke: "#000000", strokeLinejoin: "miter" } }), S.jsx("path", { d: "M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.5,26.6 L 22.5,24.5 C 20,18 10.85,14 6.97,19.85 C 4.5,25.5 13,29.5 13,29.5", style: { fill: "none", stroke: "#ffffff" } }), S.jsx("path", { d: "M 12.5,30 C 18,27 27,27 32.5,30 M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5 M 12.5,37 C 18,34 27,34 32.5,37", style: { fill: "none", stroke: "#ffffff" } })] })) })) }; function wl(e, t, n) { const r = t / 8, i = e === "white" ? km : _m, o = e === "white" ? xm : Om, s = i[n[0]] * r + r / 2, l = o[parseInt(n[1], 10) - 1] * r + r / 2; return { x: s, y: l } } function Ya(e) { let t = !1; return Object.keys(Ri).forEach(n => { e[n] !== Ri[n] && (t = !0) }), Object.keys(e).forEach(n => { Ri[n] !== e[n] && (t = !0) }), t } function Tm(e, t) { const n = { removed: {}, added: {} }; return Object.keys(e).forEach(r => { t[r] !== e[r] && (n.removed[r] = e[r]) }), Object.keys(t).forEach(r => { e[r] !== t[r] && (n.added[r] = t[r]) }), n } function Xa(e) { return e === "start" ? Ri : typeof e == "string" ? Dm(e) : e } function Dm(e) { if (!Pm(e)) return {}; e = e.replace(/ .+$/, ""); const t = e.split("/"), n = {}; let r = 8; for (let i = 0; i < 8; i++) { const o = t[i].split(""); let s = 0; for (let l = 0; l < o.length; l++)if (o[l].search(/[1-8]/) !== -1) { const u = parseInt(o[l], 10); s = s + u } else { const u = Ur[s] + r; n[u] = Im(o[l]), s = s + 1 } r = r - 1 } return n } function Pm(e) { e = e.replace(/ .+$/, ""), e = Nm(e); const t = e.split("/"); if (t.length !== 8) return !1; for (let n = 0; n < 8; n++)if (t[n].length !== 8 || t[n].search(/[^kqrnbpKQRNBP1]/) !== -1) return !1; return !0 } function Nm(e) { return e.replace(/8/g, "11111111").replace(/7/g, "1111111").replace(/6/g, "111111").replace(/5/g, "11111").replace(/4/g, "1111").replace(/3/g, "111").replace(/2/g, "11") } function Im(e) { return e.toLowerCase() === e ? "b" + e.toUpperCase() : "w" + e.toUpperCase() } const Lm = (e, t = !0, n, r) => { const [i, o] = C.useState([]), [s, l] = C.useState([]), [u, a] = C.useState(); C.useEffect(() => { Array.isArray(e) && o(e == null ? void 0 : e.filter(m => m[0] !== m[1])) }, [e]), C.useEffect(() => { n == null || n(s) }, [s]); function g() { l([]), a(void 0) } const p = (m, v) => { t && a([m, v, r]) }, f = [...s, ...i]; return { arrows: f, newArrow: u, clearArrows: g, drawNewArrow: p, setArrows: l, onArrowDrawEnd: (m, v) => { if (m === v || !t) return; let E; const d = [m, v, r]; f.every(([h, w]) => !(h === m && w === v)) ? E = [...s, d] : E = s.filter(([h, w]) => !(h === m && w === v)), a(void 0), l(E) } } }, Vf = C.createContext({}), _t = () => C.useContext(Vf), jm = C.forwardRef(({ allowDragOutsideBoard: e = !0, animationDuration: t = 300, areArrowsAllowed: n = !0, arePiecesDraggable: r = !0, arePremovesAllowed: i = !1, autoPromoteToQueen: o = !1, boardOrientation: s = "white", boardWidth: l, children: u, clearPremovesOnRightClick: a = !0, customArrows: g, customArrowColor: p = "rgb(255,170,0)", customBoardStyle: f, customDarkSquareStyle: y = { backgroundColor: "#B58863" }, customDropSquareStyle: m = { boxShadow: "inset 0 0 1px 6px rgba(255,255,255,0.75)" }, customLightSquareStyle: v = { backgroundColor: "#F0D9B5" }, customPieces: E, customPremoveDarkSquareStyle: d = { backgroundColor: "#A42323" }, customPremoveLightSquareStyle: c = { backgroundColor: "#BD2828" }, customSquare: h = "div", customSquareStyles: w, dropOffBoardAction: k = "snapback", id: O = 0, isDraggablePiece: x = () => !0, getPositionObject: T = () => { }, onArrowsChange: z = () => { }, onDragOverSquare: M = () => { }, onMouseOutSquare: $ = () => { }, onMouseOverSquare: K = () => { }, onPieceClick: Ae = () => { }, onPieceDragBegin: be = () => { }, onPieceDragEnd: qe = () => { }, onPieceDrop: Ee = () => !0, onPromotionCheck: dt = (Jt, xt, qr) => (qr === "wP" && Jt[1] === "7" && xt[1] === "8" || qr === "bP" && Jt[1] === "2" && xt[1] === "1") && Math.abs(Jt.charCodeAt(0) - xt.charCodeAt(0)) <= 1, onPromotionPieceSelect: D, onSquareClick: N = () => { }, onSquareRightClick: j = () => { }, position: H = "start", promotionDialogVariant: X = "default", promotionToSquare: ot = null, showBoardNotation: A = !0, showPromotionDialog: ft = !1, snapToCursor: Ge = !0 }, vn) => { const [Jt, xt] = C.useState(Xa(H)), [qr, Jf] = C.useState({ removed: {}, added: {} }), [Po, yn] = C.useState(void 0), [Zf, No] = C.useState(ft && !o), [eh, Eu] = C.useState(null), [th, Io] = C.useState(ot), [Cu, Lo] = C.useState([]), Ot = C.useRef(Cu), [jo, Gr] = C.useState(), [nh, rh] = C.useState(Object.assign(Object.assign({}, Ga), E)), [ih, Yr] = C.useState(!1), [Ro, oh] = C.useState(), [Xr, Jr] = C.useState(!1); C.useImperativeHandle(vn, () => ({ clearPremoves(ee = !0) { Zr(ee) } })), C.useEffect(() => { rh(Object.assign(Object.assign({}, Ga), E)) }, [E]), C.useEffect(() => { No(ft), Io(ot) }, [ot, ft]), C.useEffect(() => { var ee, de, Ye; bo(); const De = Xa(H), ht = Tm(Jt, De), Xe = ((ee = Object.keys(ht.added)) === null || ee === void 0 ? void 0 : ee.length) <= 2 ? (Ye = (de = Object.entries(ht.added)) === null || de === void 0 ? void 0 : de[0]) === null || Ye === void 0 ? void 0 : Ye[1][0] : void 0; if (Xr) xt(De), Jr(!1), i && Ao(Xe), Ro && clearTimeout(Ro); else if (ih) xt(De), Jr(!1), i && Ao(Xe); else { Ya(De) && Po !== void 0 ? yn(Xe) : Ya(De) ? yn(void 0) : yn("b"), Jf(ht), Jr(!0); const gh = setTimeout(() => { xt(De), Jr(!1), i && Ao(Xe) }, t); oh(gh) } return Yr(!1), T(De), Mo(), () => { clearTimeout(Ro) } }, [H]); const { arrows: sh, newArrow: lh, clearArrows: Mo, drawNewArrow: uh, onArrowDrawEnd: ah } = Lm(g, n, z, p); function ch(ee, de, Ye, De) { if (ee === de) return; if (Mo(), i && Xr || i && (Po === Ye[0] || Ot.current.filter(Xe => Xe.piece[0] === Ye[0]).length > 0)) { const Xe = [...Ot.current]; Xe.push({ sourceSq: ee, targetSq: de, piece: Ye }), Ot.current = Xe, Lo([...Xe]), bo(); return } if (!i && Xr) return; const ht = Object.assign({}, Jt); Yr(!!De), yn(Ye[0]), Ee.length ? Ee(ee, de, Ye) || (Zr(), Yr(!1)) : (k === "trash" && !de && delete ht[ee], delete ht[ee], ht[de] = Ye, xt(ht)), bo(), T(ht) } function Ao(ee) { if (Ot.current.length === 0) return; const de = Ot.current[0]; if (de.piece[0] !== void 0 && de.piece[0] !== ee && Ee.length) if (yn(de.piece[0]), Yr(!0), Ee(de.sourceSq, de.targetSq, de.piece)) { const De = [...Ot.current]; De.shift(), Ot.current = De, Lo([...De]) } else Zr() } function Zr(ee = !0) { ee && yn(void 0), Ot.current = [], Lo([]) } function bo() { Eu(null), Io(null), No(!1) } function dh(ee) { Gr(ee) } function fh(ee) { if (jo) { if (jo === ee) { Gr(void 0), a && Zr(!1), j(ee); return } } else Gr(void 0) } function hh() { Gr(void 0) } const ph = { animationDuration: t, arePiecesDraggable: r, arePremovesAllowed: i, boardOrientation: s, boardWidth: l, customArrowColor: p, customBoardStyle: f, customDarkSquareStyle: y, customDropSquareStyle: m, customLightSquareStyle: v, customPremoveDarkSquareStyle: d, customPremoveLightSquareStyle: c, customSquare: h, customSquareStyles: w, id: O, isDraggablePiece: x, onDragOverSquare: M, onMouseOutSquare: $, onMouseOverSquare: K, onPieceClick: Ae, onPieceDragBegin: be, onPieceDragEnd: qe, onPieceDrop: Ee, onPromotionCheck: dt, onPromotionPieceSelect: D, onSquareClick: N, showBoardNotation: A, snapToCursor: Ge, promotionDialogVariant: X, allowDragOutsideBoard: e, arrows: sh, newArrow: lh, onArrowDrawEnd: ah, chessPieces: nh, clearArrows: Mo, drawNewArrow: uh, clearCurrentRightClickDown: hh, currentPosition: Jt, handleSetPosition: ch, isWaitingForAnimation: Xr, lastPieceColour: Po, onRightClickDown: dh, onRightClickUp: fh, positionDifferences: qr, promoteFromSquare: eh, promoteToSquare: th, premoves: Cu, setPromoteFromSquare: Eu, setPromoteToSquare: Io, setShowPromoteDialog: No, showPromoteDialog: Zf, autoPromoteToQueen: o, currentRightClickDown: jo }; return S.jsx(Vf.Provider, Object.assign({ value: ph }, { children: u })) }); function Rm({ row: e, col: t }) { const { boardOrientation: n, boardWidth: r, customDarkSquareStyle: i, customLightSquareStyle: o } = _t(), s = o.backgroundColor, l = i.backgroundColor, u = t === 0, a = e === 7, g = u && a; function p() { return n === "white" ? 8 - e : e + 1 } function f() { return n === "black" ? Ur[7 - t] : Ur[t] } function y() { return S.jsxs(S.Fragment, { children: [S.jsx("div", Object.assign({ style: Object.assign(Object.assign({ zIndex: 3, position: "absolute" }, { color: s }), Za(r)) }, { children: p() })), S.jsx("div", Object.assign({ style: Object.assign(Object.assign({ zIndex: 3, position: "absolute" }, { color: s }), Ja(r)) }, { children: f() }))] }) } function m() { return S.jsx("div", Object.assign({ style: Object.assign(Object.assign({ userSelect: "none", zIndex: 3, position: "absolute" }, { color: t % 2 !== 0 ? l : s }), Ja(r)) }, { children: f() })) } function v() { return S.jsx("div", Object.assign({ style: Object.assign(Object.assign({ userSelect: "none", zIndex: 3, position: "absolute" }, n === "black" ? { color: e % 2 === 0 ? l : s } : { color: e % 2 === 0 ? l : s }), Za(r)) }, { children: p() })) } return g ? y() : a ? m() : u ? v() : null } const Ja = e => ({ alignSelf: "flex-end", paddingLeft: e / 8 - e / 48, fontSize: e / 48 }), Za = e => ({ alignSelf: "flex-start", paddingRight: e / 8 - e / 48, fontSize: e / 48 }); function ec({ isPremovedPiece: e = !1, piece: t, square: n, squares: r }) { const { animationDuration: i, arePiecesDraggable: o, arePremovesAllowed: s, boardWidth: l, boardOrientation: u, chessPieces: a, currentPosition: g, id: p, isDraggablePiece: f, isWaitingForAnimation: y, onPieceClick: m, onPieceDragBegin: v, onPieceDragEnd: E, positionDifferences: d, premoves: c, onPromotionCheck: h } = _t(), [w, k] = C.useState({ opacity: 1, zIndex: 5, touchAction: "none", cursor: o && f({ piece: t, sourceSquare: n }) ? "-webkit-grab" : "default" }), [{ canDrag: O, isDragging: x }, T, z] = H1(() => ({ type: "piece", item: () => (v(t, n), { piece: t, square: n, id: p }), end: () => E(t, n), collect: $ => ({ canDrag: f({ piece: t, sourceSquare: n }), isDragging: !!$.isDragging() }) }), [t, n, g, p]); z(dm(), { captureDraggingState: !0 }), C.useEffect(() => { k($ => Object.assign(Object.assign({}, $), { opacity: x ? 0 : 1 })) }, [x]), C.useEffect(() => { if (!s) return; let $ = !1; !e && c.find(K => K.targetSq === n) && ($ = !0), c.find(K => K.sourceSq === n && K.piece === t) && ($ = !0), k(K => Object.assign(Object.assign({}, K), { display: $ ? "none" : "unset" })) }, [g, c]), C.useEffect(() => { var $; const K = ($ = d.removed) === null || $ === void 0 ? void 0 : $[n]; if (!d.added || !K) return; const Ae = Object.entries(d.added).find(([be, qe]) => qe === K || h(n, be, K)); if (y && K && Ae && !e) { const be = n, qe = Ae[0]; if (be && qe) { const Ee = l / 8; k(dt => Object.assign(Object.assign({}, dt), { transform: `translate(${(u === "black" ? -1 : 1) * (qe.charCodeAt(0) - be.charCodeAt(0)) * Ee}px, ${(u === "black" ? -1 : 1) * (Number(be[1]) - Number(qe[1])) * Ee}px)`, transition: `transform ${i}ms`, zIndex: 6 })) } } }, [d]), C.useEffect(() => { const { sourceSq: $ } = M(); $ && k(K => Object.assign(Object.assign({}, K), { transform: "translate(0px, 0px)", transition: "transform 0ms" })) }, [g]), C.useEffect(() => { k($ => Object.assign(Object.assign({}, $), { cursor: o && f({ piece: t, sourceSquare: n }) ? "-webkit-grab" : "default" })) }, [n, g, o]); function M() { return { sourceSq: r[n] } } return S.jsx("div", Object.assign({ ref: o && O ? T : null, onClick: () => m(t), "data-piece": t, style: w }, { children: typeof a[t] == "function" ? a[t]({ squareWidth: l / 8, isDragging: x, square: n }) : S.jsx("svg", Object.assign({ viewBox: "1 1 43 43", width: l / 8, height: l / 8 }, { children: S.jsx("g", { children: a[t] }) })) })) } function Mm({ square: e, squareColor: t, setSquares: n, squareHasPremove: r, children: i }) { const o = C.useRef(null), { autoPromoteToQueen: s, boardWidth: l, boardOrientation: u, clearArrows: a, currentPosition: g, currentRightClickDown: p, customBoardStyle: f, customDarkSquareStyle: y, customDropSquareStyle: m, customLightSquareStyle: v, customPremoveDarkSquareStyle: E, customPremoveLightSquareStyle: d, customSquare: c, customSquareStyles: h, drawNewArrow: w, handleSetPosition: k, isWaitingForAnimation: O, lastPieceColour: x, onArrowDrawEnd: T, onDragOverSquare: z, onMouseOutSquare: M, onMouseOverSquare: $, onPieceDrop: K, onPromotionCheck: Ae, onRightClickDown: be, onRightClickUp: qe, onSquareClick: Ee, setPromoteFromSquare: dt, setPromoteToSquare: D, setShowPromoteDialog: N } = _t(), [{ isOver: j }, H] = X1(() => ({ accept: "piece", drop: X, collect: A => ({ isOver: !!A.isOver() }) }), [e, g, K, O, x]); function X(A) { Ae(A.square, e, A.piece) ? s ? k(A.square, e, A.piece[0] === "w" ? "wQ" : "bQ") : (dt(A.square), D(e), N(!0)) : k(A.square, e, A.piece, !0) } C.useEffect(() => { if (o.current) { const { x: A, y: ft } = o.current.getBoundingClientRect(); n(Ge => Object.assign(Object.assign({}, Ge), { [e]: { x: A, y: ft } })) } }, [l, u]); const ot = Object.assign(Object.assign(Object.assign(Object.assign({}, Am(e, u, f)), t === "black" ? y : v), r && (t === "black" ? E : d)), j && m); return S.jsx("div", Object.assign({ ref: H, style: ot, "data-square-color": t, "data-square": e, onMouseOver: A => { A.buttons === 2 && p && w(p, e), !(A.relatedTarget && A.currentTarget.contains(A.relatedTarget)) && $(e) }, onMouseOut: A => { A.relatedTarget && A.currentTarget.contains(A.relatedTarget) || M(e) }, onMouseDown: A => { A.button === 2 && be(e) }, onMouseUp: A => { A.button === 2 && (p && T(p, e), qe(e)) }, onDragEnter: () => z(e), onClick: () => { Ee(e), a() }, onContextMenu: A => { A.preventDefault() } }, { children: typeof c == "string" ? S.jsx(c, Object.assign({ ref: o, style: Object.assign(Object.assign(Object.assign({}, nc(l)), tc), !r && (h == null ? void 0 : h[e])) }, { children: i })) : S.jsx(c, Object.assign({ ref: o, square: e, squareColor: t, style: Object.assign(Object.assign(Object.assign({}, nc(l)), tc), !r && (h == null ? void 0 : h[e])) }, { children: i })) })) } const tc = { display: "flex", justifyContent: "center" }, nc = e => ({ width: e / 8, height: e / 8 }), Am = (e, t, n) => n != null && n.borderRadius ? e === "a1" ? t === "white" ? { borderBottomLeftRadius: n.borderRadius } : { borderTopRightRadius: n.borderRadius } : e === "a8" ? t === "white" ? { borderTopLeftRadius: n.borderRadius } : { borderBottomRightRadius: n.borderRadius } : e === "h1" ? t === "white" ? { borderBottomRightRadius: n.borderRadius } : { borderTopLeftRadius: n.borderRadius } : e === "h8" ? t === "white" ? { borderTopRightRadius: n.borderRadius } : { borderBottomLeftRadius: n.borderRadius } : {} : {}; function bm() { const [e, t] = C.useState({}), { boardOrientation: n, boardWidth: r, currentPosition: i, id: o, premoves: s, showBoardNotation: l } = _t(); return S.jsx("div", Object.assign({ "data-boardid": o }, { children: [...Array(8)].map((u, a) => S.jsx("div", Object.assign({ style: { display: "flex", flexWrap: "nowrap", width: r } }, { children: [...Array(8)].map((g, p) => { const f = n === "black" ? Ur[7 - p] + (a + 1) : Ur[p] + (8 - a), y = p % 2 === a % 2 ? "white" : "black", m = s.find(E => E.sourceSq === f || E.targetSq === f), v = s.find(E => E.targetSq === f); return S.jsxs(Mm, Object.assign({ square: f, squareColor: y, setSquares: t, squareHasPremove: !!m }, { children: [i[f] && S.jsx(ec, { piece: i[f], square: f, squares: e }), v && S.jsx(ec, { isPremovedPiece: !0, piece: v.piece, square: f, squares: e }), l && S.jsx(Rm, { row: a, col: p })] }), `${p}${a}`) }) }), a.toString())) })) } const zm = () => { const { arrows: e, newArrow: t, boardOrientation: n, boardWidth: r, customArrowColor: i } = _t(), o = [...e, t].filter(Boolean); return S.jsx("svg", Object.assign({ width: r, height: r, style: { position: "absolute", top: "0", left: "0", pointerEvents: "none", zIndex: "10" } }, { children: o.map((s, l) => { const [u, a, g] = s; if (u === a) return null; const p = wl(n, r, u), f = wl(n, r, a); let y = r / 32; const m = l === e.length; e.some(h => h[0] !== u && h[1] === a) && !m && (y = r / 16); const v = f.x - p.x, E = f.y - p.y, d = Math.hypot(E, v), c = { x: p.x + v * (d - y) / d, y: p.y + E * (d - y) / d }; return S.jsxs(C.Fragment, { children: [S.jsx("marker", Object.assign({ id: `arrowhead-${l}`, markerWidth: "2", markerHeight: "2.5", refX: "1.25", refY: "1.25", orient: "auto" }, { children: S.jsx("polygon", { points: "0.3 0, 2 1.25, 0.3 2.5", fill: g ?? i }) })), S.jsx("line", { x1: p.x, y1: p.y, x2: c.x, y2: c.y, opacity: m ? "0.5" : "0.65", stroke: g ?? i, strokeWidth: m ? .9 * r / 40 : r / 40, markerEnd: `url(#arrowhead-${l})` })] }, `${u}-${a}${m ? "-active" : ""}`) }) })) }; function Fm({ option: e }) { const [t, n] = C.useState(!1), { boardWidth: r, chessPieces: i, customDarkSquareStyle: o, customLightSquareStyle: s, handleSetPosition: l, onPromotionPieceSelect: u, promoteFromSquare: a, promoteToSquare: g, promotionDialogVariant: p } = _t(), f = () => { switch (e[1]) { case "Q": return o.backgroundColor; case "R": return s.backgroundColor; case "N": return p === "default" ? s.backgroundColor : o.backgroundColor; case "B": return p === "default" ? o.backgroundColor : s.backgroundColor } }; return S.jsx("div", Object.assign({ onClick: () => { u != null && u.length ? u(e) : l(a, g, e, !0) }, onMouseOver: () => n(!0), onMouseOut: () => n(!1), "data-piece": e, style: { cursor: "pointer", backgroundColor: t ? f() : `${f()}aa`, borderRadius: "4px", transition: "all 0.1s ease-out" } }, { children: typeof i[e] == "function" ? S.jsx("div", Object.assign({ style: { transition: "all 0.1s ease-out", transform: t ? "scale(1)" : "scale(0.85)" } }, { children: i[e]({ squareWidth: r / 8, isDragging: !1 }) })) : S.jsx("svg", Object.assign({ viewBox: "1 1 43 43", width: r / 8, height: r / 8, style: { transition: "all 0.1s ease-out", transform: t ? "scale(1)" : "scale(0.85)" } }, { children: S.jsx("g", { children: i[e] }) })) })) } function $m() { const { boardOrientation: e, boardWidth: t, promotionDialogVariant: n, promoteToSquare: r } = _t(), i = (r == null ? void 0 : r[1]) === "1" ? "b" : "w", o = [`${i ?? "w"}Q`, `${i ?? "w"}R`, `${i ?? "w"}N`, `${i ?? "w"}B`], s = { default: { display: "grid", gridTemplateColumns: "1fr 1fr", transform: `translate(${-t / 8}px, ${-t / 8}px)` }, vertical: { transform: `translate(${-t / 16}px, ${-t / 16}px)` }, modal: { display: "flex", justifyContent: "center", alignItems: "center", transform: `translate(0px, ${3 * t / 8}px)`, width: "100%", height: `${t / 4}px`, top: 0, backgroundColor: "white", left: 0 } }, l = wl(e, t, r || "a8"); return S.jsx("div", Object.assign({ style: Object.assign({ position: "absolute", top: `${l == null ? void 0 : l.y}px`, left: `${l == null ? void 0 : l.x}px`, zIndex: 1e3 }, s[n]), title: "Choose promotion piece" }, { children: o.map(u => S.jsx(Fm, { option: u }, u)) })) } const Um = { whiteKing: S.jsx("svg", Object.assign({ xmlns: "http://www.w3.org/2000/svg", version: "1.1", style: { shapeRendering: "geometricPrecision", textRendering: "geometricPrecision", imageRendering: "crisp-edges" }, viewBox: "0 0 4210 12970", x: "0px", y: "0px", fillRule: "evenodd", clipRule: "evenodd", width: "250", height: "250" }, { children: S.jsx("g", { children: S.jsx("path", { style: { fill: "black", fillRule: "nonzero" }, d: "M2105 0c169,0 286,160 249,315l200 0c-172,266 -231,479 -256,792 315,-24 530,-86 792,-255l0 897c-265,-171 -479,-231 -792,-256 18,234 75,495 185,682l339 0c233,0 369,269 225,456l545 0 -595 1916c130,94 158,275 59,402 465,0 416,568 51,568l-334 0 465 2867 332 0c250,0 381,306 199,485 162,63 273,220 273,399l0 633 168 0 0 475c-1403,0 -2807,0 -4210,0l0 -475 167 0 0 -633c0,-179 112,-336 274,-399 -181,-178 -52,-485 199,-485l332 0 465 -2867 -335 0c-353,0 -418,-568 51,-568 -98,-127 -70,-308 59,-402l-594 -1916c181,0 363,0 545,0 -144,-187 -9,-456 225,-456l339 0c110,-187 167,-448 185,-682 -315,25 -530,87 -793,256l0 -897c266,171 480,231 793,255 -25,-315 -87,-529 -256,-792l199 0c-36,-155 81,-315 250,-315zm-1994 10012l0 253 3988 0 0 -253c-1330,0 -2659,0 -3988,0zm484 -1060c-174,0 -316,142 -316,316l0 633 3652 0 0 -633c0,-174 -142,-316 -316,-316 -1007,0 -2013,0 -3020,0zm45 -457c-230,0 -225,345 0,345l2930 0c230,0 225,-345 0,-345 -977,0 -1953,0 -2930,0zm2020 -2978l-1111 0 -465 2867 2041 0 -465 -2867zm-1558 -456c-229,0 -224,345 0,345 669,0 1337,0 2005,0 230,0 225,-345 0,-345 -668,0 -1336,0 -2005,0zm1730 -457l-1454 0c-229,0 -224,345 0,345l1454 0c229,0 224,-345 0,-345zm-2064 -1862l544 1751c529,0 1057,0 1586,0l544 -1751c-892,0 -1783,0 -2674,0zm1085 -567l504 0c-126,-247 -163,-526 -177,-800 273,15 553,52 800,177l0 -504c-247,126 -527,163 -800,177 14,-273 51,-552 177,-799 -168,0 -336,0 -504,0 125,247 162,526 177,799 -274,-14 -553,-51 -800,-177l0 504c247,-125 527,-162 800,-177 -15,274 -52,553 -177,800zm969 111l-1434 0c-230,0 -225,345 0,345l1434 0c230,0 225,-345 0,-345zm-717 -2175c-105,0 -175,109 -133,204l266 0c42,-96 -30,-205 -133,-204z" }) }) })) }; function Hm({ children: e }) { try { return S.jsx(S.Fragment, { children: e }) } catch (t) { return console.log(t), S.jsx(Qf, { showError: !0 }) } } function Qf({ showError: e = !1 }) { return S.jsxs("div", Object.assign({ style: { display: "flex", justifyContent: "center", alignItems: "center", flexDirection: "column" } }, { children: [S.jsx("div", Object.assign({ style: { width: 250, height: 250, transform: "rotate(90deg)" } }, { children: Um.whiteKing })), e && S.jsx("h1", { children: "Something went wrong" })] })) } function Wm() { const e = C.useRef(null), { boardWidth: t, clearCurrentRightClickDown: n, onPromotionPieceSelect: r, setShowPromoteDialog: i, showPromoteDialog: o, customBoardStyle: s } = _t(); return C.useEffect(() => { function l(u) { e.current && !e.current.contains(u.target) && n() } return document.addEventListener("mouseup", l), () => { document.removeEventListener("mouseup", l) } }, []), t ? S.jsx("div", Object.assign({ style: { perspective: "1000px" } }, { children: S.jsxs("div", Object.assign({ ref: e, style: Object.assign(Object.assign({ position: "relative" }, Bm(t)), s) }, { children: [S.jsx(bm, {}), S.jsx(zm, {}), o && S.jsxs(S.Fragment, { children: [S.jsx("div", { onClick: () => { i(!1), r == null || r() }, style: { position: "absolute", top: "0", left: "0", zIndex: "100", backgroundColor: "rgba(22,21,18,.7)", width: t, height: t } }), S.jsx($m, {})] })] })) })) : S.jsx(Qf, {}) } const Bm = e => ({ cursor: "default", height: e, width: e }); function Vm({ boardContainer: e }) { const { boardWidth: t, chessPieces: n, id: r, snapToCursor: i, allowDragOutsideBoard: o } = _t(), s = W1(f => ({ item: f.getItem(), clientOffset: f.getClientOffset(), sourceClientOffset: f.getSourceClientOffset(), isDragging: f.isDragging() })), { isDragging: l, item: u, clientOffset: a, sourceClientOffset: g } = s, p = C.useCallback((f, y) => { if (!f || !y) return { display: "none" }; let { x: m, y: v } = i ? f : y; const E = t / 8 / 2; if (i && (m -= E, v -= E), !o) { const { left: c, top: h } = e, w = c - E, k = h - E, O = c + t - E, x = h + t - E; m = Math.max(w, Math.min(m, O)), v = Math.max(k, Math.min(v, x)) } const d = `translate(${m}px, ${v}px)`; return { transform: d, WebkitTransform: d, touchAction: "none" } }, [t, o, i, e]); return l && u.id === r ? S.jsx("div", Object.assign({ style: { position: "fixed", pointerEvents: "none", zIndex: 10, left: 0, top: 0 } }, { children: S.jsx("div", Object.assign({ style: p(a, g) }, { children: typeof n[u.piece] == "function" ? n[u.piece]({ squareWidth: t / 8, isDragging: !0 }) : S.jsx("svg", Object.assign({ viewBox: "1 1 43 43", width: t / 8, height: t / 8 }, { children: S.jsx("g", { children: n[u.piece] }) })) })) })) : null } const Qm = C.forwardRef((e, t) => { const { customDndBackend: n, customDndBackendOptions: r } = e, i = r0(e, ["customDndBackend", "customDndBackendOptions"]), [o, s] = C.useState(), [l, u] = C.useState(!1), [a, g] = C.useState(!1), [p, f] = C.useState(e.boardWidth), y = C.useRef(null), m = C.useRef(null), [v, E] = C.useState({ left: 0, top: 0 }), d = C.useMemo(() => { var h; return (h = y.current) === null || h === void 0 ? void 0 : h.getBoundingClientRect() }, [y.current]); C.useEffect(() => { E({ left: d != null && d.left ? d == null ? void 0 : d.left : 0, top: d != null && d.top ? d == null ? void 0 : d.top : 0 }) }, [d]), C.useEffect(() => { g("ontouchstart" in window), u(!0), s(window) }, []), C.useEffect(() => { var h; if (e.boardWidth === void 0 && (!((h = y.current) === null || h === void 0) && h.offsetWidth)) { const w = new ResizeObserver(() => { var k; f((k = y.current) === null || k === void 0 ? void 0 : k.offsetWidth) }); return w.observe(y.current), () => { w.disconnect() } } }, [y.current, o]); const c = n || (a ? Cm : fm); return l && o ? S.jsx(Hm, { children: S.jsxs("div", Object.assign({ ref: m, style: { display: "flex", flexDirection: "column", width: "100%" } }, { children: [S.jsx("div", { ref: y, style: { width: "100%" } }), S.jsx(w1, Object.assign({ backend: c, context: o, options: n ? r : void 0 }, { children: p && S.jsxs(jm, Object.assign({ boardWidth: p }, i, { ref: t }, { children: [S.jsx(Vm, { boardContainer: v }), S.jsx(Wm, {})] })) }))] })) }) : null }); var rc = globalThis && globalThis.__awaiter || function (e, t, n, r) { function i(o) { return o instanceof n ? o : new n(function (s) { s(o) }) } return new (n || (n = Promise))(function (o, s) { function l(g) { try { a(r.next(g)) } catch (p) { s(p) } } function u(g) { try { a(r.throw(g)) } catch (p) { s(p) } } function a(g) { g.done ? o(g.value) : i(g.value).then(l, u) } a((r = r.apply(e, t || [])).next()) }) }; const Km = e => { const [t, n, r] = e.split(":"); return { process_name: t, package_name: n, publisher_node: r } }; function sr(e) { const t = document.cookie.split(";"); for (let n = 0; n < t.length; n++) { const r = t[n].trim(); if (r.startsWith(e)) return r.substring(e.length + 1) } } function ic(e) { const t = JSON.stringify(e); return new TextEncoder().encode(t) } class qm { constructor({ nodeId: t, processId: n, channelId: r, uri: i = `${window.location.protocol.replace("http", "ws")}//${window.location.host}/${n}/`, onMessage: o = () => null, onOpen: s = () => null, onClose: l = () => null, onError: u = () => null }) { this._encrypt = a => null, this._decrypt = a => { }, this.send = ({ data: a }) => { sr(`kinode-auth_${this.nodeId}`), sr(`kinode-ws-auth_${this.nodeId}`), this._ws.send(ic(a)) }, this.fetchJson = (a, g) => rc(this, void 0, void 0, function* () { return console.log("Fetching JSON:", a), yield (yield fetch(a, g)).json() }), this._secret = void 0, this.processId = Km(n), this.channelId = r, this.nodeId = t, this._ws = new WebSocket(i), this._ws.onmessage = a => rc(this, void 0, void 0, function* () { o(a.data, this) }), this._ws.onopen = a => { console.log(`${t}`, sr(`kinode-auth_${t}`), sr(`kinode-ws-auth_${t}`)), this._ws.send(ic({ auth_token: sr(`kinode-auth_${t}`), target_process: n, encrypted: !1 })), s(a, this) }, this._ws.onclose = l, this._ws.onerror = u } } const oc = e => { let t; const n = new Set, r = (u, a) => { const g = typeof u == "function" ? u(t) : u; if (!Object.is(g, t)) { const p = t; t = a ?? (typeof g != "object" || g === null) ? g : Object.assign({}, t, g), n.forEach(f => f(t, p)) } }, i = () => t, l = { setState: r, getState: i, subscribe: u => (n.add(u), () => n.delete(u)), destroy: () => { n.clear() } }; return t = e(r, i, l), l }, Gm = e => e ? oc(e) : oc; var Kf = { exports: {} }, qf = {}, Gf = { exports: {} }, Yf = {};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Qn = C; function Ym(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var Xm = typeof Object.is == "function" ? Object.is : Ym, Jm = Qn.useState, Zm = Qn.useEffect, ev = Qn.useLayoutEffect, tv = Qn.useDebugValue; function nv(e, t) { var n = t(), r = Jm({ inst: { value: n, getSnapshot: t } }), i = r[0].inst, o = r[1]; return ev(function () { i.value = n, i.getSnapshot = t, ws(i) && o({ inst: i }) }, [e, n, t]), Zm(function () { return ws(i) && o({ inst: i }), e(function () { ws(i) && o({ inst: i }) }) }, [e]), tv(n), n } function ws(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !Xm(e, n) } catch { return !0 } } function rv(e, t) { return t() } var iv = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? rv : nv; Yf.useSyncExternalStore = Qn.useSyncExternalStore !== void 0 ? Qn.useSyncExternalStore : iv; Gf.exports = Yf; var ov = Gf.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Do = C, sv = ov; function lv(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var uv = typeof Object.is == "function" ? Object.is : lv, av = sv.useSyncExternalStore, cv = Do.useRef, dv = Do.useEffect, fv = Do.useMemo, hv = Do.useDebugValue; qf.useSyncExternalStoreWithSelector = function (e, t, n, r, i) { var o = cv(null); if (o.current === null) { var s = { hasValue: !1, value: null }; o.current = s } else s = o.current; o = fv(function () { function u(y) { if (!a) { if (a = !0, g = y, y = r(y), i !== void 0 && s.hasValue) { var m = s.value; if (i(m, y)) return p = m } return p = y } if (m = p, uv(g, y)) return m; var v = r(y); return i !== void 0 && i(m, v) ? m : (g = y, p = v) } var a = !1, g, p, f = n === void 0 ? null : n; return [function () { return u(t()) }, f === null ? void 0 : function () { return u(f()) }] }, [t, n, r, i]); var l = av(e, o[0], o[1]); return dv(function () { s.hasValue = !0, s.value = l }, [l]), hv(l), l }; Kf.exports = qf; var pv = Kf.exports; const gv = uc(pv), { useDebugValue: mv } = yc, { useSyncExternalStoreWithSelector: vv } = gv; function yv(e, t = e.getState, n) { const r = vv(e.subscribe, e.getState, e.getServerState || e.getState, t, n); return mv(r), r } const sc = e => { const t = typeof e == "function" ? Gm(e) : e, n = (r, i) => yv(t, r, i); return Object.assign(n, t), n }, Sv = e => e ? sc(e) : sc; function Xf(e, t) { let n; try { n = e() } catch { return } return { getItem: i => { var o; const s = u => u === null ? null : JSON.parse(u, t == null ? void 0 : t.reviver), l = (o = n.getItem(i)) != null ? o : null; return l instanceof Promise ? l.then(s) : s(l) }, setItem: (i, o) => n.setItem(i, JSON.stringify(o, t == null ? void 0 : t.replacer)), removeItem: i => n.removeItem(i) } } const Hr = e => t => { try { const n = e(t); return n instanceof Promise ? n : { then(r) { return Hr(r)(n) }, catch(r) { return this } } } catch (n) { return { then(r) { return this }, catch(r) { return Hr(r)(n) } } } }, wv = (e, t) => (n, r, i) => { let o = { getStorage: () => localStorage, serialize: JSON.stringify, deserialize: JSON.parse, partialize: E => E, version: 0, merge: (E, d) => ({ ...d, ...E }), ...t }, s = !1; const l = new Set, u = new Set; let a; try { a = o.getStorage() } catch { } if (!a) return e((...E) => { console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`), n(...E) }, r, i); const g = Hr(o.serialize), p = () => { const E = o.partialize({ ...r() }); let d; const c = g({ state: E, version: o.version }).then(h => a.setItem(o.name, h)).catch(h => { d = h }); if (d) throw d; return c }, f = i.setState; i.setState = (E, d) => { f(E, d), p() }; const y = e((...E) => { n(...E), p() }, r, i); let m; const v = () => { var E; if (!a) return; s = !1, l.forEach(c => c(r())); const d = ((E = o.onRehydrateStorage) == null ? void 0 : E.call(o, r())) || void 0; return Hr(a.getItem.bind(a))(o.name).then(c => { if (c) return o.deserialize(c) }).then(c => { if (c) if (typeof c.version == "number" && c.version !== o.version) { if (o.migrate) return o.migrate(c.state, c.version); console.error("State loaded from storage couldn't be migrated since no migrate function was provided") } else return c.state }).then(c => { var h; return m = o.merge(c, (h = r()) != null ? h : y), n(m, !0), p() }).then(() => { d == null || d(m, void 0), s = !0, u.forEach(c => c(m)) }).catch(c => { d == null || d(void 0, c) }) }; return i.persist = { setOptions: E => { o = { ...o, ...E }, E.getStorage && (a = E.getStorage()) }, clearStorage: () => { a == null || a.removeItem(o.name) }, getOptions: () => o, rehydrate: () => v(), hasHydrated: () => s, onHydrate: E => (l.add(E), () => { l.delete(E) }), onFinishHydration: E => (u.add(E), () => { u.delete(E) }) }, v(), m || y }, Ev = (e, t) => (n, r, i) => { let o = { storage: Xf(() => localStorage), partialize: v => v, version: 0, merge: (v, E) => ({ ...E, ...v }), ...t }, s = !1; const l = new Set, u = new Set; let a = o.storage; if (!a) return e((...v) => { console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`), n(...v) }, r, i); const g = () => { const v = o.partialize({ ...r() }); return a.setItem(o.name, { state: v, version: o.version }) }, p = i.setState; i.setState = (v, E) => { p(v, E), g() }; const f = e((...v) => { n(...v), g() }, r, i); let y; const m = () => { var v, E; if (!a) return; s = !1, l.forEach(c => { var h; return c((h = r()) != null ? h : f) }); const d = ((E = o.onRehydrateStorage) == null ? void 0 : E.call(o, (v = r()) != null ? v : f)) || void 0; return Hr(a.getItem.bind(a))(o.name).then(c => { if (c) if (typeof c.version == "number" && c.version !== o.version) { if (o.migrate) return o.migrate(c.state, c.version); console.error("State loaded from storage couldn't be migrated since no migrate function was provided") } else return c.state }).then(c => { var h; return y = o.merge(c, (h = r()) != null ? h : f), n(y, !0), g() }).then(() => { d == null || d(y, void 0), y = r(), s = !0, u.forEach(c => c(y)) }).catch(c => { d == null || d(void 0, c) }) }; return i.persist = { setOptions: v => { o = { ...o, ...v }, v.storage && (a = v.storage) }, clearStorage: () => { a == null || a.removeItem(o.name) }, getOptions: () => o, rehydrate: () => m(), hasHydrated: () => s, onHydrate: v => (l.add(v), () => { l.delete(v) }), onFinishHydration: v => (u.add(v), () => { u.delete(v) }) }, o.skipHydration || m(), y || f }, Cv = (e, t) => "getStorage" in t || "serialize" in t || "deserialize" in t ? wv(e, t) : Ev(e, t), kv = Cv, _v = Sv()(kv((e, t) => ({ games: {}, handleWsMessage: n => { if (typeof n == "string") try { const { kind: r, data: i } = JSON.parse(n); r === "game_update" && e({ games: { ...t().games, [i.id]: i } }) } catch (r) { console.error("Error parsing WebSocket message", r) } else { const r = new FileReader; r.onload = function (i) { var o; if (typeof ((o = i == null ? void 0 : i.target) == null ? void 0 : o.result) == "string") try { const { kind: s, data: l } = JSON.parse(i.target.result); s === "game_update" && e({ games: { ...t().games, [l.id]: l } }) } catch (s) { console.error("Error parsing WebSocket message", s) } }, r.readAsText(n) } }, set: e }), { name: "chess", storage: Xf(() => localStorage) })); const Mt = "/chess:chess:sys"; window.our && (window.our.process = Mt == null ? void 0 : Mt.replace("/", "")); const lc = (e, t) => (e.turns || 0) % 2 === 0 ? t === e.white : t === e.black, xv = void 0; function Ov() { const { games: e, handleWsMessage: t, set: n } = _v(), [r, i] = C.useState("new"), [o, s] = C.useState(""), l = C.useRef(null), [u, a] = C.useState(560 - 20), g = new ResizeObserver(d => { for (let c of d) a(Math.min(c.contentRect.width, c.contentRect.height) - 16) }); l.current && g.observe(l.current); const p = C.useMemo(() => e[r] ? { ...e[r], game: new n0(e[r].board) } : void 0, [e, r]), f = C.useMemo(() => ((p == null ? void 0 : p.turns) || 0) % 2 === 0 ? `${p == null ? void 0 : p.white} (white)` : `${p == null ? void 0 : p.black} (black)`, [p]); C.useEffect(() => { new qm({ uri: xv, nodeId: window.our.node, processId: window.our.process, onMessage: t }), fetch(`${Mt}/games`).then(d => d.json()).then(d => { n({ games: d }) }).catch(console.error) }, []); const y = C.useCallback(async d => { d.preventDefault(); try { const c = await fetch(`${Mt}/games`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ id: o }) }).then(w => { if (w.status === 409) throw e[o] ? i(o) : alert("Game already exists, please refresh the page and select it."), new Error("Game already exists"); if (w.status === 503) throw alert(`${o} may be offline, please confirm it is online and try again.`), new Error("Player offline"); if (w.status === 400) throw alert("Please enter a valid player ID"), new Error("Invalid player ID"); if (w.status > 399) throw alert("There was an error creating the game. Please try again."), new Error("Error creating game"); return w.json() }), h = { ...e }; h[c.id] = c, n({ games: h }), i(o), s("") } catch (c) { console.error(c) } }, [e, o, s, n]), m = C.useCallback((d, c) => { if (!p || !lc(p, window.our.node)) return !1; const h = { from: d, to: c, promotion: "q" }, w = { ...p }; if (w.game.move(h) === null) return !1; w.board = w.game.fen(); const O = { ...e }; return O[p.id] = w, n({ games: O }), fetch(`${Mt}/games`, { method: "PUT", body: JSON.stringify({ id: p.id, move: d + c }) }).then(x => x.json()).then(x => { const T = { ...e }; T[p.id] = x, n({ games: T }) }).catch(x => { console.error(x), alert("There was an error making your move. Please try again"); const T = { ...e }, z = { ...p }; z.game.undo(), T[p.id] = z, n({ games: T }) }), !0 }, [p, e, n]), v = C.useCallback(d => { d.preventDefault(), d.stopPropagation(), p && window.confirm("Are you sure you want to resign this game?") && fetch(`${Mt}/games?id=${p.id}`, { method: "DELETE" }).then(c => c.json()).then(c => { const h = { ...e }; h[p.id] = c, n({ games: h }) }).catch(c => { console.error(c), alert("There was an error resigning the game. Please try again") }) }, [p]), E = C.useCallback(async d => { if (d.preventDefault(), d.stopPropagation(), !!p) try { const c = await fetch(`${Mt}/games`, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ id: p.id }) }).then(w => w.json()), h = { ...e }; h[c.id] = c, n({ games: h }) } catch (c) { console.error(c), alert("You could not create the game. Please make sure your current game with this player (if any) has ended and try again.") } }, [p]); return S.jsx("div", { className: "flex flex-col justify-center items-center", children: S.jsxs("div", { className: "flex flex-col justify-center", style: { maxHeight: "100vh", maxWidth: "800px", width: "100%", position: "relative" }, children: [S.jsx("a", { href: "/", className: "absolute top-6 left-0 m-4", style: { fontSize: 24, color: "white" }, onClick: d => { d.preventDefault(), window.history.back() }, children: " Back" }), S.jsx("h1", { className: "m-4", children: "Chess by kinode" }), S.jsxs("div", { className: "flex flex-row justify-center items-center h-screen border rounded", children: [Object.keys(e).length > 0 && S.jsxs("div", { className: "flex flex-col border-r", style: { width: "25%", height: "100%" }, children: [S.jsx("h3", { className: "m-2", children: "Games" }), S.jsx("button", { className: "font-bold py-2 px-4 m-2 rounded", onClick: () => i("new"), children: "New" }), S.jsx("div", { className: "flex flex-col overflow-scroll", children: Object.values(e).map(d => S.jsx("div", { onClick: () => i(d == null ? void 0 : d.id), className: `game-entry m-2 ${r !== (d == null ? void 0 : d.id) && lc(d, window.our.node) ? "is-turn" : ""} ${r === (d == null ? void 0 : d.id) ? "selected" : ""} ${d != null && d.ended ? "ended" : ""}`, children: d == null ? void 0 : d.id }, d == null ? void 0 : d.id)) })] }), S.jsx("div", { className: "flex flex-col justify-center items-center", style: { width: "75%" }, ref: l, children: r === "new" || !p ? S.jsxs(S.Fragment, { children: [S.jsx("h2", { className: "mb-2", children: "Start New Game" }), S.jsx("h4", { className: "mb-2", children: "(game creator will be white)" }), S.jsxs("form", { onSubmit: y, className: "flex flex-col justify-center mb-40", style: { maxWidth: 400 }, children: [S.jsx("label", { className: "mb-2", style: { alignSelf: "flex-start", fontWeight: "600" }, children: "Player ID" }), S.jsx("input", { className: "border rounded p-2 mb-2", style: { color: "black", minWidth: 300 }, type: "text", placeholder: "Player ID", value: o, onChange: d => s(d.target.value) }), S.jsx("button", { className: "font-bold py-2 px-4 rounded", type: "submit", children: "Start Game" })] })] }) : S.jsxs(S.Fragment, { children: [S.jsxs("div", { className: "flex flex-row justify-between items-center w-full px-4 pb-2", children: [S.jsx("h3", { children: r }), S.jsx("h4", { children: p != null && p.ended ? "Game Ended" : `Turn: ${f}` }), p != null && p.ended ? S.jsx("button", { className: "font-bold py-1 px-4 rounded", onClick: E, children: "Rematch" }) : S.jsx("button", { className: "font-bold py-1 px-4 rounded", onClick: v, children: "Resign" })] }), S.jsx(Qm, { boardWidth: u, position: p == null ? void 0 : p.game.fen(), onPieceDrop: m, boardOrientation: (p == null ? void 0 : p.white) === window.our.node ? "white" : "black" })] }) })] })] }) }) } Es.createRoot(document.getElementById("root")).render(S.jsx(yc.StrictMode, { children: S.jsx(Ov, {}) }));

use crate::v1::wit;
use serde::{Deserialize, Serialize};
use std::hash::{Hash, Hasher};
use thiserror::Error;

pub use crate::{fd_manager::*, kernel::*, kv::*, net::*, sqlite::*, state::*, timer::*, vfs::*};

lazy_static::lazy_static! {
    pub static ref ETH_PROCESS_ID: ProcessId = ProcessId::new(Some("eth"), "distro", "sys");
    pub static ref FD_MANAGER_PROCESS_ID: ProcessId = ProcessId::new(Some("fd-manager"), "distro", "sys");
    pub static ref HTTP_CLIENT_PROCESS_ID: ProcessId = ProcessId::new(Some("http-client"), "distro", "sys");
    pub static ref HTTP_SERVER_PROCESS_ID: ProcessId = ProcessId::new(Some("http-server"), "distro", "sys");
    pub static ref KERNEL_PROCESS_ID: ProcessId = ProcessId::new(Some("kernel"), "distro", "sys");
    pub static ref KV_PROCESS_ID: ProcessId = ProcessId::new(Some("kv"), "distro", "sys");
    pub static ref NET_PROCESS_ID: ProcessId = ProcessId::new(Some("net"), "distro", "sys");
    pub static ref STATE_PROCESS_ID: ProcessId = ProcessId::new(Some("state"), "distro", "sys");
    pub static ref SQLITE_PROCESS_ID: ProcessId = ProcessId::new(Some("sqlite"), "distro", "sys");
    pub static ref TERMINAL_PROCESS_ID: ProcessId = ProcessId::new(Some("terminal"), "terminal", "sys");
    pub static ref TIMER_PROCESS_ID: ProcessId = ProcessId::new(Some("timer"), "distro", "sys");
    pub static ref VFS_PROCESS_ID: ProcessId = ProcessId::new(Some("vfs"), "distro", "sys");
}

//
// Types shared between kernel and processes generated by `hyperware.wit`.
// This is a copy of the types in `process_lib`. Even though the types
// are identical, they will not match when used in the kernel context
// which generates bindings differently than the process standard library.
// Make sure to keep this synced with process_lib.
//

pub type Context = Vec<u8>;
pub type NodeId = String; // HNS domain name

/// Determine if the given `input` string is Hypermap-safe or not.
/// A Hypermap-safe string contains only lowercase alphanumeric characters, `-`, and `.`.
/// Because Hypermap entries are delimited by `.`s, `.`s are also somewhat restricted.
/// E.g., in `ProcessId`s, neither process name nor package name can contain `.`s.
/// `is_hypermap_safe()` allows `.`s.
/// Use `is_hypermap_safe_no_dots()` to disallow `.`s.
pub fn is_hypermap_safe(input: &str) -> bool {
    let expression = r"^[a-z0-9\-.]+$";
    let re = regex::Regex::new(expression).unwrap();
    re.is_match(input)
}

/// Determine if the given `input` string is Hypermap-safe or not.
/// A Hypermap-safe string contains only lowercase alphanumeric characters, `-`, and `.`.
/// Because Hypermap entries are delimited by `.`s, `.`s are also somewhat restricted.
/// E.g., in `ProcessId`s, neither process name nor package name can contain `.`s.
/// `is_hypermap_safe_no_dots()` disallows `.`s.
/// Use `is_hypermap_safe()` to allow `.`s.
pub fn is_hypermap_safe_no_dots(input: &str) -> bool {
    let expression = r"^[a-z0-9\-]+$";
    let re = regex::Regex::new(expression).unwrap();
    re.is_match(input)
}

pub fn check_process_id_hypermap_safe(p: &ProcessId) -> Result<(), AddressParseError> {
    if !is_hypermap_safe_no_dots(&p.process_name) {
        return Err(AddressParseError::ProcessNameNotHypermapSafe(
            p.process_name.clone(),
        ));
    }
    if !is_hypermap_safe_no_dots(&p.package_name) {
        return Err(AddressParseError::PackageNameNotHypermapSafe(
            p.package_name.clone(),
        ));
    }
    if !is_hypermap_safe(&p.publisher_node) {
        return Err(AddressParseError::PublisherNodeNotHypermapSafe(
            p.publisher_node.clone(),
        ));
    }
    Ok(())
}

/// process ID is a formatted unique identifier that contains
/// the publishing node's ID, the package name, and finally the process name.
/// the process name can be a random number, or a name chosen by the user.
/// the formatting is as follows:
/// `[process name]:[package name]:[node ID]`
#[derive(Clone, Debug, Eq, PartialEq, Hash)]
pub struct ProcessId {
    process_name: String,
    package_name: String,
    publisher_node: NodeId,
}

impl Serialize for ProcessId {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        format!("{}", self).serialize(serializer)
    }
}

impl<'a> Deserialize<'a> for ProcessId {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'a>,
    {
        // TODO make this never crash!
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

/// ProcessId is defined in the wit bindings, but constructors and methods
/// are defined here.
impl ProcessId {
    /// generates a random u64 number if process_name is not declared
    pub fn new(process_name: Option<&str>, package_name: &str, publisher_node: &str) -> Self {
        let process_name = process_name
            .unwrap_or(&rand::random::<u64>().to_string())
            .to_string();
        let process_id = ProcessId {
            process_name,
            package_name: package_name.to_string(),
            publisher_node: publisher_node.to_string(),
        };
        process_id
    }
    pub fn process(&self) -> &str {
        &self.process_name
    }
    pub fn package(&self) -> &str {
        &self.package_name
    }
    pub fn publisher(&self) -> &str {
        &self.publisher_node
    }
    pub fn en_wit(&self) -> wit::ProcessId {
        wit::ProcessId {
            process_name: self.process_name.clone(),
            package_name: self.package_name.clone(),
            publisher_node: self.publisher_node.clone(),
        }
    }
    pub fn de_wit(wit: wit::ProcessId) -> Self {
        ProcessId {
            process_name: wit.process_name,
            package_name: wit.package_name,
            publisher_node: wit.publisher_node,
        }
    }
    pub fn check(self) -> Result<Self, AddressParseError> {
        check_process_id_hypermap_safe(&self)?;
        Ok(self)
    }
}

impl std::str::FromStr for ProcessId {
    type Err = AddressParseError;
    /// Attempts to parse a `ProcessId` from a string. To succeed, the string must contain
    /// exactly 3 segments, separated by colons `:`. The segments must not contain colons.
    /// Please note that while any string without colons will parse successfully
    /// to create a `ProcessId`, not all strings without colons are actually
    /// valid usernames, which the `publisher_node` field of a `ProcessId` will
    /// always in practice be.
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        let segments: Vec<&str> = input.split(':').collect();
        if segments.len() < 3 {
            return Err(AddressParseError::MissingField);
        } else if segments.len() > 3 {
            return Err(AddressParseError::TooManyColons);
        }
        let process_name = segments[0];
        if process_name.is_empty() {
            return Err(AddressParseError::MissingField);
        }
        let package_name = segments[1];
        if package_name.is_empty() {
            return Err(AddressParseError::MissingField);
        }
        let publisher_node = segments[2];
        if publisher_node.is_empty() {
            return Err(AddressParseError::MissingField);
        }
        Ok(ProcessId::new(
            Some(process_name),
            package_name,
            publisher_node,
        ))
    }
}

impl From<(&str, &str, &str)> for ProcessId {
    fn from(input: (&str, &str, &str)) -> Self {
        ProcessId::new(Some(input.0), input.1, input.2)
    }
}

impl From<&ProcessId> for ProcessId {
    fn from(input: &ProcessId) -> Self {
        input.clone()
    }
}

impl std::fmt::Display for ProcessId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}:{}:{}",
            self.process_name, self.package_name, self.publisher_node
        )
    }
}

impl PartialEq<&str> for ProcessId {
    fn eq(&self, other: &&str) -> bool {
        &self.to_string() == other
    }
}

impl PartialEq<ProcessId> for &str {
    fn eq(&self, other: &ProcessId) -> bool {
        self == &other.to_string()
    }
}

/// PackageId is like a ProcessId, but for a package. Only contains the name
/// of the package and the name of the publisher.
#[derive(Hash, Eq, PartialEq, Debug, Clone, Serialize, Deserialize)]
pub struct PackageId {
    package_name: String,
    publisher_node: String,
}

impl PackageId {
    pub fn new(package_name: &str, publisher_node: &str) -> Self {
        PackageId {
            package_name: package_name.to_string(),
            publisher_node: publisher_node.to_string(),
        }
    }
    pub fn _package(&self) -> &str {
        &self.package_name
    }
    pub fn _publisher(&self) -> &str {
        &self.publisher_node
    }
    pub fn check(self) -> Result<Self, AddressParseError> {
        if !is_hypermap_safe_no_dots(&self.package_name) {
            return Err(AddressParseError::ProcessNameNotHypermapSafe(
                self.package_name.clone(),
            ));
        }
        if !is_hypermap_safe(&self.publisher_node) {
            return Err(AddressParseError::PublisherNodeNotHypermapSafe(
                self.publisher_node.clone(),
            ));
        }
        Ok(self)
    }
}

impl std::str::FromStr for PackageId {
    type Err = AddressParseError;
    /// Attempt to parse a `PackageId` from a string. The string must
    /// contain exactly two segments, where segments are non-empty strings
    /// separated by a colon (`:`). The segments cannot themselves contain colons.
    ///
    /// Please note that while any string without colons will parse successfully
    /// to create a `PackageId`, not all strings without colons are actually
    /// valid usernames, which the `publisher_node` field of a `PackageId` will
    /// always in practice be.
    fn from_str(input: &str) -> Result<Self, Self::Err> {
        let segments: Vec<&str> = input.split(':').collect();
        if segments.len() < 2 {
            return Err(AddressParseError::MissingField);
        } else if segments.len() > 2 {
            return Err(AddressParseError::TooManyColons);
        }
        let package_name = segments[0];
        if package_name.is_empty() {
            return Err(AddressParseError::MissingField);
        }
        let publisher_node = segments[1];
        if publisher_node.is_empty() {
            return Err(AddressParseError::MissingField);
        }
        Ok(PackageId::new(package_name, publisher_node))
    }
}

impl std::fmt::Display for PackageId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}:{}", self.package_name, self.publisher_node)
    }
}

/// An address is a node ID and a process ID, to uniquely globally identify a process.
/// The [`NodeId`] is the HNS name of the node that the process is running on.
#[derive(Clone, Debug, Hash, Eq, PartialEq)]
pub struct Address {
    pub node: NodeId,
    pub process: ProcessId,
}

impl Address {
    pub fn new<T, U>(node: T, process: U) -> Self
    where
        T: Into<String>,
        U: Into<ProcessId>,
    {
        let node = node.into();
        let process = process.into();
        Address { node, process }
    }
    pub fn en_wit(&self) -> wit::Address {
        wit::Address {
            node: self.node.clone(),
            process: self.process.en_wit(),
        }
    }
    pub fn de_wit(wit: wit::Address) -> Address {
        Address {
            node: wit.node,
            process: ProcessId {
                process_name: wit.process.process_name,
                package_name: wit.process.package_name,
                publisher_node: wit.process.publisher_node,
            },
        }
    }
    pub fn check(self) -> Result<Self, AddressParseError> {
        if !is_hypermap_safe(&self.node) {
            return Err(AddressParseError::NodeNotHypermapSafe(self.node.clone()));
        }
        check_process_id_hypermap_safe(&self.process)?;
        Ok(self)
    }
}

impl std::str::FromStr for Address {
    type Err = AddressParseError;
    /// Attempt to parse an `Address` from a string. The formatting structure for
    /// an Address is `node@process_name:package_name:publisher_node`.
    ///
    /// The string being parsed must contain exactly one `@` and three `:` characters.
    /// The `@` character separates the node ID from the rest of the address, and the
    /// `:` characters separate the process name, package name, and publisher node ID.
    fn from_str(input: &str) -> Result<Self, AddressParseError> {
        // split string on '@' and ensure there is exactly one '@'
        let parts: Vec<&str> = input.split('@').collect();
        if parts.len() < 2 {
            return Err(AddressParseError::MissingNodeId);
        } else if parts.len() > 2 {
            return Err(AddressParseError::TooManyAts);
        }
        let node = parts[0];
        if node.is_empty() {
            return Err(AddressParseError::MissingNodeId);
        }

        // split the rest on ':' and ensure there are exactly three ':'
        let segments: Vec<&str> = parts[1].split(':').collect();
        if segments.len() < 3 {
            return Err(AddressParseError::MissingField);
        } else if segments.len() > 3 {
            return Err(AddressParseError::TooManyColons);
        }
        let process_name = segments[0];
        if process_name.is_empty() {
            return Err(AddressParseError::MissingField);
        }
        let package_name = segments[1];
        if package_name.is_empty() {
            return Err(AddressParseError::MissingField);
        }
        let publisher_node = segments[2];
        if publisher_node.is_empty() {
            return Err(AddressParseError::MissingField);
        }
        Ok(Address::new(
            node,
            (process_name, package_name, publisher_node),
        ))
    }
}

impl Serialize for Address {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        format!("{}", self).serialize(serializer)
    }
}

impl<'a> Deserialize<'a> for Address {
    fn deserialize<D>(deserializer: D) -> Result<Address, D::Error>
    where
        D: serde::de::Deserializer<'a>,
    {
        // TODO make this never crash!
        let s = String::deserialize(deserializer)?;
        s.parse().map_err(serde::de::Error::custom)
    }
}

impl From<(&str, &str, &str, &str)> for Address {
    fn from(input: (&str, &str, &str, &str)) -> Self {
        Address::new(input.0, (input.1, input.2, input.3))
    }
}

impl<T, U> From<(T, U)> for Address
where
    T: Into<String>,
    U: Into<ProcessId>,
{
    fn from(input: (T, U)) -> Self {
        Address::new(input.0, input.1)
    }
}

impl std::fmt::Display for Address {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}@{}", self.node, self.process)
    }
}

/// Errors that can occur when parsing a [`Address`] from a string.
/// Also used for [`ProcessId`] and [`PackageId`].
#[derive(Error, Debug)]
pub enum AddressParseError {
    #[error("Too many `@` chars: only one allowed")]
    TooManyAts,
    #[error("Too many colons in ProcessId string")]
    TooManyColons,
    #[error("Node ID missing")]
    MissingNodeId,
    #[error("Missing field in ProcessId string")]
    MissingField,
    #[error("Process name ({0}) can only contain a-z, 0-9, `-`")]
    ProcessNameNotHypermapSafe(String),
    #[error("Package name ({0}) can only contain a-z, 0-9, `-`")]
    PackageNameNotHypermapSafe(String),
    #[error("Node ({0}) can only contain a-z, 0-9, `-`, `.`")]
    NodeNotHypermapSafe(String),
    #[error("Publisher node ({0}) can only contain a-z, 0-9, `-`, `.`")]
    PublisherNodeNotHypermapSafe(String),
    #[error("Other: {0}")]
    Other(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct LazyLoadBlob {
    pub mime: Option<String>, // MIME type
    pub bytes: Vec<u8>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Request {
    pub inherit: bool,
    pub expects_response: Option<u64>, // number of seconds until timeout
    pub body: Vec<u8>,
    pub metadata: Option<String>, // JSON-string
    pub capabilities: Vec<(Capability, Vec<u8>)>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct Response {
    pub inherit: bool,
    pub body: Vec<u8>,
    pub metadata: Option<String>, // JSON-string
    pub capabilities: Vec<(Capability, Vec<u8>)>,
}

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum Message {
    Request(Request),
    Response((Response, Option<Context>)),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Capability {
    pub issuer: Address,
    pub params: String,
}

impl Eq for Capability {}

impl PartialEq for Capability {
    fn eq(&self, other: &Self) -> bool {
        let self_json_params: serde_json::Value =
            serde_json::from_str(&self.params).unwrap_or_default();
        let other_json_params: serde_json::Value =
            serde_json::from_str(&other.params).unwrap_or_default();
        self.issuer == other.issuer && self_json_params == other_json_params
    }
}

impl Hash for Capability {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.issuer.hash(state);
        let params: serde_json::Value = serde_json::from_str(&self.params).unwrap_or_default();
        params.hash(state);
    }
}

impl Capability {
    pub fn new<T, U>(issuer: T, params: U) -> Self
    where
        T: Into<Address>,
        U: Into<String>,
    {
        Capability {
            issuer: issuer.into(),
            params: params.into(),
        }
    }

    pub fn messaging<T>(issuer: T) -> Self
    where
        T: Into<Address>,
    {
        Capability {
            issuer: issuer.into(),
            params: "\"messaging\"".into(),
        }
    }
}

impl std::fmt::Display for Capability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{}({})",
            self.issuer,
            serde_json::from_str::<serde_json::Value>(&self.params)
                .unwrap_or(serde_json::json!("invalid JSON in capability"))
        )
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SendError {
    pub kind: SendErrorKind,
    pub target: Address,
    pub message: Message,
    pub lazy_load_blob: Option<LazyLoadBlob>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum SendErrorKind {
    Offline,
    Timeout,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum OnExit {
    None,
    Restart,
    Requests(Vec<(Address, Request, Option<LazyLoadBlob>)>),
}

impl OnExit {
    pub fn is_restart(&self) -> bool {
        match self {
            OnExit::None => false,
            OnExit::Restart => true,
            OnExit::Requests(_) => false,
        }
    }

    pub fn is_none(&self) -> bool {
        match self {
            OnExit::None => true,
            OnExit::Restart => false,
            OnExit::Requests(_) => false,
        }
    }

    pub fn en_wit(&self) -> wit::OnExit {
        match self {
            OnExit::None => wit::OnExit::None,
            OnExit::Restart => wit::OnExit::Restart,
            OnExit::Requests(reqs) => wit::OnExit::Requests(
                reqs.iter()
                    .map(|(address, request, blob)| {
                        (
                            address.en_wit(),
                            en_wit_request(request.clone()),
                            en_wit_blob(blob.clone()),
                        )
                    })
                    .collect(),
            ),
        }
    }

    pub fn de_wit(wit: wit::OnExit) -> Self {
        match wit {
            wit::OnExit::None => OnExit::None,
            wit::OnExit::Restart => OnExit::Restart,
            wit::OnExit::Requests(reqs) => OnExit::Requests(
                reqs.into_iter()
                    .map(|(address, request, blob)| {
                        (
                            Address::de_wit(address),
                            de_wit_request(request),
                            de_wit_blob(blob),
                        )
                    })
                    .collect(),
            ),
        }
    }
}

impl std::fmt::Display for OnExit {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(
            f,
            "{}",
            match self {
                OnExit::None => "None",
                OnExit::Restart => "Restart",
                OnExit::Requests(_) => "Requests",
            }
        )
    }
}

impl std::fmt::Display for Message {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}", display_message(self, "\n    "))
    }
}

fn display_capabilities(capabilities: &Vec<(Capability, Vec<u8>)>, delimiter: &str) -> String {
    if capabilities.is_empty() {
        return "[],".to_string();
    }

    let mut caps_string = "[".to_string();
    for cap in capabilities.iter() {
        caps_string += &format!("{}    {}", delimiter, cap.0.to_string());
    }
    format!("{}{}]", caps_string, delimiter)
}

pub fn display_message(m: &Message, delimiter: &str) -> String {
    let lines = match m {
        Message::Request(request) => {
            vec![
                "Request(".into(),
                format!("inherit: {},", request.inherit),
                format!("expects_response: {:?},", request.expects_response),
                format!(
                    "body: {},",
                    match std::str::from_utf8(&request.body) {
                        Ok(str) => str.to_string(),
                        Err(_) => format!("{:?}", request.body),
                    }
                ),
                format!(
                    "metadata: {},",
                    &request.metadata.as_ref().unwrap_or(&"None".into())
                ),
                format!(
                    "capabilities: {}",
                    display_capabilities(&request.capabilities, delimiter)
                ),
            ]
        }
        Message::Response((response, context)) => {
            vec![
                "Response(".into(),
                format!("inherit: {},", response.inherit),
                format!(
                    "body: {},",
                    match serde_json::from_slice::<serde_json::Value>(&response.body) {
                        Ok(json) => format!("{}", json),
                        Err(_) => format!("{:?}", response.body),
                    }
                ),
                format!(
                    "metadata: {},",
                    &response.metadata.as_ref().unwrap_or(&"None".into())
                ),
                format!(
                    "context: {},",
                    if context.is_none() {
                        "None".into()
                    } else {
                        match serde_json::from_slice::<serde_json::Value>(context.as_ref().unwrap())
                        {
                            Ok(json) => format!("{}", json),
                            Err(_) => format!("{:?}", context.as_ref().unwrap()),
                        }
                    },
                ),
                format!(
                    "capabilities: {}",
                    display_capabilities(&response.capabilities, delimiter)
                ),
            ]
        }
    };
    lines.into_iter().collect::<Vec<_>>().join(delimiter) + &delimiter[..delimiter.len() - 4] + ")"
}

//
// conversions between wit types and kernel types (annoying!)
//

pub fn de_wit_request(wit: wit::Request) -> Request {
    Request {
        inherit: wit.inherit,
        expects_response: wit.expects_response,
        body: wit.body,
        metadata: wit.metadata,
        capabilities: wit
            .capabilities
            .into_iter()
            .map(|cap| de_wit_capability(cap))
            .collect(),
    }
}

pub fn en_wit_request(request: Request) -> wit::Request {
    wit::Request {
        inherit: request.inherit,
        expects_response: request.expects_response,
        body: request.body,
        metadata: request.metadata,
        capabilities: request
            .capabilities
            .into_iter()
            .map(|cap| en_wit_capability(cap))
            .collect(),
    }
}

pub fn de_wit_response(wit: wit::Response) -> Response {
    Response {
        inherit: wit.inherit,
        body: wit.body,
        metadata: wit.metadata,
        capabilities: wit
            .capabilities
            .into_iter()
            .map(|cap| de_wit_capability(cap))
            .collect(),
    }
}

pub fn en_wit_response(response: Response) -> wit::Response {
    wit::Response {
        inherit: response.inherit,
        body: response.body,
        metadata: response.metadata,
        capabilities: response
            .capabilities
            .into_iter()
            .map(|cap| en_wit_capability(cap))
            .collect(),
    }
}

pub fn de_wit_blob(wit: Option<wit::LazyLoadBlob>) -> Option<LazyLoadBlob> {
    match wit {
        None => None,
        Some(wit) => Some(LazyLoadBlob {
            mime: wit.mime,
            bytes: wit.bytes,
        }),
    }
}

pub fn en_wit_blob(load: Option<LazyLoadBlob>) -> Option<wit::LazyLoadBlob> {
    match load {
        None => None,
        Some(load) => Some(wit::LazyLoadBlob {
            mime: load.mime,
            bytes: load.bytes,
        }),
    }
}

pub fn de_wit_capability(wit: wit::Capability) -> (Capability, Vec<u8>) {
    (
        Capability {
            issuer: Address {
                node: wit.issuer.node,
                process: ProcessId {
                    process_name: wit.issuer.process.process_name,
                    package_name: wit.issuer.process.package_name,
                    publisher_node: wit.issuer.process.publisher_node,
                },
            },
            params: wit.params,
        },
        vec![],
    )
}

pub fn en_wit_capability(cap: (Capability, Vec<u8>)) -> wit::Capability {
    wit::Capability {
        issuer: cap.0.issuer.en_wit(),
        params: cap.0.params,
    }
}

pub fn en_wit_message(message: Message) -> wit::Message {
    match message {
        Message::Request(request) => wit::Message::Request(en_wit_request(request)),
        Message::Response((response, context)) => {
            wit::Message::Response((en_wit_response(response), context))
        }
    }
}

pub fn en_wit_send_error(error: SendError) -> wit::SendError {
    wit::SendError {
        kind: en_wit_send_error_kind(error.kind),
        target: error.target.en_wit(),
        message: en_wit_message(error.message),
        lazy_load_blob: en_wit_blob(error.lazy_load_blob),
    }
}

pub fn en_wit_send_error_kind(kind: SendErrorKind) -> wit::SendErrorKind {
    match kind {
        SendErrorKind::Offline => wit::SendErrorKind::Offline,
        SendErrorKind::Timeout => wit::SendErrorKind::Timeout,
    }
}
